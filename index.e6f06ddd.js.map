{"mappings":"IKkCI,EACA,E,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,MJ2BA,EACA,EACA,E,E,E,O,C,Y,I,G,I,E,E,S,E,E,S,E,E,QAEJ,OAAM,UAAkB,EAAA,MAAK,CAE5B,YAAa,CAAO,CAAG,CAEtB,KAAK,CAAE,EAER,CAEA,KAAM,CAAG,CAAE,CAAM,CAAE,CAAU,CAAE,CAAO,CAAG,CAExC,IAAM,EAAQ,IAAI,CAEZ,EAAO,AAAiB,KAAjB,EAAQ,IAAI,CAAY,AAAA,CAAA,EAAA,EAAA,WAAU,AAAV,EAAY,cAAc,CAAE,GAAQ,EAAM,IAAI,CAE7E,EAAS,IAAI,EAAA,UAAS,CAAG,IAAI,CAAC,OAAO,EAC3C,EAAO,OAAO,CAAE,EAAM,IAAI,EAC1B,EAAO,eAAe,CAAE,eACxB,EAAO,gBAAgB,CAAE,EAAM,aAAa,EAC5C,EAAO,kBAAkB,CAAE,EAAM,eAAe,EAEhD,EAAO,IAAI,CAAE,EAAK,SAAW,CAAM,EAElC,GAAI,CAEH,EAAQ,EAAM,KAAK,CAAE,EAAQ,GAE9B,CAAE,MAAQ,EAAI,CAER,EAEJ,EAAS,GAIT,QAAQ,KAAK,CAAE,GAIhB,EAAM,OAAO,CAAC,SAAS,CAAE,EAE1B,CAED,EAAG,EAAY,EAEhB,CAEA,MAAO,CAAS,CAAE,CAAI,CAAG,CAExB,GAAK,AAqpHP,SAA4B,CAAM,EAEjC,IAAM,EAAU,yBAEhB,OAAO,EAAO,UAAU,EAAI,EAAQ,MAAM,EAAI,IAAY,EAA4B,EAAQ,EAAG,EAAQ,MAAM,CAEhH,EA3pH0B,GAEvB,EAAU,IAAI,IAAe,KAAK,CAAE,OAE9B,CAEN,IAAM,EAAU,EAA4B,GAE5C,GAAK,CAAE,AAqpHV,SAA2B,C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","sources":["<anon>","node_modules/three/examples/jsm/loaders/FBXLoader.js","node_modules/three/examples/jsm/libs/fflate.module.js","node_modules/three/examples/jsm/curves/NURBSCurve.js","node_modules/three/examples/jsm/curves/NURBSUtils.js","src/js/3D_thing copy.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire3abd\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire3abd\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"qgTqt\", function(module, exports) {\n\n$parcel$export(module.exports, \"FBXLoader\", () => $04ef886a022e9ae8$export$60c52e42bb04b96);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $79Zxq = parcelRequire(\"79Zxq\");\n\nvar $cLt9Z = parcelRequire(\"cLt9Z\");\n/**\n * Loader loads FBX file and generates Group representing FBX scene.\n * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format\n * Versions lower than this may load but will probably have errors\n *\n * Needs Support:\n *  Morph normals / blend shape normals\n *\n * FBX format references:\n * \thttps://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)\n *\n * Binary format specification:\n *\thttps://code.blender.org/2013/08/fbx-binary-file-format-specification/\n */ let $04ef886a022e9ae8$var$fbxTree;\nlet $04ef886a022e9ae8$var$connections;\nlet $04ef886a022e9ae8$var$sceneGraph;\nclass $04ef886a022e9ae8$export$60c52e42bb04b96 extends (0, $ilwiq.Loader) {\n    constructor(manager){\n        super(manager);\n    }\n    load(url, onLoad, onProgress, onError) {\n        const scope = this;\n        const path = scope.path === \"\" ? (0, $ilwiq.LoaderUtils).extractUrlBase(url) : scope.path;\n        const loader = new (0, $ilwiq.FileLoader)(this.manager);\n        loader.setPath(scope.path);\n        loader.setResponseType(\"arraybuffer\");\n        loader.setRequestHeader(scope.requestHeader);\n        loader.setWithCredentials(scope.withCredentials);\n        loader.load(url, function(buffer) {\n            try {\n                onLoad(scope.parse(buffer, path));\n            } catch (e) {\n                if (onError) onError(e);\n                else console.error(e);\n                scope.manager.itemError(url);\n            }\n        }, onProgress, onError);\n    }\n    parse(FBXBuffer, path) {\n        if ($04ef886a022e9ae8$var$isFbxFormatBinary(FBXBuffer)) $04ef886a022e9ae8$var$fbxTree = new $04ef886a022e9ae8$var$BinaryParser().parse(FBXBuffer);\n        else {\n            const FBXText = $04ef886a022e9ae8$var$convertArrayBufferToString(FBXBuffer);\n            if (!$04ef886a022e9ae8$var$isFbxFormatASCII(FBXText)) throw new Error(\"THREE.FBXLoader: Unknown format.\");\n            if ($04ef886a022e9ae8$var$getFbxVersion(FBXText) < 7000) throw new Error(\"THREE.FBXLoader: FBX version not supported, FileVersion: \" + $04ef886a022e9ae8$var$getFbxVersion(FBXText));\n            $04ef886a022e9ae8$var$fbxTree = new $04ef886a022e9ae8$var$TextParser().parse(FBXText);\n        }\n        // console.log( fbxTree );\n        const textureLoader = new (0, $ilwiq.TextureLoader)(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n        return new $04ef886a022e9ae8$var$FBXTreeParser(textureLoader, this.manager).parse($04ef886a022e9ae8$var$fbxTree);\n    }\n}\n// Parse the FBXTree object returned by the BinaryParser or TextParser and return a Group\nclass $04ef886a022e9ae8$var$FBXTreeParser {\n    constructor(textureLoader, manager){\n        this.textureLoader = textureLoader;\n        this.manager = manager;\n    }\n    parse() {\n        $04ef886a022e9ae8$var$connections = this.parseConnections();\n        const images = this.parseImages();\n        const textures = this.parseTextures(images);\n        const materials = this.parseMaterials(textures);\n        const deformers = this.parseDeformers();\n        const geometryMap = new $04ef886a022e9ae8$var$GeometryParser().parse(deformers);\n        this.parseScene(deformers, geometryMap, materials);\n        return $04ef886a022e9ae8$var$sceneGraph;\n    }\n    // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )\n    // and details the connection type\n    parseConnections() {\n        const connectionMap = new Map();\n        if (\"Connections\" in $04ef886a022e9ae8$var$fbxTree) {\n            const rawConnections = $04ef886a022e9ae8$var$fbxTree.Connections.connections;\n            rawConnections.forEach(function(rawConnection) {\n                const fromID = rawConnection[0];\n                const toID = rawConnection[1];\n                const relationship = rawConnection[2];\n                if (!connectionMap.has(fromID)) connectionMap.set(fromID, {\n                    parents: [],\n                    children: []\n                });\n                const parentRelationship = {\n                    ID: toID,\n                    relationship: relationship\n                };\n                connectionMap.get(fromID).parents.push(parentRelationship);\n                if (!connectionMap.has(toID)) connectionMap.set(toID, {\n                    parents: [],\n                    children: []\n                });\n                const childRelationship = {\n                    ID: fromID,\n                    relationship: relationship\n                };\n                connectionMap.get(toID).children.push(childRelationship);\n            });\n        }\n        return connectionMap;\n    }\n    // Parse FBXTree.Objects.Video for embedded image data\n    // These images are connected to textures in FBXTree.Objects.Textures\n    // via FBXTree.Connections.\n    parseImages() {\n        const images = {};\n        const blobs = {};\n        if (\"Video\" in $04ef886a022e9ae8$var$fbxTree.Objects) {\n            const videoNodes = $04ef886a022e9ae8$var$fbxTree.Objects.Video;\n            for(const nodeID in videoNodes){\n                const videoNode = videoNodes[nodeID];\n                const id = parseInt(nodeID);\n                images[id] = videoNode.RelativeFilename || videoNode.Filename;\n                // raw image data is in videoNode.Content\n                if (\"Content\" in videoNode) {\n                    const arrayBufferContent = videoNode.Content instanceof ArrayBuffer && videoNode.Content.byteLength > 0;\n                    const base64Content = typeof videoNode.Content === \"string\" && videoNode.Content !== \"\";\n                    if (arrayBufferContent || base64Content) {\n                        const image = this.parseImage(videoNodes[nodeID]);\n                        blobs[videoNode.RelativeFilename || videoNode.Filename] = image;\n                    }\n                }\n            }\n        }\n        for(const id in images){\n            const filename = images[id];\n            if (blobs[filename] !== undefined) images[id] = blobs[filename];\n            else images[id] = images[id].split(\"\\\\\").pop();\n        }\n        return images;\n    }\n    // Parse embedded image data in FBXTree.Video.Content\n    parseImage(videoNode) {\n        const content = videoNode.Content;\n        const fileName = videoNode.RelativeFilename || videoNode.Filename;\n        const extension = fileName.slice(fileName.lastIndexOf(\".\") + 1).toLowerCase();\n        let type;\n        switch(extension){\n            case \"bmp\":\n                type = \"image/bmp\";\n                break;\n            case \"jpg\":\n            case \"jpeg\":\n                type = \"image/jpeg\";\n                break;\n            case \"png\":\n                type = \"image/png\";\n                break;\n            case \"tif\":\n                type = \"image/tiff\";\n                break;\n            case \"tga\":\n                if (this.manager.getHandler(\".tga\") === null) console.warn(\"FBXLoader: TGA loader not found, skipping \", fileName);\n                type = \"image/tga\";\n                break;\n            default:\n                console.warn('FBXLoader: Image type \"' + extension + '\" is not supported.');\n                return;\n        }\n        if (typeof content === \"string\") return \"data:\" + type + \";base64,\" + content;\n        else {\n            const array = new Uint8Array(content);\n            return window.URL.createObjectURL(new Blob([\n                array\n            ], {\n                type: type\n            }));\n        }\n    }\n    // Parse nodes in FBXTree.Objects.Texture\n    // These contain details such as UV scaling, cropping, rotation etc and are connected\n    // to images in FBXTree.Objects.Video\n    parseTextures(images) {\n        const textureMap = new Map();\n        if (\"Texture\" in $04ef886a022e9ae8$var$fbxTree.Objects) {\n            const textureNodes = $04ef886a022e9ae8$var$fbxTree.Objects.Texture;\n            for(const nodeID in textureNodes){\n                const texture = this.parseTexture(textureNodes[nodeID], images);\n                textureMap.set(parseInt(nodeID), texture);\n            }\n        }\n        return textureMap;\n    }\n    // Parse individual node in FBXTree.Objects.Texture\n    parseTexture(textureNode, images) {\n        const texture = this.loadTexture(textureNode, images);\n        texture.ID = textureNode.id;\n        texture.name = textureNode.attrName;\n        const wrapModeU = textureNode.WrapModeU;\n        const wrapModeV = textureNode.WrapModeV;\n        const valueU = wrapModeU !== undefined ? wrapModeU.value : 0;\n        const valueV = wrapModeV !== undefined ? wrapModeV.value : 0;\n        // http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a\n        // 0: repeat(default), 1: clamp\n        texture.wrapS = valueU === 0 ? (0, $ilwiq.RepeatWrapping) : (0, $ilwiq.ClampToEdgeWrapping);\n        texture.wrapT = valueV === 0 ? (0, $ilwiq.RepeatWrapping) : (0, $ilwiq.ClampToEdgeWrapping);\n        if (\"Scaling\" in textureNode) {\n            const values = textureNode.Scaling.value;\n            texture.repeat.x = values[0];\n            texture.repeat.y = values[1];\n        }\n        if (\"Translation\" in textureNode) {\n            const values = textureNode.Translation.value;\n            texture.offset.x = values[0];\n            texture.offset.y = values[1];\n        }\n        return texture;\n    }\n    // load a texture specified as a blob or data URI, or via an external URL using TextureLoader\n    loadTexture(textureNode, images) {\n        let fileName;\n        const currentPath = this.textureLoader.path;\n        const children = $04ef886a022e9ae8$var$connections.get(textureNode.id).children;\n        if (children !== undefined && children.length > 0 && images[children[0].ID] !== undefined) {\n            fileName = images[children[0].ID];\n            if (fileName.indexOf(\"blob:\") === 0 || fileName.indexOf(\"data:\") === 0) this.textureLoader.setPath(undefined);\n        }\n        let texture;\n        const extension = textureNode.FileName.slice(-3).toLowerCase();\n        if (extension === \"tga\") {\n            const loader = this.manager.getHandler(\".tga\");\n            if (loader === null) {\n                console.warn(\"FBXLoader: TGA loader not found, creating placeholder texture for\", textureNode.RelativeFilename);\n                texture = new (0, $ilwiq.Texture)();\n            } else {\n                loader.setPath(this.textureLoader.path);\n                texture = loader.load(fileName);\n            }\n        } else if (extension === \"psd\") {\n            console.warn(\"FBXLoader: PSD textures are not supported, creating placeholder texture for\", textureNode.RelativeFilename);\n            texture = new (0, $ilwiq.Texture)();\n        } else texture = this.textureLoader.load(fileName);\n        this.textureLoader.setPath(currentPath);\n        return texture;\n    }\n    // Parse nodes in FBXTree.Objects.Material\n    parseMaterials(textureMap) {\n        const materialMap = new Map();\n        if (\"Material\" in $04ef886a022e9ae8$var$fbxTree.Objects) {\n            const materialNodes = $04ef886a022e9ae8$var$fbxTree.Objects.Material;\n            for(const nodeID in materialNodes){\n                const material = this.parseMaterial(materialNodes[nodeID], textureMap);\n                if (material !== null) materialMap.set(parseInt(nodeID), material);\n            }\n        }\n        return materialMap;\n    }\n    // Parse single node in FBXTree.Objects.Material\n    // Materials are connected to texture maps in FBXTree.Objects.Textures\n    // FBX format currently only supports Lambert and Phong shading models\n    parseMaterial(materialNode, textureMap) {\n        const ID = materialNode.id;\n        const name = materialNode.attrName;\n        let type = materialNode.ShadingModel;\n        // Case where FBX wraps shading model in property object.\n        if (typeof type === \"object\") type = type.value;\n        // Ignore unused materials which don't have any connections.\n        if (!$04ef886a022e9ae8$var$connections.has(ID)) return null;\n        const parameters = this.parseParameters(materialNode, textureMap, ID);\n        let material;\n        switch(type.toLowerCase()){\n            case \"phong\":\n                material = new (0, $ilwiq.MeshPhongMaterial)();\n                break;\n            case \"lambert\":\n                material = new (0, $ilwiq.MeshLambertMaterial)();\n                break;\n            default:\n                console.warn('THREE.FBXLoader: unknown material type \"%s\". Defaulting to MeshPhongMaterial.', type);\n                material = new (0, $ilwiq.MeshPhongMaterial)();\n                break;\n        }\n        material.setValues(parameters);\n        material.name = name;\n        return material;\n    }\n    // Parse FBX material and return parameters suitable for a three.js material\n    // Also parse the texture map and return any textures associated with the material\n    parseParameters(materialNode, textureMap, ID) {\n        const parameters = {};\n        if (materialNode.BumpFactor) parameters.bumpScale = materialNode.BumpFactor.value;\n        if (materialNode.Diffuse) parameters.color = new (0, $ilwiq.Color)().fromArray(materialNode.Diffuse.value).convertSRGBToLinear();\n        else if (materialNode.DiffuseColor && (materialNode.DiffuseColor.type === \"Color\" || materialNode.DiffuseColor.type === \"ColorRGB\")) // The blender exporter exports diffuse here instead of in materialNode.Diffuse\n        parameters.color = new (0, $ilwiq.Color)().fromArray(materialNode.DiffuseColor.value).convertSRGBToLinear();\n        if (materialNode.DisplacementFactor) parameters.displacementScale = materialNode.DisplacementFactor.value;\n        if (materialNode.Emissive) parameters.emissive = new (0, $ilwiq.Color)().fromArray(materialNode.Emissive.value).convertSRGBToLinear();\n        else if (materialNode.EmissiveColor && (materialNode.EmissiveColor.type === \"Color\" || materialNode.EmissiveColor.type === \"ColorRGB\")) // The blender exporter exports emissive color here instead of in materialNode.Emissive\n        parameters.emissive = new (0, $ilwiq.Color)().fromArray(materialNode.EmissiveColor.value).convertSRGBToLinear();\n        if (materialNode.EmissiveFactor) parameters.emissiveIntensity = parseFloat(materialNode.EmissiveFactor.value);\n        if (materialNode.Opacity) parameters.opacity = parseFloat(materialNode.Opacity.value);\n        if (parameters.opacity < 1.0) parameters.transparent = true;\n        if (materialNode.ReflectionFactor) parameters.reflectivity = materialNode.ReflectionFactor.value;\n        if (materialNode.Shininess) parameters.shininess = materialNode.Shininess.value;\n        if (materialNode.Specular) parameters.specular = new (0, $ilwiq.Color)().fromArray(materialNode.Specular.value).convertSRGBToLinear();\n        else if (materialNode.SpecularColor && materialNode.SpecularColor.type === \"Color\") // The blender exporter exports specular color here instead of in materialNode.Specular\n        parameters.specular = new (0, $ilwiq.Color)().fromArray(materialNode.SpecularColor.value).convertSRGBToLinear();\n        const scope = this;\n        $04ef886a022e9ae8$var$connections.get(ID).children.forEach(function(child) {\n            const type = child.relationship;\n            switch(type){\n                case \"Bump\":\n                    parameters.bumpMap = scope.getTexture(textureMap, child.ID);\n                    break;\n                case \"Maya|TEX_ao_map\":\n                    parameters.aoMap = scope.getTexture(textureMap, child.ID);\n                    break;\n                case \"DiffuseColor\":\n                case \"Maya|TEX_color_map\":\n                    parameters.map = scope.getTexture(textureMap, child.ID);\n                    if (parameters.map !== undefined) parameters.map.encoding = (0, $ilwiq.sRGBEncoding);\n                    break;\n                case \"DisplacementColor\":\n                    parameters.displacementMap = scope.getTexture(textureMap, child.ID);\n                    break;\n                case \"EmissiveColor\":\n                    parameters.emissiveMap = scope.getTexture(textureMap, child.ID);\n                    if (parameters.emissiveMap !== undefined) parameters.emissiveMap.encoding = (0, $ilwiq.sRGBEncoding);\n                    break;\n                case \"NormalMap\":\n                case \"Maya|TEX_normal_map\":\n                    parameters.normalMap = scope.getTexture(textureMap, child.ID);\n                    break;\n                case \"ReflectionColor\":\n                    parameters.envMap = scope.getTexture(textureMap, child.ID);\n                    if (parameters.envMap !== undefined) {\n                        parameters.envMap.mapping = (0, $ilwiq.EquirectangularReflectionMapping);\n                        parameters.envMap.encoding = (0, $ilwiq.sRGBEncoding);\n                    }\n                    break;\n                case \"SpecularColor\":\n                    parameters.specularMap = scope.getTexture(textureMap, child.ID);\n                    if (parameters.specularMap !== undefined) parameters.specularMap.encoding = (0, $ilwiq.sRGBEncoding);\n                    break;\n                case \"TransparentColor\":\n                case \"TransparencyFactor\":\n                    parameters.alphaMap = scope.getTexture(textureMap, child.ID);\n                    parameters.transparent = true;\n                    break;\n                case \"AmbientColor\":\n                case \"ShininessExponent\":\n                case \"SpecularFactor\":\n                case \"VectorDisplacementColor\":\n                default:\n                    console.warn(\"THREE.FBXLoader: %s map is not supported in three.js, skipping texture.\", type);\n                    break;\n            }\n        });\n        return parameters;\n    }\n    // get a texture from the textureMap for use by a material.\n    getTexture(textureMap, id) {\n        // if the texture is a layered texture, just use the first layer and issue a warning\n        if (\"LayeredTexture\" in $04ef886a022e9ae8$var$fbxTree.Objects && id in $04ef886a022e9ae8$var$fbxTree.Objects.LayeredTexture) {\n            console.warn(\"THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.\");\n            id = $04ef886a022e9ae8$var$connections.get(id).children[0].ID;\n        }\n        return textureMap.get(id);\n    }\n    // Parse nodes in FBXTree.Objects.Deformer\n    // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here\n    // Generates map of Skeleton-like objects for use later when generating and binding skeletons.\n    parseDeformers() {\n        const skeletons = {};\n        const morphTargets = {};\n        if (\"Deformer\" in $04ef886a022e9ae8$var$fbxTree.Objects) {\n            const DeformerNodes = $04ef886a022e9ae8$var$fbxTree.Objects.Deformer;\n            for(const nodeID in DeformerNodes){\n                const deformerNode = DeformerNodes[nodeID];\n                const relationships = $04ef886a022e9ae8$var$connections.get(parseInt(nodeID));\n                if (deformerNode.attrType === \"Skin\") {\n                    const skeleton = this.parseSkeleton(relationships, DeformerNodes);\n                    skeleton.ID = nodeID;\n                    if (relationships.parents.length > 1) console.warn(\"THREE.FBXLoader: skeleton attached to more than one geometry is not supported.\");\n                    skeleton.geometryID = relationships.parents[0].ID;\n                    skeletons[nodeID] = skeleton;\n                } else if (deformerNode.attrType === \"BlendShape\") {\n                    const morphTarget = {\n                        id: nodeID\n                    };\n                    morphTarget.rawTargets = this.parseMorphTargets(relationships, DeformerNodes);\n                    morphTarget.id = nodeID;\n                    if (relationships.parents.length > 1) console.warn(\"THREE.FBXLoader: morph target attached to more than one geometry is not supported.\");\n                    morphTargets[nodeID] = morphTarget;\n                }\n            }\n        }\n        return {\n            skeletons: skeletons,\n            morphTargets: morphTargets\n        };\n    }\n    // Parse single nodes in FBXTree.Objects.Deformer\n    // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'\n    // Each skin node represents a skeleton and each cluster node represents a bone\n    parseSkeleton(relationships, deformerNodes) {\n        const rawBones = [];\n        relationships.children.forEach(function(child) {\n            const boneNode = deformerNodes[child.ID];\n            if (boneNode.attrType !== \"Cluster\") return;\n            const rawBone = {\n                ID: child.ID,\n                indices: [],\n                weights: [],\n                transformLink: new (0, $ilwiq.Matrix4)().fromArray(boneNode.TransformLink.a)\n            };\n            if (\"Indexes\" in boneNode) {\n                rawBone.indices = boneNode.Indexes.a;\n                rawBone.weights = boneNode.Weights.a;\n            }\n            rawBones.push(rawBone);\n        });\n        return {\n            rawBones: rawBones,\n            bones: []\n        };\n    }\n    // The top level morph deformer node has type \"BlendShape\" and sub nodes have type \"BlendShapeChannel\"\n    parseMorphTargets(relationships, deformerNodes) {\n        const rawMorphTargets = [];\n        for(let i = 0; i < relationships.children.length; i++){\n            const child = relationships.children[i];\n            const morphTargetNode = deformerNodes[child.ID];\n            const rawMorphTarget = {\n                name: morphTargetNode.attrName,\n                initialWeight: morphTargetNode.DeformPercent,\n                id: morphTargetNode.id,\n                fullWeights: morphTargetNode.FullWeights.a\n            };\n            if (morphTargetNode.attrType !== \"BlendShapeChannel\") return;\n            rawMorphTarget.geoID = $04ef886a022e9ae8$var$connections.get(parseInt(child.ID)).children.filter(function(child) {\n                return child.relationship === undefined;\n            })[0].ID;\n            rawMorphTargets.push(rawMorphTarget);\n        }\n        return rawMorphTargets;\n    }\n    // create the main Group() to be returned by the loader\n    parseScene(deformers, geometryMap, materialMap) {\n        $04ef886a022e9ae8$var$sceneGraph = new (0, $ilwiq.Group)();\n        const modelMap = this.parseModels(deformers.skeletons, geometryMap, materialMap);\n        const modelNodes = $04ef886a022e9ae8$var$fbxTree.Objects.Model;\n        const scope = this;\n        modelMap.forEach(function(model) {\n            const modelNode = modelNodes[model.ID];\n            scope.setLookAtProperties(model, modelNode);\n            const parentConnections = $04ef886a022e9ae8$var$connections.get(model.ID).parents;\n            parentConnections.forEach(function(connection) {\n                const parent = modelMap.get(connection.ID);\n                if (parent !== undefined) parent.add(model);\n            });\n            if (model.parent === null) $04ef886a022e9ae8$var$sceneGraph.add(model);\n        });\n        this.bindSkeleton(deformers.skeletons, geometryMap, modelMap);\n        this.createAmbientLight();\n        $04ef886a022e9ae8$var$sceneGraph.traverse(function(node) {\n            if (node.userData.transformData) {\n                if (node.parent) {\n                    node.userData.transformData.parentMatrix = node.parent.matrix;\n                    node.userData.transformData.parentMatrixWorld = node.parent.matrixWorld;\n                }\n                const transform = $04ef886a022e9ae8$var$generateTransform(node.userData.transformData);\n                node.applyMatrix4(transform);\n                node.updateWorldMatrix();\n            }\n        });\n        const animations = new $04ef886a022e9ae8$var$AnimationParser().parse();\n        // if all the models where already combined in a single group, just return that\n        if ($04ef886a022e9ae8$var$sceneGraph.children.length === 1 && $04ef886a022e9ae8$var$sceneGraph.children[0].isGroup) {\n            $04ef886a022e9ae8$var$sceneGraph.children[0].animations = animations;\n            $04ef886a022e9ae8$var$sceneGraph = $04ef886a022e9ae8$var$sceneGraph.children[0];\n        }\n        $04ef886a022e9ae8$var$sceneGraph.animations = animations;\n    }\n    // parse nodes in FBXTree.Objects.Model\n    parseModels(skeletons, geometryMap, materialMap) {\n        const modelMap = new Map();\n        const modelNodes = $04ef886a022e9ae8$var$fbxTree.Objects.Model;\n        for(const nodeID in modelNodes){\n            const id = parseInt(nodeID);\n            const node = modelNodes[nodeID];\n            const relationships = $04ef886a022e9ae8$var$connections.get(id);\n            let model = this.buildSkeleton(relationships, skeletons, id, node.attrName);\n            if (!model) {\n                switch(node.attrType){\n                    case \"Camera\":\n                        model = this.createCamera(relationships);\n                        break;\n                    case \"Light\":\n                        model = this.createLight(relationships);\n                        break;\n                    case \"Mesh\":\n                        model = this.createMesh(relationships, geometryMap, materialMap);\n                        break;\n                    case \"NurbsCurve\":\n                        model = this.createCurve(relationships, geometryMap);\n                        break;\n                    case \"LimbNode\":\n                    case \"Root\":\n                        model = new (0, $ilwiq.Bone)();\n                        break;\n                    case \"Null\":\n                    default:\n                        model = new (0, $ilwiq.Group)();\n                        break;\n                }\n                model.name = node.attrName ? (0, $ilwiq.PropertyBinding).sanitizeNodeName(node.attrName) : \"\";\n                model.ID = id;\n            }\n            this.getTransformData(model, node);\n            modelMap.set(id, model);\n        }\n        return modelMap;\n    }\n    buildSkeleton(relationships, skeletons, id, name) {\n        let bone = null;\n        relationships.parents.forEach(function(parent) {\n            for(const ID in skeletons){\n                const skeleton = skeletons[ID];\n                skeleton.rawBones.forEach(function(rawBone, i) {\n                    if (rawBone.ID === parent.ID) {\n                        const subBone = bone;\n                        bone = new (0, $ilwiq.Bone)();\n                        bone.matrixWorld.copy(rawBone.transformLink);\n                        // set name and id here - otherwise in cases where \"subBone\" is created it will not have a name / id\n                        bone.name = name ? (0, $ilwiq.PropertyBinding).sanitizeNodeName(name) : \"\";\n                        bone.ID = id;\n                        skeleton.bones[i] = bone;\n                        // In cases where a bone is shared between multiple meshes\n                        // duplicate the bone here and and it as a child of the first bone\n                        if (subBone !== null) bone.add(subBone);\n                    }\n                });\n            }\n        });\n        return bone;\n    }\n    // create a PerspectiveCamera or OrthographicCamera\n    createCamera(relationships) {\n        let model;\n        let cameraAttribute;\n        relationships.children.forEach(function(child) {\n            const attr = $04ef886a022e9ae8$var$fbxTree.Objects.NodeAttribute[child.ID];\n            if (attr !== undefined) cameraAttribute = attr;\n        });\n        if (cameraAttribute === undefined) model = new (0, $ilwiq.Object3D)();\n        else {\n            let type = 0;\n            if (cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1) type = 1;\n            let nearClippingPlane = 1;\n            if (cameraAttribute.NearPlane !== undefined) nearClippingPlane = cameraAttribute.NearPlane.value / 1000;\n            let farClippingPlane = 1000;\n            if (cameraAttribute.FarPlane !== undefined) farClippingPlane = cameraAttribute.FarPlane.value / 1000;\n            let width = window.innerWidth;\n            let height = window.innerHeight;\n            if (cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined) {\n                width = cameraAttribute.AspectWidth.value;\n                height = cameraAttribute.AspectHeight.value;\n            }\n            const aspect = width / height;\n            let fov = 45;\n            if (cameraAttribute.FieldOfView !== undefined) fov = cameraAttribute.FieldOfView.value;\n            const focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;\n            switch(type){\n                case 0:\n                    model = new (0, $ilwiq.PerspectiveCamera)(fov, aspect, nearClippingPlane, farClippingPlane);\n                    if (focalLength !== null) model.setFocalLength(focalLength);\n                    break;\n                case 1:\n                    model = new (0, $ilwiq.OrthographicCamera)(-width / 2, width / 2, height / 2, -height / 2, nearClippingPlane, farClippingPlane);\n                    break;\n                default:\n                    console.warn(\"THREE.FBXLoader: Unknown camera type \" + type + \".\");\n                    model = new (0, $ilwiq.Object3D)();\n                    break;\n            }\n        }\n        return model;\n    }\n    // Create a DirectionalLight, PointLight or SpotLight\n    createLight(relationships) {\n        let model;\n        let lightAttribute;\n        relationships.children.forEach(function(child) {\n            const attr = $04ef886a022e9ae8$var$fbxTree.Objects.NodeAttribute[child.ID];\n            if (attr !== undefined) lightAttribute = attr;\n        });\n        if (lightAttribute === undefined) model = new (0, $ilwiq.Object3D)();\n        else {\n            let type;\n            // LightType can be undefined for Point lights\n            if (lightAttribute.LightType === undefined) type = 0;\n            else type = lightAttribute.LightType.value;\n            let color = 0xffffff;\n            if (lightAttribute.Color !== undefined) color = new (0, $ilwiq.Color)().fromArray(lightAttribute.Color.value).convertSRGBToLinear();\n            let intensity = lightAttribute.Intensity === undefined ? 1 : lightAttribute.Intensity.value / 100;\n            // light disabled\n            if (lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0) intensity = 0;\n            let distance = 0;\n            if (lightAttribute.FarAttenuationEnd !== undefined) {\n                if (lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0) distance = 0;\n                else distance = lightAttribute.FarAttenuationEnd.value;\n            }\n            // TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?\n            const decay = 1;\n            switch(type){\n                case 0:\n                    model = new (0, $ilwiq.PointLight)(color, intensity, distance, decay);\n                    break;\n                case 1:\n                    model = new (0, $ilwiq.DirectionalLight)(color, intensity);\n                    break;\n                case 2:\n                    let angle = Math.PI / 3;\n                    if (lightAttribute.InnerAngle !== undefined) angle = (0, $ilwiq.MathUtils).degToRad(lightAttribute.InnerAngle.value);\n                    let penumbra = 0;\n                    if (lightAttribute.OuterAngle !== undefined) {\n                        // TODO: this is not correct - FBX calculates outer and inner angle in degrees\n                        // with OuterAngle > InnerAngle && OuterAngle <= Math.PI\n                        // while three.js uses a penumbra between (0, 1) to attenuate the inner angle\n                        penumbra = (0, $ilwiq.MathUtils).degToRad(lightAttribute.OuterAngle.value);\n                        penumbra = Math.max(penumbra, 1);\n                    }\n                    model = new (0, $ilwiq.SpotLight)(color, intensity, distance, angle, penumbra, decay);\n                    break;\n                default:\n                    console.warn(\"THREE.FBXLoader: Unknown light type \" + lightAttribute.LightType.value + \", defaulting to a PointLight.\");\n                    model = new (0, $ilwiq.PointLight)(color, intensity);\n                    break;\n            }\n            if (lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1) model.castShadow = true;\n        }\n        return model;\n    }\n    createMesh(relationships, geometryMap, materialMap) {\n        let model;\n        let geometry = null;\n        let material = null;\n        const materials = [];\n        // get geometry and materials(s) from connections\n        relationships.children.forEach(function(child) {\n            if (geometryMap.has(child.ID)) geometry = geometryMap.get(child.ID);\n            if (materialMap.has(child.ID)) materials.push(materialMap.get(child.ID));\n        });\n        if (materials.length > 1) material = materials;\n        else if (materials.length > 0) material = materials[0];\n        else {\n            material = new (0, $ilwiq.MeshPhongMaterial)({\n                color: 0xcccccc\n            });\n            materials.push(material);\n        }\n        if (\"color\" in geometry.attributes) materials.forEach(function(material) {\n            material.vertexColors = true;\n        });\n        if (geometry.FBX_Deformer) {\n            model = new (0, $ilwiq.SkinnedMesh)(geometry, material);\n            model.normalizeSkinWeights();\n        } else model = new (0, $ilwiq.Mesh)(geometry, material);\n        return model;\n    }\n    createCurve(relationships, geometryMap) {\n        const geometry = relationships.children.reduce(function(geo, child) {\n            if (geometryMap.has(child.ID)) geo = geometryMap.get(child.ID);\n            return geo;\n        }, null);\n        // FBX does not list materials for Nurbs lines, so we'll just put our own in here.\n        const material = new (0, $ilwiq.LineBasicMaterial)({\n            color: 0x3300ff,\n            linewidth: 1\n        });\n        return new (0, $ilwiq.Line)(geometry, material);\n    }\n    // parse the model node for transform data\n    getTransformData(model, modelNode) {\n        const transformData = {};\n        if (\"InheritType\" in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value);\n        if (\"RotationOrder\" in modelNode) transformData.eulerOrder = $04ef886a022e9ae8$var$getEulerOrder(modelNode.RotationOrder.value);\n        else transformData.eulerOrder = \"ZYX\";\n        if (\"Lcl_Translation\" in modelNode) transformData.translation = modelNode.Lcl_Translation.value;\n        if (\"PreRotation\" in modelNode) transformData.preRotation = modelNode.PreRotation.value;\n        if (\"Lcl_Rotation\" in modelNode) transformData.rotation = modelNode.Lcl_Rotation.value;\n        if (\"PostRotation\" in modelNode) transformData.postRotation = modelNode.PostRotation.value;\n        if (\"Lcl_Scaling\" in modelNode) transformData.scale = modelNode.Lcl_Scaling.value;\n        if (\"ScalingOffset\" in modelNode) transformData.scalingOffset = modelNode.ScalingOffset.value;\n        if (\"ScalingPivot\" in modelNode) transformData.scalingPivot = modelNode.ScalingPivot.value;\n        if (\"RotationOffset\" in modelNode) transformData.rotationOffset = modelNode.RotationOffset.value;\n        if (\"RotationPivot\" in modelNode) transformData.rotationPivot = modelNode.RotationPivot.value;\n        model.userData.transformData = transformData;\n    }\n    setLookAtProperties(model, modelNode) {\n        if (\"LookAtProperty\" in modelNode) {\n            const children = $04ef886a022e9ae8$var$connections.get(model.ID).children;\n            children.forEach(function(child) {\n                if (child.relationship === \"LookAtProperty\") {\n                    const lookAtTarget = $04ef886a022e9ae8$var$fbxTree.Objects.Model[child.ID];\n                    if (\"Lcl_Translation\" in lookAtTarget) {\n                        const pos = lookAtTarget.Lcl_Translation.value;\n                        // DirectionalLight, SpotLight\n                        if (model.target !== undefined) {\n                            model.target.position.fromArray(pos);\n                            $04ef886a022e9ae8$var$sceneGraph.add(model.target);\n                        } else model.lookAt(new (0, $ilwiq.Vector3)().fromArray(pos));\n                    }\n                }\n            });\n        }\n    }\n    bindSkeleton(skeletons, geometryMap, modelMap) {\n        const bindMatrices = this.parsePoseNodes();\n        for(const ID in skeletons){\n            const skeleton = skeletons[ID];\n            const parents = $04ef886a022e9ae8$var$connections.get(parseInt(skeleton.ID)).parents;\n            parents.forEach(function(parent) {\n                if (geometryMap.has(parent.ID)) {\n                    const geoID = parent.ID;\n                    const geoRelationships = $04ef886a022e9ae8$var$connections.get(geoID);\n                    geoRelationships.parents.forEach(function(geoConnParent) {\n                        if (modelMap.has(geoConnParent.ID)) {\n                            const model = modelMap.get(geoConnParent.ID);\n                            model.bind(new (0, $ilwiq.Skeleton)(skeleton.bones), bindMatrices[geoConnParent.ID]);\n                        }\n                    });\n                }\n            });\n        }\n    }\n    parsePoseNodes() {\n        const bindMatrices = {};\n        if (\"Pose\" in $04ef886a022e9ae8$var$fbxTree.Objects) {\n            const BindPoseNode = $04ef886a022e9ae8$var$fbxTree.Objects.Pose;\n            for(const nodeID in BindPoseNode)if (BindPoseNode[nodeID].attrType === \"BindPose\" && BindPoseNode[nodeID].NbPoseNodes > 0) {\n                const poseNodes = BindPoseNode[nodeID].PoseNode;\n                if (Array.isArray(poseNodes)) poseNodes.forEach(function(poseNode) {\n                    bindMatrices[poseNode.Node] = new (0, $ilwiq.Matrix4)().fromArray(poseNode.Matrix.a);\n                });\n                else bindMatrices[poseNodes.Node] = new (0, $ilwiq.Matrix4)().fromArray(poseNodes.Matrix.a);\n            }\n        }\n        return bindMatrices;\n    }\n    // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light\n    createAmbientLight() {\n        if (\"GlobalSettings\" in $04ef886a022e9ae8$var$fbxTree && \"AmbientColor\" in $04ef886a022e9ae8$var$fbxTree.GlobalSettings) {\n            const ambientColor = $04ef886a022e9ae8$var$fbxTree.GlobalSettings.AmbientColor.value;\n            const r = ambientColor[0];\n            const g = ambientColor[1];\n            const b = ambientColor[2];\n            if (r !== 0 || g !== 0 || b !== 0) {\n                const color = new (0, $ilwiq.Color)(r, g, b).convertSRGBToLinear();\n                $04ef886a022e9ae8$var$sceneGraph.add(new (0, $ilwiq.AmbientLight)(color, 1));\n            }\n        }\n    }\n}\n// parse Geometry data from FBXTree and return map of BufferGeometries\nclass $04ef886a022e9ae8$var$GeometryParser {\n    constructor(){\n        this.negativeMaterialIndices = false;\n    }\n    // Parse nodes in FBXTree.Objects.Geometry\n    parse(deformers) {\n        const geometryMap = new Map();\n        if (\"Geometry\" in $04ef886a022e9ae8$var$fbxTree.Objects) {\n            const geoNodes = $04ef886a022e9ae8$var$fbxTree.Objects.Geometry;\n            for(const nodeID in geoNodes){\n                const relationships = $04ef886a022e9ae8$var$connections.get(parseInt(nodeID));\n                const geo = this.parseGeometry(relationships, geoNodes[nodeID], deformers);\n                geometryMap.set(parseInt(nodeID), geo);\n            }\n        }\n        // report warnings\n        if (this.negativeMaterialIndices === true) console.warn(\"THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected.\");\n        return geometryMap;\n    }\n    // Parse single node in FBXTree.Objects.Geometry\n    parseGeometry(relationships, geoNode, deformers) {\n        switch(geoNode.attrType){\n            case \"Mesh\":\n                return this.parseMeshGeometry(relationships, geoNode, deformers);\n            case \"NurbsCurve\":\n                return this.parseNurbsGeometry(geoNode);\n        }\n    }\n    // Parse single node mesh geometry in FBXTree.Objects.Geometry\n    parseMeshGeometry(relationships, geoNode, deformers) {\n        const skeletons = deformers.skeletons;\n        const morphTargets = [];\n        const modelNodes = relationships.parents.map(function(parent) {\n            return $04ef886a022e9ae8$var$fbxTree.Objects.Model[parent.ID];\n        });\n        // don't create geometry if it is not associated with any models\n        if (modelNodes.length === 0) return;\n        const skeleton = relationships.children.reduce(function(skeleton, child) {\n            if (skeletons[child.ID] !== undefined) skeleton = skeletons[child.ID];\n            return skeleton;\n        }, null);\n        relationships.children.forEach(function(child) {\n            if (deformers.morphTargets[child.ID] !== undefined) morphTargets.push(deformers.morphTargets[child.ID]);\n        });\n        // Assume one model and get the preRotation from that\n        // if there is more than one model associated with the geometry this may cause problems\n        const modelNode = modelNodes[0];\n        const transformData = {};\n        if (\"RotationOrder\" in modelNode) transformData.eulerOrder = $04ef886a022e9ae8$var$getEulerOrder(modelNode.RotationOrder.value);\n        if (\"InheritType\" in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value);\n        if (\"GeometricTranslation\" in modelNode) transformData.translation = modelNode.GeometricTranslation.value;\n        if (\"GeometricRotation\" in modelNode) transformData.rotation = modelNode.GeometricRotation.value;\n        if (\"GeometricScaling\" in modelNode) transformData.scale = modelNode.GeometricScaling.value;\n        const transform = $04ef886a022e9ae8$var$generateTransform(transformData);\n        return this.genGeometry(geoNode, skeleton, morphTargets, transform);\n    }\n    // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry\n    genGeometry(geoNode, skeleton, morphTargets, preTransform) {\n        const geo = new (0, $ilwiq.BufferGeometry)();\n        if (geoNode.attrName) geo.name = geoNode.attrName;\n        const geoInfo = this.parseGeoNode(geoNode, skeleton);\n        const buffers = this.genBuffers(geoInfo);\n        const positionAttribute = new (0, $ilwiq.Float32BufferAttribute)(buffers.vertex, 3);\n        positionAttribute.applyMatrix4(preTransform);\n        geo.setAttribute(\"position\", positionAttribute);\n        if (buffers.colors.length > 0) geo.setAttribute(\"color\", new (0, $ilwiq.Float32BufferAttribute)(buffers.colors, 3));\n        if (skeleton) {\n            geo.setAttribute(\"skinIndex\", new (0, $ilwiq.Uint16BufferAttribute)(buffers.weightsIndices, 4));\n            geo.setAttribute(\"skinWeight\", new (0, $ilwiq.Float32BufferAttribute)(buffers.vertexWeights, 4));\n            // used later to bind the skeleton to the model\n            geo.FBX_Deformer = skeleton;\n        }\n        if (buffers.normal.length > 0) {\n            const normalMatrix = new (0, $ilwiq.Matrix3)().getNormalMatrix(preTransform);\n            const normalAttribute = new (0, $ilwiq.Float32BufferAttribute)(buffers.normal, 3);\n            normalAttribute.applyNormalMatrix(normalMatrix);\n            geo.setAttribute(\"normal\", normalAttribute);\n        }\n        buffers.uvs.forEach(function(uvBuffer, i) {\n            // subsequent uv buffers are called 'uv1', 'uv2', ...\n            let name = \"uv\" + (i + 1).toString();\n            // the first uv buffer is just called 'uv'\n            if (i === 0) name = \"uv\";\n            geo.setAttribute(name, new (0, $ilwiq.Float32BufferAttribute)(buffers.uvs[i], 2));\n        });\n        if (geoInfo.material && geoInfo.material.mappingType !== \"AllSame\") {\n            // Convert the material indices of each vertex into rendering groups on the geometry.\n            let prevMaterialIndex = buffers.materialIndex[0];\n            let startIndex = 0;\n            buffers.materialIndex.forEach(function(currentIndex, i) {\n                if (currentIndex !== prevMaterialIndex) {\n                    geo.addGroup(startIndex, i - startIndex, prevMaterialIndex);\n                    prevMaterialIndex = currentIndex;\n                    startIndex = i;\n                }\n            });\n            // the loop above doesn't add the last group, do that here.\n            if (geo.groups.length > 0) {\n                const lastGroup = geo.groups[geo.groups.length - 1];\n                const lastIndex = lastGroup.start + lastGroup.count;\n                if (lastIndex !== buffers.materialIndex.length) geo.addGroup(lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex);\n            }\n            // case where there are multiple materials but the whole geometry is only\n            // using one of them\n            if (geo.groups.length === 0) geo.addGroup(0, buffers.materialIndex.length, buffers.materialIndex[0]);\n        }\n        this.addMorphTargets(geo, geoNode, morphTargets, preTransform);\n        return geo;\n    }\n    parseGeoNode(geoNode, skeleton) {\n        const geoInfo = {};\n        geoInfo.vertexPositions = geoNode.Vertices !== undefined ? geoNode.Vertices.a : [];\n        geoInfo.vertexIndices = geoNode.PolygonVertexIndex !== undefined ? geoNode.PolygonVertexIndex.a : [];\n        if (geoNode.LayerElementColor) geoInfo.color = this.parseVertexColors(geoNode.LayerElementColor[0]);\n        if (geoNode.LayerElementMaterial) geoInfo.material = this.parseMaterialIndices(geoNode.LayerElementMaterial[0]);\n        if (geoNode.LayerElementNormal) geoInfo.normal = this.parseNormals(geoNode.LayerElementNormal[0]);\n        if (geoNode.LayerElementUV) {\n            geoInfo.uv = [];\n            let i = 0;\n            while(geoNode.LayerElementUV[i]){\n                if (geoNode.LayerElementUV[i].UV) geoInfo.uv.push(this.parseUVs(geoNode.LayerElementUV[i]));\n                i++;\n            }\n        }\n        geoInfo.weightTable = {};\n        if (skeleton !== null) {\n            geoInfo.skeleton = skeleton;\n            skeleton.rawBones.forEach(function(rawBone, i) {\n                // loop over the bone's vertex indices and weights\n                rawBone.indices.forEach(function(index, j) {\n                    if (geoInfo.weightTable[index] === undefined) geoInfo.weightTable[index] = [];\n                    geoInfo.weightTable[index].push({\n                        id: i,\n                        weight: rawBone.weights[j]\n                    });\n                });\n            });\n        }\n        return geoInfo;\n    }\n    genBuffers(geoInfo) {\n        const buffers = {\n            vertex: [],\n            normal: [],\n            colors: [],\n            uvs: [],\n            materialIndex: [],\n            vertexWeights: [],\n            weightsIndices: []\n        };\n        let polygonIndex = 0;\n        let faceLength = 0;\n        let displayedWeightsWarning = false;\n        // these will hold data for a single face\n        let facePositionIndexes = [];\n        let faceNormals = [];\n        let faceColors = [];\n        let faceUVs = [];\n        let faceWeights = [];\n        let faceWeightIndices = [];\n        const scope = this;\n        geoInfo.vertexIndices.forEach(function(vertexIndex, polygonVertexIndex) {\n            let materialIndex;\n            let endOfFace = false;\n            // Face index and vertex index arrays are combined in a single array\n            // A cube with quad faces looks like this:\n            // PolygonVertexIndex: *24 {\n            //  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5\n            //  }\n            // Negative numbers mark the end of a face - first face here is 0, 1, 3, -3\n            // to find index of last vertex bit shift the index: ^ - 1\n            if (vertexIndex < 0) {\n                vertexIndex = vertexIndex ^ -1; // equivalent to ( x * -1 ) - 1\n                endOfFace = true;\n            }\n            let weightIndices = [];\n            let weights = [];\n            facePositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2);\n            if (geoInfo.color) {\n                const data = $04ef886a022e9ae8$var$getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color);\n                faceColors.push(data[0], data[1], data[2]);\n            }\n            if (geoInfo.skeleton) {\n                if (geoInfo.weightTable[vertexIndex] !== undefined) geoInfo.weightTable[vertexIndex].forEach(function(wt) {\n                    weights.push(wt.weight);\n                    weightIndices.push(wt.id);\n                });\n                if (weights.length > 4) {\n                    if (!displayedWeightsWarning) {\n                        console.warn(\"THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.\");\n                        displayedWeightsWarning = true;\n                    }\n                    const wIndex = [\n                        0,\n                        0,\n                        0,\n                        0\n                    ];\n                    const Weight = [\n                        0,\n                        0,\n                        0,\n                        0\n                    ];\n                    weights.forEach(function(weight, weightIndex) {\n                        let currentWeight = weight;\n                        let currentIndex = weightIndices[weightIndex];\n                        Weight.forEach(function(comparedWeight, comparedWeightIndex, comparedWeightArray) {\n                            if (currentWeight > comparedWeight) {\n                                comparedWeightArray[comparedWeightIndex] = currentWeight;\n                                currentWeight = comparedWeight;\n                                const tmp = wIndex[comparedWeightIndex];\n                                wIndex[comparedWeightIndex] = currentIndex;\n                                currentIndex = tmp;\n                            }\n                        });\n                    });\n                    weightIndices = wIndex;\n                    weights = Weight;\n                }\n                // if the weight array is shorter than 4 pad with 0s\n                while(weights.length < 4){\n                    weights.push(0);\n                    weightIndices.push(0);\n                }\n                for(let i = 0; i < 4; ++i){\n                    faceWeights.push(weights[i]);\n                    faceWeightIndices.push(weightIndices[i]);\n                }\n            }\n            if (geoInfo.normal) {\n                const data = $04ef886a022e9ae8$var$getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal);\n                faceNormals.push(data[0], data[1], data[2]);\n            }\n            if (geoInfo.material && geoInfo.material.mappingType !== \"AllSame\") {\n                materialIndex = $04ef886a022e9ae8$var$getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material)[0];\n                if (materialIndex < 0) {\n                    scope.negativeMaterialIndices = true;\n                    materialIndex = 0; // fallback\n                }\n            }\n            if (geoInfo.uv) geoInfo.uv.forEach(function(uv, i) {\n                const data = $04ef886a022e9ae8$var$getData(polygonVertexIndex, polygonIndex, vertexIndex, uv);\n                if (faceUVs[i] === undefined) faceUVs[i] = [];\n                faceUVs[i].push(data[0]);\n                faceUVs[i].push(data[1]);\n            });\n            faceLength++;\n            if (endOfFace) {\n                if (faceLength > 4) console.warn(\"THREE.FBXLoader: Polygons with more than four sides are not supported. Make sure to triangulate the geometry during export.\");\n                scope.genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength);\n                polygonIndex++;\n                faceLength = 0;\n                // reset arrays for the next face\n                facePositionIndexes = [];\n                faceNormals = [];\n                faceColors = [];\n                faceUVs = [];\n                faceWeights = [];\n                faceWeightIndices = [];\n            }\n        });\n        return buffers;\n    }\n    // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris\n    genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength) {\n        for(let i = 2; i < faceLength; i++){\n            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[0]]);\n            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[1]]);\n            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[2]]);\n            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3]]);\n            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 1]]);\n            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 2]]);\n            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3]]);\n            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 1]]);\n            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 2]]);\n            if (geoInfo.skeleton) {\n                buffers.vertexWeights.push(faceWeights[0]);\n                buffers.vertexWeights.push(faceWeights[1]);\n                buffers.vertexWeights.push(faceWeights[2]);\n                buffers.vertexWeights.push(faceWeights[3]);\n                buffers.vertexWeights.push(faceWeights[(i - 1) * 4]);\n                buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 1]);\n                buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 2]);\n                buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 3]);\n                buffers.vertexWeights.push(faceWeights[i * 4]);\n                buffers.vertexWeights.push(faceWeights[i * 4 + 1]);\n                buffers.vertexWeights.push(faceWeights[i * 4 + 2]);\n                buffers.vertexWeights.push(faceWeights[i * 4 + 3]);\n                buffers.weightsIndices.push(faceWeightIndices[0]);\n                buffers.weightsIndices.push(faceWeightIndices[1]);\n                buffers.weightsIndices.push(faceWeightIndices[2]);\n                buffers.weightsIndices.push(faceWeightIndices[3]);\n                buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4]);\n                buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 1]);\n                buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 2]);\n                buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 3]);\n                buffers.weightsIndices.push(faceWeightIndices[i * 4]);\n                buffers.weightsIndices.push(faceWeightIndices[i * 4 + 1]);\n                buffers.weightsIndices.push(faceWeightIndices[i * 4 + 2]);\n                buffers.weightsIndices.push(faceWeightIndices[i * 4 + 3]);\n            }\n            if (geoInfo.color) {\n                buffers.colors.push(faceColors[0]);\n                buffers.colors.push(faceColors[1]);\n                buffers.colors.push(faceColors[2]);\n                buffers.colors.push(faceColors[(i - 1) * 3]);\n                buffers.colors.push(faceColors[(i - 1) * 3 + 1]);\n                buffers.colors.push(faceColors[(i - 1) * 3 + 2]);\n                buffers.colors.push(faceColors[i * 3]);\n                buffers.colors.push(faceColors[i * 3 + 1]);\n                buffers.colors.push(faceColors[i * 3 + 2]);\n            }\n            if (geoInfo.material && geoInfo.material.mappingType !== \"AllSame\") {\n                buffers.materialIndex.push(materialIndex);\n                buffers.materialIndex.push(materialIndex);\n                buffers.materialIndex.push(materialIndex);\n            }\n            if (geoInfo.normal) {\n                buffers.normal.push(faceNormals[0]);\n                buffers.normal.push(faceNormals[1]);\n                buffers.normal.push(faceNormals[2]);\n                buffers.normal.push(faceNormals[(i - 1) * 3]);\n                buffers.normal.push(faceNormals[(i - 1) * 3 + 1]);\n                buffers.normal.push(faceNormals[(i - 1) * 3 + 2]);\n                buffers.normal.push(faceNormals[i * 3]);\n                buffers.normal.push(faceNormals[i * 3 + 1]);\n                buffers.normal.push(faceNormals[i * 3 + 2]);\n            }\n            if (geoInfo.uv) geoInfo.uv.forEach(function(uv, j) {\n                if (buffers.uvs[j] === undefined) buffers.uvs[j] = [];\n                buffers.uvs[j].push(faceUVs[j][0]);\n                buffers.uvs[j].push(faceUVs[j][1]);\n                buffers.uvs[j].push(faceUVs[j][(i - 1) * 2]);\n                buffers.uvs[j].push(faceUVs[j][(i - 1) * 2 + 1]);\n                buffers.uvs[j].push(faceUVs[j][i * 2]);\n                buffers.uvs[j].push(faceUVs[j][i * 2 + 1]);\n            });\n        }\n    }\n    addMorphTargets(parentGeo, parentGeoNode, morphTargets, preTransform) {\n        if (morphTargets.length === 0) return;\n        parentGeo.morphTargetsRelative = true;\n        parentGeo.morphAttributes.position = [];\n        // parentGeo.morphAttributes.normal = []; // not implemented\n        const scope = this;\n        morphTargets.forEach(function(morphTarget) {\n            morphTarget.rawTargets.forEach(function(rawTarget) {\n                const morphGeoNode = $04ef886a022e9ae8$var$fbxTree.Objects.Geometry[rawTarget.geoID];\n                if (morphGeoNode !== undefined) scope.genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name);\n            });\n        });\n    }\n    // a morph geometry node is similar to a standard  node, and the node is also contained\n    // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal\n    // and a special attribute Index defining which vertices of the original geometry are affected\n    // Normal and position attributes only have data for the vertices that are affected by the morph\n    genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, name) {\n        const vertexIndices = parentGeoNode.PolygonVertexIndex !== undefined ? parentGeoNode.PolygonVertexIndex.a : [];\n        const morphPositionsSparse = morphGeoNode.Vertices !== undefined ? morphGeoNode.Vertices.a : [];\n        const indices = morphGeoNode.Indexes !== undefined ? morphGeoNode.Indexes.a : [];\n        const length = parentGeo.attributes.position.count * 3;\n        const morphPositions = new Float32Array(length);\n        for(let i = 0; i < indices.length; i++){\n            const morphIndex = indices[i] * 3;\n            morphPositions[morphIndex] = morphPositionsSparse[i * 3];\n            morphPositions[morphIndex + 1] = morphPositionsSparse[i * 3 + 1];\n            morphPositions[morphIndex + 2] = morphPositionsSparse[i * 3 + 2];\n        }\n        // TODO: add morph normal support\n        const morphGeoInfo = {\n            vertexIndices: vertexIndices,\n            vertexPositions: morphPositions\n        };\n        const morphBuffers = this.genBuffers(morphGeoInfo);\n        const positionAttribute = new (0, $ilwiq.Float32BufferAttribute)(morphBuffers.vertex, 3);\n        positionAttribute.name = name || morphGeoNode.attrName;\n        positionAttribute.applyMatrix4(preTransform);\n        parentGeo.morphAttributes.position.push(positionAttribute);\n    }\n    // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists\n    parseNormals(NormalNode) {\n        const mappingType = NormalNode.MappingInformationType;\n        const referenceType = NormalNode.ReferenceInformationType;\n        const buffer = NormalNode.Normals.a;\n        let indexBuffer = [];\n        if (referenceType === \"IndexToDirect\") {\n            if (\"NormalIndex\" in NormalNode) indexBuffer = NormalNode.NormalIndex.a;\n            else if (\"NormalsIndex\" in NormalNode) indexBuffer = NormalNode.NormalsIndex.a;\n        }\n        return {\n            dataSize: 3,\n            buffer: buffer,\n            indices: indexBuffer,\n            mappingType: mappingType,\n            referenceType: referenceType\n        };\n    }\n    // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists\n    parseUVs(UVNode) {\n        const mappingType = UVNode.MappingInformationType;\n        const referenceType = UVNode.ReferenceInformationType;\n        const buffer = UVNode.UV.a;\n        let indexBuffer = [];\n        if (referenceType === \"IndexToDirect\") indexBuffer = UVNode.UVIndex.a;\n        return {\n            dataSize: 2,\n            buffer: buffer,\n            indices: indexBuffer,\n            mappingType: mappingType,\n            referenceType: referenceType\n        };\n    }\n    // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists\n    parseVertexColors(ColorNode) {\n        const mappingType = ColorNode.MappingInformationType;\n        const referenceType = ColorNode.ReferenceInformationType;\n        const buffer = ColorNode.Colors.a;\n        let indexBuffer = [];\n        if (referenceType === \"IndexToDirect\") indexBuffer = ColorNode.ColorIndex.a;\n        for(let i = 0, c = new (0, $ilwiq.Color)(); i < buffer.length; i += 4)c.fromArray(buffer, i).convertSRGBToLinear().toArray(buffer, i);\n        return {\n            dataSize: 4,\n            buffer: buffer,\n            indices: indexBuffer,\n            mappingType: mappingType,\n            referenceType: referenceType\n        };\n    }\n    // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists\n    parseMaterialIndices(MaterialNode) {\n        const mappingType = MaterialNode.MappingInformationType;\n        const referenceType = MaterialNode.ReferenceInformationType;\n        if (mappingType === \"NoMappingInformation\") return {\n            dataSize: 1,\n            buffer: [\n                0\n            ],\n            indices: [\n                0\n            ],\n            mappingType: \"AllSame\",\n            referenceType: referenceType\n        };\n        const materialIndexBuffer = MaterialNode.Materials.a;\n        // Since materials are stored as indices, there's a bit of a mismatch between FBX and what\n        // we expect.So we create an intermediate buffer that points to the index in the buffer,\n        // for conforming with the other functions we've written for other data.\n        const materialIndices = [];\n        for(let i = 0; i < materialIndexBuffer.length; ++i)materialIndices.push(i);\n        return {\n            dataSize: 1,\n            buffer: materialIndexBuffer,\n            indices: materialIndices,\n            mappingType: mappingType,\n            referenceType: referenceType\n        };\n    }\n    // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry\n    parseNurbsGeometry(geoNode) {\n        const order = parseInt(geoNode.Order);\n        if (isNaN(order)) {\n            console.error(\"THREE.FBXLoader: Invalid Order %s given for geometry ID: %s\", geoNode.Order, geoNode.id);\n            return new (0, $ilwiq.BufferGeometry)();\n        }\n        const degree = order - 1;\n        const knots = geoNode.KnotVector.a;\n        const controlPoints = [];\n        const pointsValues = geoNode.Points.a;\n        for(let i = 0, l = pointsValues.length; i < l; i += 4)controlPoints.push(new (0, $ilwiq.Vector4)().fromArray(pointsValues, i));\n        let startKnot, endKnot;\n        if (geoNode.Form === \"Closed\") controlPoints.push(controlPoints[0]);\n        else if (geoNode.Form === \"Periodic\") {\n            startKnot = degree;\n            endKnot = knots.length - 1 - startKnot;\n            for(let i = 0; i < degree; ++i)controlPoints.push(controlPoints[i]);\n        }\n        const curve = new (0, $cLt9Z.NURBSCurve)(degree, knots, controlPoints, startKnot, endKnot);\n        const points = curve.getPoints(controlPoints.length * 12);\n        return new (0, $ilwiq.BufferGeometry)().setFromPoints(points);\n    }\n}\n// parse animation data from FBXTree\nclass $04ef886a022e9ae8$var$AnimationParser {\n    // take raw animation clips and turn them into three.js animation clips\n    parse() {\n        const animationClips = [];\n        const rawClips = this.parseClips();\n        if (rawClips !== undefined) for(const key in rawClips){\n            const rawClip = rawClips[key];\n            const clip = this.addClip(rawClip);\n            animationClips.push(clip);\n        }\n        return animationClips;\n    }\n    parseClips() {\n        // since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,\n        // if this is undefined we can safely assume there are no animations\n        if ($04ef886a022e9ae8$var$fbxTree.Objects.AnimationCurve === undefined) return undefined;\n        const curveNodesMap = this.parseAnimationCurveNodes();\n        this.parseAnimationCurves(curveNodesMap);\n        const layersMap = this.parseAnimationLayers(curveNodesMap);\n        const rawClips = this.parseAnimStacks(layersMap);\n        return rawClips;\n    }\n    // parse nodes in FBXTree.Objects.AnimationCurveNode\n    // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )\n    // and is referenced by an AnimationLayer\n    parseAnimationCurveNodes() {\n        const rawCurveNodes = $04ef886a022e9ae8$var$fbxTree.Objects.AnimationCurveNode;\n        const curveNodesMap = new Map();\n        for(const nodeID in rawCurveNodes){\n            const rawCurveNode = rawCurveNodes[nodeID];\n            if (rawCurveNode.attrName.match(/S|R|T|DeformPercent/) !== null) {\n                const curveNode = {\n                    id: rawCurveNode.id,\n                    attr: rawCurveNode.attrName,\n                    curves: {}\n                };\n                curveNodesMap.set(curveNode.id, curveNode);\n            }\n        }\n        return curveNodesMap;\n    }\n    // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to\n    // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated\n    // axis ( e.g. times and values of x rotation)\n    parseAnimationCurves(curveNodesMap) {\n        const rawCurves = $04ef886a022e9ae8$var$fbxTree.Objects.AnimationCurve;\n        // TODO: Many values are identical up to roundoff error, but won't be optimised\n        // e.g. position times: [0, 0.4, 0. 8]\n        // position values: [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.235384487103147e-7, 93.67520904541016, -0.9982695579528809]\n        // clearly, this should be optimised to\n        // times: [0], positions [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809]\n        // this shows up in nearly every FBX file, and generally time array is length > 100\n        for(const nodeID in rawCurves){\n            const animationCurve = {\n                id: rawCurves[nodeID].id,\n                times: rawCurves[nodeID].KeyTime.a.map($04ef886a022e9ae8$var$convertFBXTimeToSeconds),\n                values: rawCurves[nodeID].KeyValueFloat.a\n            };\n            const relationships = $04ef886a022e9ae8$var$connections.get(animationCurve.id);\n            if (relationships !== undefined) {\n                const animationCurveID = relationships.parents[0].ID;\n                const animationCurveRelationship = relationships.parents[0].relationship;\n                if (animationCurveRelationship.match(/X/)) curveNodesMap.get(animationCurveID).curves[\"x\"] = animationCurve;\n                else if (animationCurveRelationship.match(/Y/)) curveNodesMap.get(animationCurveID).curves[\"y\"] = animationCurve;\n                else if (animationCurveRelationship.match(/Z/)) curveNodesMap.get(animationCurveID).curves[\"z\"] = animationCurve;\n                else if (animationCurveRelationship.match(/DeformPercent/) && curveNodesMap.has(animationCurveID)) curveNodesMap.get(animationCurveID).curves[\"morph\"] = animationCurve;\n            }\n        }\n    }\n    // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references\n    // to various AnimationCurveNodes and is referenced by an AnimationStack node\n    // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack\n    parseAnimationLayers(curveNodesMap) {\n        const rawLayers = $04ef886a022e9ae8$var$fbxTree.Objects.AnimationLayer;\n        const layersMap = new Map();\n        for(const nodeID in rawLayers){\n            const layerCurveNodes = [];\n            const connection = $04ef886a022e9ae8$var$connections.get(parseInt(nodeID));\n            if (connection !== undefined) {\n                // all the animationCurveNodes used in the layer\n                const children = connection.children;\n                children.forEach(function(child, i) {\n                    if (curveNodesMap.has(child.ID)) {\n                        const curveNode = curveNodesMap.get(child.ID);\n                        // check that the curves are defined for at least one axis, otherwise ignore the curveNode\n                        if (curveNode.curves.x !== undefined || curveNode.curves.y !== undefined || curveNode.curves.z !== undefined) {\n                            if (layerCurveNodes[i] === undefined) {\n                                const modelID = $04ef886a022e9ae8$var$connections.get(child.ID).parents.filter(function(parent) {\n                                    return parent.relationship !== undefined;\n                                })[0].ID;\n                                if (modelID !== undefined) {\n                                    const rawModel = $04ef886a022e9ae8$var$fbxTree.Objects.Model[modelID.toString()];\n                                    if (rawModel === undefined) {\n                                        console.warn(\"THREE.FBXLoader: Encountered a unused curve.\", child);\n                                        return;\n                                    }\n                                    const node = {\n                                        modelName: rawModel.attrName ? (0, $ilwiq.PropertyBinding).sanitizeNodeName(rawModel.attrName) : \"\",\n                                        ID: rawModel.id,\n                                        initialPosition: [\n                                            0,\n                                            0,\n                                            0\n                                        ],\n                                        initialRotation: [\n                                            0,\n                                            0,\n                                            0\n                                        ],\n                                        initialScale: [\n                                            1,\n                                            1,\n                                            1\n                                        ]\n                                    };\n                                    $04ef886a022e9ae8$var$sceneGraph.traverse(function(child) {\n                                        if (child.ID === rawModel.id) {\n                                            node.transform = child.matrix;\n                                            if (child.userData.transformData) node.eulerOrder = child.userData.transformData.eulerOrder;\n                                        }\n                                    });\n                                    if (!node.transform) node.transform = new (0, $ilwiq.Matrix4)();\n                                    // if the animated model is pre rotated, we'll have to apply the pre rotations to every\n                                    // animation value as well\n                                    if (\"PreRotation\" in rawModel) node.preRotation = rawModel.PreRotation.value;\n                                    if (\"PostRotation\" in rawModel) node.postRotation = rawModel.PostRotation.value;\n                                    layerCurveNodes[i] = node;\n                                }\n                            }\n                            if (layerCurveNodes[i]) layerCurveNodes[i][curveNode.attr] = curveNode;\n                        } else if (curveNode.curves.morph !== undefined) {\n                            if (layerCurveNodes[i] === undefined) {\n                                const deformerID = $04ef886a022e9ae8$var$connections.get(child.ID).parents.filter(function(parent) {\n                                    return parent.relationship !== undefined;\n                                })[0].ID;\n                                const morpherID = $04ef886a022e9ae8$var$connections.get(deformerID).parents[0].ID;\n                                const geoID = $04ef886a022e9ae8$var$connections.get(morpherID).parents[0].ID;\n                                // assuming geometry is not used in more than one model\n                                const modelID = $04ef886a022e9ae8$var$connections.get(geoID).parents[0].ID;\n                                const rawModel = $04ef886a022e9ae8$var$fbxTree.Objects.Model[modelID];\n                                const node = {\n                                    modelName: rawModel.attrName ? (0, $ilwiq.PropertyBinding).sanitizeNodeName(rawModel.attrName) : \"\",\n                                    morphName: $04ef886a022e9ae8$var$fbxTree.Objects.Deformer[deformerID].attrName\n                                };\n                                layerCurveNodes[i] = node;\n                            }\n                            layerCurveNodes[i][curveNode.attr] = curveNode;\n                        }\n                    }\n                });\n                layersMap.set(parseInt(nodeID), layerCurveNodes);\n            }\n        }\n        return layersMap;\n    }\n    // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation\n    // hierarchy. Each Stack node will be used to create a AnimationClip\n    parseAnimStacks(layersMap) {\n        const rawStacks = $04ef886a022e9ae8$var$fbxTree.Objects.AnimationStack;\n        // connect the stacks (clips) up to the layers\n        const rawClips = {};\n        for(const nodeID in rawStacks){\n            const children = $04ef886a022e9ae8$var$connections.get(parseInt(nodeID)).children;\n            if (children.length > 1) // it seems like stacks will always be associated with a single layer. But just in case there are files\n            // where there are multiple layers per stack, we'll display a warning\n            console.warn(\"THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.\");\n            const layer = layersMap.get(children[0].ID);\n            rawClips[nodeID] = {\n                name: rawStacks[nodeID].attrName,\n                layer: layer\n            };\n        }\n        return rawClips;\n    }\n    addClip(rawClip) {\n        let tracks = [];\n        const scope = this;\n        rawClip.layer.forEach(function(rawTracks) {\n            tracks = tracks.concat(scope.generateTracks(rawTracks));\n        });\n        return new (0, $ilwiq.AnimationClip)(rawClip.name, -1, tracks);\n    }\n    generateTracks(rawTracks) {\n        const tracks = [];\n        let initialPosition = new (0, $ilwiq.Vector3)();\n        let initialRotation = new (0, $ilwiq.Quaternion)();\n        let initialScale = new (0, $ilwiq.Vector3)();\n        if (rawTracks.transform) rawTracks.transform.decompose(initialPosition, initialRotation, initialScale);\n        initialPosition = initialPosition.toArray();\n        initialRotation = new (0, $ilwiq.Euler)().setFromQuaternion(initialRotation, rawTracks.eulerOrder).toArray();\n        initialScale = initialScale.toArray();\n        if (rawTracks.T !== undefined && Object.keys(rawTracks.T.curves).length > 0) {\n            const positionTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.T.curves, initialPosition, \"position\");\n            if (positionTrack !== undefined) tracks.push(positionTrack);\n        }\n        if (rawTracks.R !== undefined && Object.keys(rawTracks.R.curves).length > 0) {\n            const rotationTrack = this.generateRotationTrack(rawTracks.modelName, rawTracks.R.curves, initialRotation, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder);\n            if (rotationTrack !== undefined) tracks.push(rotationTrack);\n        }\n        if (rawTracks.S !== undefined && Object.keys(rawTracks.S.curves).length > 0) {\n            const scaleTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.S.curves, initialScale, \"scale\");\n            if (scaleTrack !== undefined) tracks.push(scaleTrack);\n        }\n        if (rawTracks.DeformPercent !== undefined) {\n            const morphTrack = this.generateMorphTrack(rawTracks);\n            if (morphTrack !== undefined) tracks.push(morphTrack);\n        }\n        return tracks;\n    }\n    generateVectorTrack(modelName, curves, initialValue, type) {\n        const times = this.getTimesForAllAxes(curves);\n        const values = this.getKeyframeTrackValues(times, curves, initialValue);\n        return new (0, $ilwiq.VectorKeyframeTrack)(modelName + \".\" + type, times, values);\n    }\n    generateRotationTrack(modelName, curves, initialValue, preRotation, postRotation, eulerOrder) {\n        if (curves.x !== undefined) {\n            this.interpolateRotations(curves.x);\n            curves.x.values = curves.x.values.map((0, $ilwiq.MathUtils).degToRad);\n        }\n        if (curves.y !== undefined) {\n            this.interpolateRotations(curves.y);\n            curves.y.values = curves.y.values.map((0, $ilwiq.MathUtils).degToRad);\n        }\n        if (curves.z !== undefined) {\n            this.interpolateRotations(curves.z);\n            curves.z.values = curves.z.values.map((0, $ilwiq.MathUtils).degToRad);\n        }\n        const times = this.getTimesForAllAxes(curves);\n        const values = this.getKeyframeTrackValues(times, curves, initialValue);\n        if (preRotation !== undefined) {\n            preRotation = preRotation.map((0, $ilwiq.MathUtils).degToRad);\n            preRotation.push(eulerOrder);\n            preRotation = new (0, $ilwiq.Euler)().fromArray(preRotation);\n            preRotation = new (0, $ilwiq.Quaternion)().setFromEuler(preRotation);\n        }\n        if (postRotation !== undefined) {\n            postRotation = postRotation.map((0, $ilwiq.MathUtils).degToRad);\n            postRotation.push(eulerOrder);\n            postRotation = new (0, $ilwiq.Euler)().fromArray(postRotation);\n            postRotation = new (0, $ilwiq.Quaternion)().setFromEuler(postRotation).invert();\n        }\n        const quaternion = new (0, $ilwiq.Quaternion)();\n        const euler = new (0, $ilwiq.Euler)();\n        const quaternionValues = [];\n        for(let i = 0; i < values.length; i += 3){\n            euler.set(values[i], values[i + 1], values[i + 2], eulerOrder);\n            quaternion.setFromEuler(euler);\n            if (preRotation !== undefined) quaternion.premultiply(preRotation);\n            if (postRotation !== undefined) quaternion.multiply(postRotation);\n            quaternion.toArray(quaternionValues, i / 3 * 4);\n        }\n        return new (0, $ilwiq.QuaternionKeyframeTrack)(modelName + \".quaternion\", times, quaternionValues);\n    }\n    generateMorphTrack(rawTracks) {\n        const curves = rawTracks.DeformPercent.curves.morph;\n        const values = curves.values.map(function(val) {\n            return val / 100;\n        });\n        const morphNum = $04ef886a022e9ae8$var$sceneGraph.getObjectByName(rawTracks.modelName).morphTargetDictionary[rawTracks.morphName];\n        return new (0, $ilwiq.NumberKeyframeTrack)(rawTracks.modelName + \".morphTargetInfluences[\" + morphNum + \"]\", curves.times, values);\n    }\n    // For all animated objects, times are defined separately for each axis\n    // Here we'll combine the times into one sorted array without duplicates\n    getTimesForAllAxes(curves) {\n        let times = [];\n        // first join together the times for each axis, if defined\n        if (curves.x !== undefined) times = times.concat(curves.x.times);\n        if (curves.y !== undefined) times = times.concat(curves.y.times);\n        if (curves.z !== undefined) times = times.concat(curves.z.times);\n        // then sort them\n        times = times.sort(function(a, b) {\n            return a - b;\n        });\n        // and remove duplicates\n        if (times.length > 1) {\n            let targetIndex = 1;\n            let lastValue = times[0];\n            for(let i = 1; i < times.length; i++){\n                const currentValue = times[i];\n                if (currentValue !== lastValue) {\n                    times[targetIndex] = currentValue;\n                    lastValue = currentValue;\n                    targetIndex++;\n                }\n            }\n            times = times.slice(0, targetIndex);\n        }\n        return times;\n    }\n    getKeyframeTrackValues(times, curves, initialValue) {\n        const prevValue = initialValue;\n        const values = [];\n        let xIndex = -1;\n        let yIndex = -1;\n        let zIndex = -1;\n        times.forEach(function(time) {\n            if (curves.x) xIndex = curves.x.times.indexOf(time);\n            if (curves.y) yIndex = curves.y.times.indexOf(time);\n            if (curves.z) zIndex = curves.z.times.indexOf(time);\n            // if there is an x value defined for this frame, use that\n            if (xIndex !== -1) {\n                const xValue = curves.x.values[xIndex];\n                values.push(xValue);\n                prevValue[0] = xValue;\n            } else // otherwise use the x value from the previous frame\n            values.push(prevValue[0]);\n            if (yIndex !== -1) {\n                const yValue = curves.y.values[yIndex];\n                values.push(yValue);\n                prevValue[1] = yValue;\n            } else values.push(prevValue[1]);\n            if (zIndex !== -1) {\n                const zValue = curves.z.values[zIndex];\n                values.push(zValue);\n                prevValue[2] = zValue;\n            } else values.push(prevValue[2]);\n        });\n        return values;\n    }\n    // Rotations are defined as Euler angles which can have values  of any size\n    // These will be converted to quaternions which don't support values greater than\n    // PI, so we'll interpolate large rotations\n    interpolateRotations(curve) {\n        for(let i = 1; i < curve.values.length; i++){\n            const initialValue = curve.values[i - 1];\n            const valuesSpan = curve.values[i] - initialValue;\n            const absoluteSpan = Math.abs(valuesSpan);\n            if (absoluteSpan >= 180) {\n                const numSubIntervals = absoluteSpan / 180;\n                const step = valuesSpan / numSubIntervals;\n                let nextValue = initialValue + step;\n                const initialTime = curve.times[i - 1];\n                const timeSpan = curve.times[i] - initialTime;\n                const interval = timeSpan / numSubIntervals;\n                let nextTime = initialTime + interval;\n                const interpolatedTimes = [];\n                const interpolatedValues = [];\n                while(nextTime < curve.times[i]){\n                    interpolatedTimes.push(nextTime);\n                    nextTime += interval;\n                    interpolatedValues.push(nextValue);\n                    nextValue += step;\n                }\n                curve.times = $04ef886a022e9ae8$var$inject(curve.times, i, interpolatedTimes);\n                curve.values = $04ef886a022e9ae8$var$inject(curve.values, i, interpolatedValues);\n            }\n        }\n    }\n}\n// parse an FBX file in ASCII format\nclass $04ef886a022e9ae8$var$TextParser {\n    getPrevNode() {\n        return this.nodeStack[this.currentIndent - 2];\n    }\n    getCurrentNode() {\n        return this.nodeStack[this.currentIndent - 1];\n    }\n    getCurrentProp() {\n        return this.currentProp;\n    }\n    pushStack(node) {\n        this.nodeStack.push(node);\n        this.currentIndent += 1;\n    }\n    popStack() {\n        this.nodeStack.pop();\n        this.currentIndent -= 1;\n    }\n    setCurrentProp(val, name) {\n        this.currentProp = val;\n        this.currentPropName = name;\n    }\n    parse(text) {\n        this.currentIndent = 0;\n        this.allNodes = new $04ef886a022e9ae8$var$FBXTree();\n        this.nodeStack = [];\n        this.currentProp = [];\n        this.currentPropName = \"\";\n        const scope = this;\n        const split = text.split(/[\\r\\n]+/);\n        split.forEach(function(line, i) {\n            const matchComment = line.match(/^[\\s\\t]*;/);\n            const matchEmpty = line.match(/^[\\s\\t]*$/);\n            if (matchComment || matchEmpty) return;\n            const matchBeginning = line.match(\"^\\\\t{\" + scope.currentIndent + \"}(\\\\w+):(.*){\", \"\");\n            const matchProperty = line.match(\"^\\\\t{\" + scope.currentIndent + \"}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)\");\n            const matchEnd = line.match(\"^\\\\t{\" + (scope.currentIndent - 1) + \"}}\");\n            if (matchBeginning) scope.parseNodeBegin(line, matchBeginning);\n            else if (matchProperty) scope.parseNodeProperty(line, matchProperty, split[++i]);\n            else if (matchEnd) scope.popStack();\n            else if (line.match(/^[^\\s\\t}]/)) // large arrays are split over multiple lines terminated with a ',' character\n            // if this is encountered the line needs to be joined to the previous line\n            scope.parseNodePropertyContinued(line);\n        });\n        return this.allNodes;\n    }\n    parseNodeBegin(line, property) {\n        const nodeName = property[1].trim().replace(/^\"/, \"\").replace(/\"$/, \"\");\n        const nodeAttrs = property[2].split(\",\").map(function(attr) {\n            return attr.trim().replace(/^\"/, \"\").replace(/\"$/, \"\");\n        });\n        const node = {\n            name: nodeName\n        };\n        const attrs = this.parseNodeAttr(nodeAttrs);\n        const currentNode = this.getCurrentNode();\n        // a top node\n        if (this.currentIndent === 0) this.allNodes.add(nodeName, node);\n        else {\n            // if the subnode already exists, append it\n            if (nodeName in currentNode) {\n                // special case Pose needs PoseNodes as an array\n                if (nodeName === \"PoseNode\") currentNode.PoseNode.push(node);\n                else if (currentNode[nodeName].id !== undefined) {\n                    currentNode[nodeName] = {};\n                    currentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName];\n                }\n                if (attrs.id !== \"\") currentNode[nodeName][attrs.id] = node;\n            } else if (typeof attrs.id === \"number\") {\n                currentNode[nodeName] = {};\n                currentNode[nodeName][attrs.id] = node;\n            } else if (nodeName !== \"Properties70\") {\n                if (nodeName === \"PoseNode\") currentNode[nodeName] = [\n                    node\n                ];\n                else currentNode[nodeName] = node;\n            }\n        }\n        if (typeof attrs.id === \"number\") node.id = attrs.id;\n        if (attrs.name !== \"\") node.attrName = attrs.name;\n        if (attrs.type !== \"\") node.attrType = attrs.type;\n        this.pushStack(node);\n    }\n    parseNodeAttr(attrs) {\n        let id = attrs[0];\n        if (attrs[0] !== \"\") {\n            id = parseInt(attrs[0]);\n            if (isNaN(id)) id = attrs[0];\n        }\n        let name = \"\", type = \"\";\n        if (attrs.length > 1) {\n            name = attrs[1].replace(/^(\\w+)::/, \"\");\n            type = attrs[2];\n        }\n        return {\n            id: id,\n            name: name,\n            type: type\n        };\n    }\n    parseNodeProperty(line, property, contentLine) {\n        let propName = property[1].replace(/^\"/, \"\").replace(/\"$/, \"\").trim();\n        let propValue = property[2].replace(/^\"/, \"\").replace(/\"$/, \"\").trim();\n        // for special case: base64 image data follows \"Content: ,\" line\n        //\tContent: ,\n        //\t \"/9j/4RDaRXhpZgAATU0A...\"\n        if (propName === \"Content\" && propValue === \",\") propValue = contentLine.replace(/\"/g, \"\").replace(/,$/, \"\").trim();\n        const currentNode = this.getCurrentNode();\n        const parentName = currentNode.name;\n        if (parentName === \"Properties70\") {\n            this.parseNodeSpecialProperty(line, propName, propValue);\n            return;\n        }\n        // Connections\n        if (propName === \"C\") {\n            const connProps = propValue.split(\",\").slice(1);\n            const from = parseInt(connProps[0]);\n            const to = parseInt(connProps[1]);\n            let rest = propValue.split(\",\").slice(3);\n            rest = rest.map(function(elem) {\n                return elem.trim().replace(/^\"/, \"\");\n            });\n            propName = \"connections\";\n            propValue = [\n                from,\n                to\n            ];\n            $04ef886a022e9ae8$var$append(propValue, rest);\n            if (currentNode[propName] === undefined) currentNode[propName] = [];\n        }\n        // Node\n        if (propName === \"Node\") currentNode.id = propValue;\n        // connections\n        if (propName in currentNode && Array.isArray(currentNode[propName])) currentNode[propName].push(propValue);\n        else if (propName !== \"a\") currentNode[propName] = propValue;\n        else currentNode.a = propValue;\n        this.setCurrentProp(currentNode, propName);\n        // convert string to array, unless it ends in ',' in which case more will be added to it\n        if (propName === \"a\" && propValue.slice(-1) !== \",\") currentNode.a = $04ef886a022e9ae8$var$parseNumberArray(propValue);\n    }\n    parseNodePropertyContinued(line) {\n        const currentNode = this.getCurrentNode();\n        currentNode.a += line;\n        // if the line doesn't end in ',' we have reached the end of the property value\n        // so convert the string to an array\n        if (line.slice(-1) !== \",\") currentNode.a = $04ef886a022e9ae8$var$parseNumberArray(currentNode.a);\n    }\n    // parse \"Property70\"\n    parseNodeSpecialProperty(line, propName, propValue) {\n        // split this\n        // P: \"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\",1,1,1\n        // into array like below\n        // [\"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\", \"1,1,1\" ]\n        const props = propValue.split('\",').map(function(prop) {\n            return prop.trim().replace(/^\\\"/, \"\").replace(/\\s/, \"_\");\n        });\n        const innerPropName = props[0];\n        const innerPropType1 = props[1];\n        const innerPropType2 = props[2];\n        const innerPropFlag = props[3];\n        let innerPropValue = props[4];\n        // cast values where needed, otherwise leave as strings\n        switch(innerPropType1){\n            case \"int\":\n            case \"enum\":\n            case \"bool\":\n            case \"ULongLong\":\n            case \"double\":\n            case \"Number\":\n            case \"FieldOfView\":\n                innerPropValue = parseFloat(innerPropValue);\n                break;\n            case \"Color\":\n            case \"ColorRGB\":\n            case \"Vector3D\":\n            case \"Lcl_Translation\":\n            case \"Lcl_Rotation\":\n            case \"Lcl_Scaling\":\n                innerPropValue = $04ef886a022e9ae8$var$parseNumberArray(innerPropValue);\n                break;\n        }\n        // CAUTION: these props must append to parent's parent\n        this.getPrevNode()[innerPropName] = {\n            \"type\": innerPropType1,\n            \"type2\": innerPropType2,\n            \"flag\": innerPropFlag,\n            \"value\": innerPropValue\n        };\n        this.setCurrentProp(this.getPrevNode(), innerPropName);\n    }\n}\n// Parse an FBX file in Binary format\nclass $04ef886a022e9ae8$var$BinaryParser {\n    parse(buffer) {\n        const reader = new $04ef886a022e9ae8$var$BinaryReader(buffer);\n        reader.skip(23); // skip magic 23 bytes\n        const version = reader.getUint32();\n        if (version < 6400) throw new Error(\"THREE.FBXLoader: FBX version not supported, FileVersion: \" + version);\n        const allNodes = new $04ef886a022e9ae8$var$FBXTree();\n        while(!this.endOfContent(reader)){\n            const node = this.parseNode(reader, version);\n            if (node !== null) allNodes.add(node.name, node);\n        }\n        return allNodes;\n    }\n    // Check if reader has reached the end of content.\n    endOfContent(reader) {\n        // footer size: 160bytes + 16-byte alignment padding\n        // - 16bytes: magic\n        // - padding til 16-byte alignment (at least 1byte?)\n        //\t(seems like some exporters embed fixed 15 or 16bytes?)\n        // - 4bytes: magic\n        // - 4bytes: version\n        // - 120bytes: zero\n        // - 16bytes: magic\n        if (reader.size() % 16 === 0) return (reader.getOffset() + 160 + 16 & -16) >= reader.size();\n        else return reader.getOffset() + 160 + 16 >= reader.size();\n    }\n    // recursively parse nodes until the end of the file is reached\n    parseNode(reader, version) {\n        const node = {};\n        // The first three data sizes depends on version.\n        const endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32();\n        const numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32();\n        version >= 7500 ? reader.getUint64() : reader.getUint32(); // the returned propertyListLen is not used\n        const nameLen = reader.getUint8();\n        const name = reader.getString(nameLen);\n        // Regards this node as NULL-record if endOffset is zero\n        if (endOffset === 0) return null;\n        const propertyList = [];\n        for(let i = 0; i < numProperties; i++)propertyList.push(this.parseProperty(reader));\n        // Regards the first three elements in propertyList as id, attrName, and attrType\n        const id = propertyList.length > 0 ? propertyList[0] : \"\";\n        const attrName = propertyList.length > 1 ? propertyList[1] : \"\";\n        const attrType = propertyList.length > 2 ? propertyList[2] : \"\";\n        // check if this node represents just a single property\n        // like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}\n        node.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false;\n        while(endOffset > reader.getOffset()){\n            const subNode = this.parseNode(reader, version);\n            if (subNode !== null) this.parseSubNode(name, node, subNode);\n        }\n        node.propertyList = propertyList; // raw property list used by parent\n        if (typeof id === \"number\") node.id = id;\n        if (attrName !== \"\") node.attrName = attrName;\n        if (attrType !== \"\") node.attrType = attrType;\n        if (name !== \"\") node.name = name;\n        return node;\n    }\n    parseSubNode(name, node, subNode) {\n        // special case: child node is single property\n        if (subNode.singleProperty === true) {\n            const value = subNode.propertyList[0];\n            if (Array.isArray(value)) {\n                node[subNode.name] = subNode;\n                subNode.a = value;\n            } else node[subNode.name] = value;\n        } else if (name === \"Connections\" && subNode.name === \"C\") {\n            const array = [];\n            subNode.propertyList.forEach(function(property, i) {\n                // first Connection is FBX type (OO, OP, etc.). We'll discard these\n                if (i !== 0) array.push(property);\n            });\n            if (node.connections === undefined) node.connections = [];\n            node.connections.push(array);\n        } else if (subNode.name === \"Properties70\") {\n            const keys = Object.keys(subNode);\n            keys.forEach(function(key) {\n                node[key] = subNode[key];\n            });\n        } else if (name === \"Properties70\" && subNode.name === \"P\") {\n            let innerPropName = subNode.propertyList[0];\n            let innerPropType1 = subNode.propertyList[1];\n            const innerPropType2 = subNode.propertyList[2];\n            const innerPropFlag = subNode.propertyList[3];\n            let innerPropValue;\n            if (innerPropName.indexOf(\"Lcl \") === 0) innerPropName = innerPropName.replace(\"Lcl \", \"Lcl_\");\n            if (innerPropType1.indexOf(\"Lcl \") === 0) innerPropType1 = innerPropType1.replace(\"Lcl \", \"Lcl_\");\n            if (innerPropType1 === \"Color\" || innerPropType1 === \"ColorRGB\" || innerPropType1 === \"Vector\" || innerPropType1 === \"Vector3D\" || innerPropType1.indexOf(\"Lcl_\") === 0) innerPropValue = [\n                subNode.propertyList[4],\n                subNode.propertyList[5],\n                subNode.propertyList[6]\n            ];\n            else innerPropValue = subNode.propertyList[4];\n            // this will be copied to parent, see above\n            node[innerPropName] = {\n                \"type\": innerPropType1,\n                \"type2\": innerPropType2,\n                \"flag\": innerPropFlag,\n                \"value\": innerPropValue\n            };\n        } else if (node[subNode.name] === undefined) {\n            if (typeof subNode.id === \"number\") {\n                node[subNode.name] = {};\n                node[subNode.name][subNode.id] = subNode;\n            } else node[subNode.name] = subNode;\n        } else {\n            if (subNode.name === \"PoseNode\") {\n                if (!Array.isArray(node[subNode.name])) node[subNode.name] = [\n                    node[subNode.name]\n                ];\n                node[subNode.name].push(subNode);\n            } else if (node[subNode.name][subNode.id] === undefined) node[subNode.name][subNode.id] = subNode;\n        }\n    }\n    parseProperty(reader) {\n        const type = reader.getString(1);\n        let length;\n        switch(type){\n            case \"C\":\n                return reader.getBoolean();\n            case \"D\":\n                return reader.getFloat64();\n            case \"F\":\n                return reader.getFloat32();\n            case \"I\":\n                return reader.getInt32();\n            case \"L\":\n                return reader.getInt64();\n            case \"R\":\n                length = reader.getUint32();\n                return reader.getArrayBuffer(length);\n            case \"S\":\n                length = reader.getUint32();\n                return reader.getString(length);\n            case \"Y\":\n                return reader.getInt16();\n            case \"b\":\n            case \"c\":\n            case \"d\":\n            case \"f\":\n            case \"i\":\n            case \"l\":\n                const arrayLength = reader.getUint32();\n                const encoding = reader.getUint32(); // 0: non-compressed, 1: compressed\n                const compressedLength = reader.getUint32();\n                if (encoding === 0) switch(type){\n                    case \"b\":\n                    case \"c\":\n                        return reader.getBooleanArray(arrayLength);\n                    case \"d\":\n                        return reader.getFloat64Array(arrayLength);\n                    case \"f\":\n                        return reader.getFloat32Array(arrayLength);\n                    case \"i\":\n                        return reader.getInt32Array(arrayLength);\n                    case \"l\":\n                        return reader.getInt64Array(arrayLength);\n                }\n                const data = $79Zxq.unzlibSync(new Uint8Array(reader.getArrayBuffer(compressedLength)));\n                const reader2 = new $04ef886a022e9ae8$var$BinaryReader(data.buffer);\n                switch(type){\n                    case \"b\":\n                    case \"c\":\n                        return reader2.getBooleanArray(arrayLength);\n                    case \"d\":\n                        return reader2.getFloat64Array(arrayLength);\n                    case \"f\":\n                        return reader2.getFloat32Array(arrayLength);\n                    case \"i\":\n                        return reader2.getInt32Array(arrayLength);\n                    case \"l\":\n                        return reader2.getInt64Array(arrayLength);\n                }\n                break; // cannot happen but is required by the DeepScan\n            default:\n                throw new Error(\"THREE.FBXLoader: Unknown property type \" + type);\n        }\n    }\n}\nclass $04ef886a022e9ae8$var$BinaryReader {\n    constructor(buffer, littleEndian){\n        this.dv = new DataView(buffer);\n        this.offset = 0;\n        this.littleEndian = littleEndian !== undefined ? littleEndian : true;\n        this._textDecoder = new TextDecoder();\n    }\n    getOffset() {\n        return this.offset;\n    }\n    size() {\n        return this.dv.buffer.byteLength;\n    }\n    skip(length) {\n        this.offset += length;\n    }\n    // seems like true/false representation depends on exporter.\n    // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)\n    // then sees LSB.\n    getBoolean() {\n        return (this.getUint8() & 1) === 1;\n    }\n    getBooleanArray(size) {\n        const a = [];\n        for(let i = 0; i < size; i++)a.push(this.getBoolean());\n        return a;\n    }\n    getUint8() {\n        const value = this.dv.getUint8(this.offset);\n        this.offset += 1;\n        return value;\n    }\n    getInt16() {\n        const value = this.dv.getInt16(this.offset, this.littleEndian);\n        this.offset += 2;\n        return value;\n    }\n    getInt32() {\n        const value = this.dv.getInt32(this.offset, this.littleEndian);\n        this.offset += 4;\n        return value;\n    }\n    getInt32Array(size) {\n        const a = [];\n        for(let i = 0; i < size; i++)a.push(this.getInt32());\n        return a;\n    }\n    getUint32() {\n        const value = this.dv.getUint32(this.offset, this.littleEndian);\n        this.offset += 4;\n        return value;\n    }\n    // JavaScript doesn't support 64-bit integer so calculate this here\n    // 1 << 32 will return 1 so using multiply operation instead here.\n    // There's a possibility that this method returns wrong value if the value\n    // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.\n    // TODO: safely handle 64-bit integer\n    getInt64() {\n        let low, high;\n        if (this.littleEndian) {\n            low = this.getUint32();\n            high = this.getUint32();\n        } else {\n            high = this.getUint32();\n            low = this.getUint32();\n        }\n        // calculate negative value\n        if (high & 0x80000000) {\n            high = ~high & 0xFFFFFFFF;\n            low = ~low & 0xFFFFFFFF;\n            if (low === 0xFFFFFFFF) high = high + 1 & 0xFFFFFFFF;\n            low = low + 1 & 0xFFFFFFFF;\n            return -(high * 0x100000000 + low);\n        }\n        return high * 0x100000000 + low;\n    }\n    getInt64Array(size) {\n        const a = [];\n        for(let i = 0; i < size; i++)a.push(this.getInt64());\n        return a;\n    }\n    // Note: see getInt64() comment\n    getUint64() {\n        let low, high;\n        if (this.littleEndian) {\n            low = this.getUint32();\n            high = this.getUint32();\n        } else {\n            high = this.getUint32();\n            low = this.getUint32();\n        }\n        return high * 0x100000000 + low;\n    }\n    getFloat32() {\n        const value = this.dv.getFloat32(this.offset, this.littleEndian);\n        this.offset += 4;\n        return value;\n    }\n    getFloat32Array(size) {\n        const a = [];\n        for(let i = 0; i < size; i++)a.push(this.getFloat32());\n        return a;\n    }\n    getFloat64() {\n        const value = this.dv.getFloat64(this.offset, this.littleEndian);\n        this.offset += 8;\n        return value;\n    }\n    getFloat64Array(size) {\n        const a = [];\n        for(let i = 0; i < size; i++)a.push(this.getFloat64());\n        return a;\n    }\n    getArrayBuffer(size) {\n        const value = this.dv.buffer.slice(this.offset, this.offset + size);\n        this.offset += size;\n        return value;\n    }\n    getString(size) {\n        const start = this.offset;\n        let a = new Uint8Array(this.dv.buffer, start, size);\n        this.skip(size);\n        const nullByte = a.indexOf(0);\n        if (nullByte >= 0) a = new Uint8Array(this.dv.buffer, start, nullByte);\n        return this._textDecoder.decode(a);\n    }\n}\n// FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)\n// and BinaryParser( FBX Binary format)\nclass $04ef886a022e9ae8$var$FBXTree {\n    add(key, val) {\n        this[key] = val;\n    }\n}\n// ************** UTILITY FUNCTIONS **************\nfunction $04ef886a022e9ae8$var$isFbxFormatBinary(buffer) {\n    const CORRECT = \"Kaydara FBX Binary  \\0\";\n    return buffer.byteLength >= CORRECT.length && CORRECT === $04ef886a022e9ae8$var$convertArrayBufferToString(buffer, 0, CORRECT.length);\n}\nfunction $04ef886a022e9ae8$var$isFbxFormatASCII(text) {\n    const CORRECT = [\n        \"K\",\n        \"a\",\n        \"y\",\n        \"d\",\n        \"a\",\n        \"r\",\n        \"a\",\n        \"\\\\\",\n        \"F\",\n        \"B\",\n        \"X\",\n        \"\\\\\",\n        \"B\",\n        \"i\",\n        \"n\",\n        \"a\",\n        \"r\",\n        \"y\",\n        \"\\\\\",\n        \"\\\\\"\n    ];\n    let cursor = 0;\n    function read(offset) {\n        const result = text[offset - 1];\n        text = text.slice(cursor + offset);\n        cursor++;\n        return result;\n    }\n    for(let i = 0; i < CORRECT.length; ++i){\n        const num = read(1);\n        if (num === CORRECT[i]) return false;\n    }\n    return true;\n}\nfunction $04ef886a022e9ae8$var$getFbxVersion(text) {\n    const versionRegExp = /FBXVersion: (\\d+)/;\n    const match = text.match(versionRegExp);\n    if (match) {\n        const version = parseInt(match[1]);\n        return version;\n    }\n    throw new Error(\"THREE.FBXLoader: Cannot find the version number for the file given.\");\n}\n// Converts FBX ticks into real time seconds.\nfunction $04ef886a022e9ae8$var$convertFBXTimeToSeconds(time) {\n    return time / 46186158000;\n}\nconst $04ef886a022e9ae8$var$dataArray = [];\n// extracts the data from the correct position in the FBX array based on indexing type\nfunction $04ef886a022e9ae8$var$getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n    let index;\n    switch(infoObject.mappingType){\n        case \"ByPolygonVertex\":\n            index = polygonVertexIndex;\n            break;\n        case \"ByPolygon\":\n            index = polygonIndex;\n            break;\n        case \"ByVertice\":\n            index = vertexIndex;\n            break;\n        case \"AllSame\":\n            index = infoObject.indices[0];\n            break;\n        default:\n            console.warn(\"THREE.FBXLoader: unknown attribute mapping type \" + infoObject.mappingType);\n    }\n    if (infoObject.referenceType === \"IndexToDirect\") index = infoObject.indices[index];\n    const from = index * infoObject.dataSize;\n    const to = from + infoObject.dataSize;\n    return $04ef886a022e9ae8$var$slice($04ef886a022e9ae8$var$dataArray, infoObject.buffer, from, to);\n}\nconst $04ef886a022e9ae8$var$tempEuler = new (0, $ilwiq.Euler)();\nconst $04ef886a022e9ae8$var$tempVec = new (0, $ilwiq.Vector3)();\n// generate transformation from FBX transform data\n// ref: https://help.autodesk.com/view/FBX/2017/ENU/?guid=__files_GUID_10CDD63C_79C1_4F2D_BB28_AD2BE65A02ED_htm\n// ref: http://docs.autodesk.com/FBX/2014/ENU/FBX-SDK-Documentation/index.html?url=cpp_ref/_transformations_2main_8cxx-example.html,topicNumber=cpp_ref__transformations_2main_8cxx_example_htmlfc10a1e1-b18d-4e72-9dc0-70d0f1959f5e\nfunction $04ef886a022e9ae8$var$generateTransform(transformData) {\n    const lTranslationM = new (0, $ilwiq.Matrix4)();\n    const lPreRotationM = new (0, $ilwiq.Matrix4)();\n    const lRotationM = new (0, $ilwiq.Matrix4)();\n    const lPostRotationM = new (0, $ilwiq.Matrix4)();\n    const lScalingM = new (0, $ilwiq.Matrix4)();\n    const lScalingPivotM = new (0, $ilwiq.Matrix4)();\n    const lScalingOffsetM = new (0, $ilwiq.Matrix4)();\n    const lRotationOffsetM = new (0, $ilwiq.Matrix4)();\n    const lRotationPivotM = new (0, $ilwiq.Matrix4)();\n    const lParentGX = new (0, $ilwiq.Matrix4)();\n    const lParentLX = new (0, $ilwiq.Matrix4)();\n    const lGlobalT = new (0, $ilwiq.Matrix4)();\n    const inheritType = transformData.inheritType ? transformData.inheritType : 0;\n    if (transformData.translation) lTranslationM.setPosition($04ef886a022e9ae8$var$tempVec.fromArray(transformData.translation));\n    if (transformData.preRotation) {\n        const array = transformData.preRotation.map((0, $ilwiq.MathUtils).degToRad);\n        array.push(transformData.eulerOrder || (0, $ilwiq.Euler).DEFAULT_ORDER);\n        lPreRotationM.makeRotationFromEuler($04ef886a022e9ae8$var$tempEuler.fromArray(array));\n    }\n    if (transformData.rotation) {\n        const array = transformData.rotation.map((0, $ilwiq.MathUtils).degToRad);\n        array.push(transformData.eulerOrder || (0, $ilwiq.Euler).DEFAULT_ORDER);\n        lRotationM.makeRotationFromEuler($04ef886a022e9ae8$var$tempEuler.fromArray(array));\n    }\n    if (transformData.postRotation) {\n        const array = transformData.postRotation.map((0, $ilwiq.MathUtils).degToRad);\n        array.push(transformData.eulerOrder || (0, $ilwiq.Euler).DEFAULT_ORDER);\n        lPostRotationM.makeRotationFromEuler($04ef886a022e9ae8$var$tempEuler.fromArray(array));\n        lPostRotationM.invert();\n    }\n    if (transformData.scale) lScalingM.scale($04ef886a022e9ae8$var$tempVec.fromArray(transformData.scale));\n    // Pivots and offsets\n    if (transformData.scalingOffset) lScalingOffsetM.setPosition($04ef886a022e9ae8$var$tempVec.fromArray(transformData.scalingOffset));\n    if (transformData.scalingPivot) lScalingPivotM.setPosition($04ef886a022e9ae8$var$tempVec.fromArray(transformData.scalingPivot));\n    if (transformData.rotationOffset) lRotationOffsetM.setPosition($04ef886a022e9ae8$var$tempVec.fromArray(transformData.rotationOffset));\n    if (transformData.rotationPivot) lRotationPivotM.setPosition($04ef886a022e9ae8$var$tempVec.fromArray(transformData.rotationPivot));\n    // parent transform\n    if (transformData.parentMatrixWorld) {\n        lParentLX.copy(transformData.parentMatrix);\n        lParentGX.copy(transformData.parentMatrixWorld);\n    }\n    const lLRM = lPreRotationM.clone().multiply(lRotationM).multiply(lPostRotationM);\n    // Global Rotation\n    const lParentGRM = new (0, $ilwiq.Matrix4)();\n    lParentGRM.extractRotation(lParentGX);\n    // Global Shear*Scaling\n    const lParentTM = new (0, $ilwiq.Matrix4)();\n    lParentTM.copyPosition(lParentGX);\n    const lParentGRSM = lParentTM.clone().invert().multiply(lParentGX);\n    const lParentGSM = lParentGRM.clone().invert().multiply(lParentGRSM);\n    const lLSM = lScalingM;\n    const lGlobalRS = new (0, $ilwiq.Matrix4)();\n    if (inheritType === 0) lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM).multiply(lLSM);\n    else if (inheritType === 1) lGlobalRS.copy(lParentGRM).multiply(lParentGSM).multiply(lLRM).multiply(lLSM);\n    else {\n        const lParentLSM = new (0, $ilwiq.Matrix4)().scale(new (0, $ilwiq.Vector3)().setFromMatrixScale(lParentLX));\n        const lParentLSM_inv = lParentLSM.clone().invert();\n        const lParentGSM_noLocal = lParentGSM.clone().multiply(lParentLSM_inv);\n        lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM_noLocal).multiply(lLSM);\n    }\n    const lRotationPivotM_inv = lRotationPivotM.clone().invert();\n    const lScalingPivotM_inv = lScalingPivotM.clone().invert();\n    // Calculate the local transform matrix\n    let lTransform = lTranslationM.clone().multiply(lRotationOffsetM).multiply(lRotationPivotM).multiply(lPreRotationM).multiply(lRotationM).multiply(lPostRotationM).multiply(lRotationPivotM_inv).multiply(lScalingOffsetM).multiply(lScalingPivotM).multiply(lScalingM).multiply(lScalingPivotM_inv);\n    const lLocalTWithAllPivotAndOffsetInfo = new (0, $ilwiq.Matrix4)().copyPosition(lTransform);\n    const lGlobalTranslation = lParentGX.clone().multiply(lLocalTWithAllPivotAndOffsetInfo);\n    lGlobalT.copyPosition(lGlobalTranslation);\n    lTransform = lGlobalT.clone().multiply(lGlobalRS);\n    // from global to local\n    lTransform.premultiply(lParentGX.invert());\n    return lTransform;\n}\n// Returns the three.js intrinsic Euler order corresponding to FBX extrinsic Euler order\n// ref: http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html\nfunction $04ef886a022e9ae8$var$getEulerOrder(order) {\n    order = order || 0;\n    const enums = [\n        \"ZYX\",\n        \"YZX\",\n        \"XZY\",\n        \"ZXY\",\n        \"YXZ\",\n        \"XYZ\"\n    ];\n    if (order === 6) {\n        console.warn(\"THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.\");\n        return enums[0];\n    }\n    return enums[order];\n}\n// Parses comma separated list of numbers and returns them an array.\n// Used internally by the TextParser\nfunction $04ef886a022e9ae8$var$parseNumberArray(value) {\n    const array = value.split(\",\").map(function(val) {\n        return parseFloat(val);\n    });\n    return array;\n}\nfunction $04ef886a022e9ae8$var$convertArrayBufferToString(buffer, from, to) {\n    if (from === undefined) from = 0;\n    if (to === undefined) to = buffer.byteLength;\n    return new TextDecoder().decode(new Uint8Array(buffer, from, to));\n}\nfunction $04ef886a022e9ae8$var$append(a, b) {\n    for(let i = 0, j = a.length, l = b.length; i < l; i++, j++)a[j] = b[i];\n}\nfunction $04ef886a022e9ae8$var$slice(a, b, from, to) {\n    for(let i = from, j = 0; i < to; i++, j++)a[j] = b[i];\n    return a;\n}\n// inject array a2 into array a1 at index\nfunction $04ef886a022e9ae8$var$inject(a1, index, a2) {\n    return a1.slice(0, index).concat(a2).concat(a1.slice(index));\n}\n\n});\nparcelRegister(\"79Zxq\", function(module, exports) {\n\n$parcel$export(module.exports, \"unzlibSync\", () => $53691bda533d12d0$export$9ec8134f0f1b9fc6);\n/*!\nfflate - fast JavaScript compression/decompression\n<https://101arrowz.github.io/fflate>\nLicensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE\nversion 0.6.9\n*/ // DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\nvar $53691bda533d12d0$var$ch2 = {};\nvar $53691bda533d12d0$var$durl = function(c) {\n    return URL.createObjectURL(new Blob([\n        c\n    ], {\n        type: \"text/javascript\"\n    }));\n};\nvar $53691bda533d12d0$var$cwk = function(u) {\n    return new Worker(u);\n};\ntry {\n    URL.revokeObjectURL($53691bda533d12d0$var$durl(\"\"));\n} catch (e) {\n    // We're in Deno or a very old browser\n    $53691bda533d12d0$var$durl = function(c) {\n        return \"data:application/javascript;charset=UTF-8,\" + encodeURI(c);\n    };\n    // If Deno, this is necessary; if not, this changes nothing\n    $53691bda533d12d0$var$cwk = function(u) {\n        return new Worker(u, {\n            type: \"module\"\n        });\n    };\n}\nvar $53691bda533d12d0$var$wk = function(c, id, msg, transfer, cb) {\n    var w = $53691bda533d12d0$var$cwk($53691bda533d12d0$var$ch2[id] || ($53691bda533d12d0$var$ch2[id] = $53691bda533d12d0$var$durl(c)));\n    w.onerror = function(e) {\n        return cb(e.error, null);\n    };\n    w.onmessage = function(e) {\n        return cb(null, e.data);\n    };\n    w.postMessage(msg, transfer);\n    return w;\n};\n// aliases for shorter compressed code (most minifers don't do this)\nvar $53691bda533d12d0$var$u8 = Uint8Array, $53691bda533d12d0$var$u16 = Uint16Array, $53691bda533d12d0$var$u32 = Uint32Array;\n// fixed length extra bits\nvar $53691bda533d12d0$var$fleb = new $53691bda533d12d0$var$u8([\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    2,\n    2,\n    2,\n    2,\n    3,\n    3,\n    3,\n    3,\n    4,\n    4,\n    4,\n    4,\n    5,\n    5,\n    5,\n    5,\n    0,\n    /* unused */ 0,\n    0,\n    /* impossible */ 0\n]);\n// fixed distance extra bits\n// see fleb note\nvar $53691bda533d12d0$var$fdeb = new $53691bda533d12d0$var$u8([\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    2,\n    2,\n    3,\n    3,\n    4,\n    4,\n    5,\n    5,\n    6,\n    6,\n    7,\n    7,\n    8,\n    8,\n    9,\n    9,\n    10,\n    10,\n    11,\n    11,\n    12,\n    12,\n    13,\n    13,\n    /* unused */ 0,\n    0\n]);\n// code length index map\nvar $53691bda533d12d0$var$clim = new $53691bda533d12d0$var$u8([\n    16,\n    17,\n    18,\n    0,\n    8,\n    7,\n    9,\n    6,\n    10,\n    5,\n    11,\n    4,\n    12,\n    3,\n    13,\n    2,\n    14,\n    1,\n    15\n]);\n// get base, reverse index map from extra bits\nvar $53691bda533d12d0$var$freb = function(eb, start) {\n    var b = new $53691bda533d12d0$var$u16(31);\n    for(var i = 0; i < 31; ++i)b[i] = start += 1 << eb[i - 1];\n    // numbers here are at max 18 bits\n    var r = new $53691bda533d12d0$var$u32(b[30]);\n    for(var i = 1; i < 30; ++i)for(var j = b[i]; j < b[i + 1]; ++j)r[j] = j - b[i] << 5 | i;\n    return [\n        b,\n        r\n    ];\n};\nvar $53691bda533d12d0$var$_a = $53691bda533d12d0$var$freb($53691bda533d12d0$var$fleb, 2), $53691bda533d12d0$var$fl = $53691bda533d12d0$var$_a[0], $53691bda533d12d0$var$revfl = $53691bda533d12d0$var$_a[1];\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\n$53691bda533d12d0$var$fl[28] = 258, $53691bda533d12d0$var$revfl[258] = 28;\nvar $53691bda533d12d0$var$_b = $53691bda533d12d0$var$freb($53691bda533d12d0$var$fdeb, 0), $53691bda533d12d0$var$fd = $53691bda533d12d0$var$_b[0], $53691bda533d12d0$var$revfd = $53691bda533d12d0$var$_b[1];\n// map of value to reverse (assuming 16 bits)\nvar $53691bda533d12d0$var$rev = new $53691bda533d12d0$var$u16(32768);\nfor(var $53691bda533d12d0$var$i = 0; $53691bda533d12d0$var$i < 32768; ++$53691bda533d12d0$var$i){\n    // reverse table algorithm from SO\n    var $53691bda533d12d0$var$x = ($53691bda533d12d0$var$i & 0xAAAA) >>> 1 | ($53691bda533d12d0$var$i & 0x5555) << 1;\n    $53691bda533d12d0$var$x = ($53691bda533d12d0$var$x & 0xCCCC) >>> 2 | ($53691bda533d12d0$var$x & 0x3333) << 2;\n    $53691bda533d12d0$var$x = ($53691bda533d12d0$var$x & 0xF0F0) >>> 4 | ($53691bda533d12d0$var$x & 0x0F0F) << 4;\n    $53691bda533d12d0$var$rev[$53691bda533d12d0$var$i] = (($53691bda533d12d0$var$x & 0xFF00) >>> 8 | ($53691bda533d12d0$var$x & 0x00FF) << 8) >>> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar $53691bda533d12d0$var$hMap = function(cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new $53691bda533d12d0$var$u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for(; i < s; ++i)++l[cd[i] - 1];\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new $53691bda533d12d0$var$u16(mb);\n    for(i = 0; i < mb; ++i)le[i] = le[i - 1] + l[i - 1] << 1;\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new $53691bda533d12d0$var$u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for(i = 0; i < s; ++i)// ignore 0 lengths\n        if (cd[i]) {\n            // num encoding both symbol and bits read\n            var sv = i << 4 | cd[i];\n            // free bits\n            var r_1 = mb - cd[i];\n            // start value\n            var v = le[cd[i] - 1]++ << r_1;\n            // m is end value\n            for(var m = v | (1 << r_1) - 1; v <= m; ++v)// every 16 bit value starting with the code yields the same result\n            co[$53691bda533d12d0$var$rev[v] >>> rvb] = sv;\n        }\n    } else {\n        co = new $53691bda533d12d0$var$u16(s);\n        for(i = 0; i < s; ++i)if (cd[i]) co[i] = $53691bda533d12d0$var$rev[le[cd[i] - 1]++] >>> 15 - cd[i];\n    }\n    return co;\n};\n// fixed length tree\nvar $53691bda533d12d0$var$flt = new $53691bda533d12d0$var$u8(288);\nfor(var $53691bda533d12d0$var$i = 0; $53691bda533d12d0$var$i < 144; ++$53691bda533d12d0$var$i)$53691bda533d12d0$var$flt[$53691bda533d12d0$var$i] = 8;\nfor(var $53691bda533d12d0$var$i = 144; $53691bda533d12d0$var$i < 256; ++$53691bda533d12d0$var$i)$53691bda533d12d0$var$flt[$53691bda533d12d0$var$i] = 9;\nfor(var $53691bda533d12d0$var$i = 256; $53691bda533d12d0$var$i < 280; ++$53691bda533d12d0$var$i)$53691bda533d12d0$var$flt[$53691bda533d12d0$var$i] = 7;\nfor(var $53691bda533d12d0$var$i = 280; $53691bda533d12d0$var$i < 288; ++$53691bda533d12d0$var$i)$53691bda533d12d0$var$flt[$53691bda533d12d0$var$i] = 8;\n// fixed distance tree\nvar $53691bda533d12d0$var$fdt = new $53691bda533d12d0$var$u8(32);\nfor(var $53691bda533d12d0$var$i = 0; $53691bda533d12d0$var$i < 32; ++$53691bda533d12d0$var$i)$53691bda533d12d0$var$fdt[$53691bda533d12d0$var$i] = 5;\n// fixed length map\nvar $53691bda533d12d0$var$flm = /*#__PURE__*/ $53691bda533d12d0$var$hMap($53691bda533d12d0$var$flt, 9, 0), $53691bda533d12d0$var$flrm = /*#__PURE__*/ $53691bda533d12d0$var$hMap($53691bda533d12d0$var$flt, 9, 1);\n// fixed distance map\nvar $53691bda533d12d0$var$fdm = /*#__PURE__*/ $53691bda533d12d0$var$hMap($53691bda533d12d0$var$fdt, 5, 0), $53691bda533d12d0$var$fdrm = /*#__PURE__*/ $53691bda533d12d0$var$hMap($53691bda533d12d0$var$fdt, 5, 1);\n// find max of array\nvar $53691bda533d12d0$var$max = function(a) {\n    var m = a[0];\n    for(var i = 1; i < a.length; ++i)if (a[i] > m) m = a[i];\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar $53691bda533d12d0$var$bits = function(d, p, m) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8) >> (p & 7) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar $53691bda533d12d0$var$bits16 = function(d, p) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);\n};\n// get end of byte\nvar $53691bda533d12d0$var$shft = function(p) {\n    return (p / 8 | 0) + (p & 7 && 1);\n};\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar $53691bda533d12d0$var$slc = function(v, s, e) {\n    if (s == null || s < 0) s = 0;\n    if (e == null || e > v.length) e = v.length;\n    // can't use .constructor in case user-supplied\n    var n = new (v instanceof $53691bda533d12d0$var$u16 ? $53691bda533d12d0$var$u16 : v instanceof $53691bda533d12d0$var$u32 ? $53691bda533d12d0$var$u32 : $53691bda533d12d0$var$u8)(e - s);\n    n.set(v.subarray(s, e));\n    return n;\n};\n// expands raw DEFLATE data\nvar $53691bda533d12d0$var$inflt = function(dat, buf, st) {\n    // source length\n    var sl = dat.length;\n    if (!sl || st && !st.l && sl < 5) return buf || new $53691bda533d12d0$var$u8(0);\n    // have to estimate size\n    var noBuf = !buf || st;\n    // no state\n    var noSt = !st || st.i;\n    if (!st) st = {};\n    // Assumes roughly 33% compression ratio average\n    if (!buf) buf = new $53691bda533d12d0$var$u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function(l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new $53691bda533d12d0$var$u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            st.f = final = $53691bda533d12d0$var$bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = $53691bda533d12d0$var$bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = $53691bda533d12d0$var$shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;\n                if (t > sl) {\n                    if (noSt) throw \"unexpected EOF\";\n                    break;\n                }\n                // ensure size\n                if (noBuf) cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8;\n                continue;\n            } else if (type == 1) lm = $53691bda533d12d0$var$flrm, dm = $53691bda533d12d0$var$fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = $53691bda533d12d0$var$bits(dat, pos, 31) + 257, hcLen = $53691bda533d12d0$var$bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + $53691bda533d12d0$var$bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new $53691bda533d12d0$var$u8(tl);\n                // code length tree\n                var clt = new $53691bda533d12d0$var$u8(19);\n                for(var i = 0; i < hcLen; ++i)// use index map to get real code\n                clt[$53691bda533d12d0$var$clim[i]] = $53691bda533d12d0$var$bits(dat, pos + i * 3, 7);\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = $53691bda533d12d0$var$max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = $53691bda533d12d0$var$hMap(clt, clb, 1);\n                for(var i = 0; i < tl;){\n                    var r = clm[$53691bda533d12d0$var$bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >>> 4;\n                    // code length to copy\n                    if (s < 16) ldt[i++] = s;\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16) n = 3 + $53691bda533d12d0$var$bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17) n = 3 + $53691bda533d12d0$var$bits(dat, pos, 7), pos += 3;\n                        else if (s == 18) n = 11 + $53691bda533d12d0$var$bits(dat, pos, 127), pos += 7;\n                        while(n--)ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = $53691bda533d12d0$var$max(lt);\n                // max dist bits\n                dbt = $53691bda533d12d0$var$max(dt);\n                lm = $53691bda533d12d0$var$hMap(lt, lbt, 1);\n                dm = $53691bda533d12d0$var$hMap(dt, dbt, 1);\n            } else throw \"invalid block type\";\n            if (pos > tbts) {\n                if (noSt) throw \"unexpected EOF\";\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17;\n        if (noBuf) cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for(;; lpos = pos){\n            // bits read, code\n            var c = lm[$53691bda533d12d0$var$bits16(dat, pos) & lms], sym = c >>> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt) throw \"unexpected EOF\";\n                break;\n            }\n            if (!c) throw \"invalid length/literal\";\n            if (sym < 256) buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            } else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = $53691bda533d12d0$var$fleb[i];\n                    add = $53691bda533d12d0$var$bits(dat, pos, (1 << b) - 1) + $53691bda533d12d0$var$fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[$53691bda533d12d0$var$bits16(dat, pos) & dms], dsym = d >>> 4;\n                if (!d) throw \"invalid distance\";\n                pos += d & 15;\n                var dt = $53691bda533d12d0$var$fd[dsym];\n                if (dsym > 3) {\n                    var b = $53691bda533d12d0$var$fdeb[dsym];\n                    dt += $53691bda533d12d0$var$bits16(dat, pos) & (1 << b) - 1, pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt) throw \"unexpected EOF\";\n                    break;\n                }\n                if (noBuf) cbuf(bt + 131072);\n                var end = bt + add;\n                for(; bt < end; bt += 4){\n                    buf[bt] = buf[bt - dt];\n                    buf[bt + 1] = buf[bt + 1 - dt];\n                    buf[bt + 2] = buf[bt + 2 - dt];\n                    buf[bt + 3] = buf[bt + 3 - dt];\n                }\n                bt = end;\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt;\n        if (lm) final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    }while (!final);\n    return bt == buf.length ? buf : $53691bda533d12d0$var$slc(buf, 0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar $53691bda533d12d0$var$wbits = function(d, p, v) {\n    v <<= p & 7;\n    var o = p / 8 | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar $53691bda533d12d0$var$wbits16 = function(d, p, v) {\n    v <<= p & 7;\n    var o = p / 8 | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n    d[o + 2] |= v >>> 16;\n};\n// creates code lengths from a frequency table\nvar $53691bda533d12d0$var$hTree = function(d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for(var i = 0; i < d.length; ++i)if (d[i]) t.push({\n        s: i,\n        f: d[i]\n    });\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s) return [\n        $53691bda533d12d0$var$et,\n        0\n    ];\n    if (s == 1) {\n        var v = new $53691bda533d12d0$var$u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return [\n            v,\n            1\n        ];\n    }\n    t.sort(function(a, b) {\n        return a.f - b.f;\n    });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({\n        s: -1,\n        f: 25001\n    });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = {\n        s: -1,\n        f: l.f + r.f,\n        l: l,\n        r: r\n    };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while(i1 != s - 1){\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = {\n            s: -1,\n            f: l.f + r.f,\n            l: l,\n            r: r\n        };\n    }\n    var maxSym = t2[0].s;\n    for(var i = 1; i < s; ++i)if (t2[i].s > maxSym) maxSym = t2[i].s;\n    // code lengths\n    var tr = new $53691bda533d12d0$var$u16(maxSym + 1);\n    // max bits in tree\n    var mbt = $53691bda533d12d0$var$ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function(a, b) {\n            return tr[b.s] - tr[a.s] || a.f - b.f;\n        });\n        for(; i < s; ++i){\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << mbt - tr[i2_1]);\n                tr[i2_1] = mb;\n            } else break;\n        }\n        dt >>>= lft;\n        while(dt > 0){\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb) dt -= 1 << mb - tr[i2_2]++ - 1;\n            else ++i;\n        }\n        for(; i >= 0 && dt; --i){\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return [\n        new $53691bda533d12d0$var$u8(tr),\n        mbt\n    ];\n};\n// get the max length and assign length codes\nvar $53691bda533d12d0$var$ln = function(n, l, d) {\n    return n.s == -1 ? Math.max($53691bda533d12d0$var$ln(n.l, l, d + 1), $53691bda533d12d0$var$ln(n.r, l, d + 1)) : l[n.s] = d;\n};\n// length codes generation\nvar $53691bda533d12d0$var$lc = function(c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while(s && !c[--s]);\n    var cl = new $53691bda533d12d0$var$u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function(v) {\n        cl[cli++] = v;\n    };\n    for(var i = 1; i <= s; ++i)if (c[i] == cln && i != s) ++cls;\n    else {\n        if (!cln && cls > 2) {\n            for(; cls > 138; cls -= 138)w(32754);\n            if (cls > 2) {\n                w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);\n                cls = 0;\n            }\n        } else if (cls > 3) {\n            w(cln), --cls;\n            for(; cls > 6; cls -= 6)w(8304);\n            if (cls > 2) w(cls - 3 << 5 | 8208), cls = 0;\n        }\n        while(cls--)w(cln);\n        cls = 1;\n        cln = c[i];\n    }\n    return [\n        cl.subarray(0, cli),\n        s\n    ];\n};\n// calculate the length of output from tree, code lengths\nvar $53691bda533d12d0$var$clen = function(cf, cl) {\n    var l = 0;\n    for(var i = 0; i < cl.length; ++i)l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar $53691bda533d12d0$var$wfblk = function(out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = $53691bda533d12d0$var$shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >>> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for(var i = 0; i < s; ++i)out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar $53691bda533d12d0$var$wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    $53691bda533d12d0$var$wbits(out, p++, final);\n    ++lf[256];\n    var _a = $53691bda533d12d0$var$hTree(lf, 15), dlt = _a[0], mlb = _a[1];\n    var _b = $53691bda533d12d0$var$hTree(df, 15), ddt = _b[0], mdb = _b[1];\n    var _c = $53691bda533d12d0$var$lc(dlt), lclt = _c[0], nlc = _c[1];\n    var _d = $53691bda533d12d0$var$lc(ddt), lcdt = _d[0], ndc = _d[1];\n    var lcfreq = new $53691bda533d12d0$var$u16(19);\n    for(var i = 0; i < lclt.length; ++i)lcfreq[lclt[i] & 31]++;\n    for(var i = 0; i < lcdt.length; ++i)lcfreq[lcdt[i] & 31]++;\n    var _e = $53691bda533d12d0$var$hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];\n    var nlcc = 19;\n    for(; nlcc > 4 && !lct[$53691bda533d12d0$var$clim[nlcc - 1]]; --nlcc);\n    var flen = bl + 5 << 3;\n    var ftlen = $53691bda533d12d0$var$clen(lf, $53691bda533d12d0$var$flt) + $53691bda533d12d0$var$clen(df, $53691bda533d12d0$var$fdt) + eb;\n    var dtlen = $53691bda533d12d0$var$clen(lf, dlt) + $53691bda533d12d0$var$clen(df, ddt) + eb + 14 + 3 * nlcc + $53691bda533d12d0$var$clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);\n    if (flen <= ftlen && flen <= dtlen) return $53691bda533d12d0$var$wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    $53691bda533d12d0$var$wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = $53691bda533d12d0$var$hMap(dlt, mlb, 0), ll = dlt, dm = $53691bda533d12d0$var$hMap(ddt, mdb, 0), dl = ddt;\n        var llm = $53691bda533d12d0$var$hMap(lct, mlcb, 0);\n        $53691bda533d12d0$var$wbits(out, p, nlc - 257);\n        $53691bda533d12d0$var$wbits(out, p + 5, ndc - 1);\n        $53691bda533d12d0$var$wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for(var i = 0; i < nlcc; ++i)$53691bda533d12d0$var$wbits(out, p + 3 * i, lct[$53691bda533d12d0$var$clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [\n            lclt,\n            lcdt\n        ];\n        for(var it = 0; it < 2; ++it){\n            var clct = lcts[it];\n            for(var i = 0; i < clct.length; ++i){\n                var len = clct[i] & 31;\n                $53691bda533d12d0$var$wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15) $53691bda533d12d0$var$wbits(out, p, clct[i] >>> 5 & 127), p += clct[i] >>> 12;\n            }\n        }\n    } else lm = $53691bda533d12d0$var$flm, ll = $53691bda533d12d0$var$flt, dm = $53691bda533d12d0$var$fdm, dl = $53691bda533d12d0$var$fdt;\n    for(var i = 0; i < li; ++i)if (syms[i] > 255) {\n        var len = syms[i] >>> 18 & 31;\n        $53691bda533d12d0$var$wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n        if (len > 7) $53691bda533d12d0$var$wbits(out, p, syms[i] >>> 23 & 31), p += $53691bda533d12d0$var$fleb[len];\n        var dst = syms[i] & 31;\n        $53691bda533d12d0$var$wbits16(out, p, dm[dst]), p += dl[dst];\n        if (dst > 3) $53691bda533d12d0$var$wbits16(out, p, syms[i] >>> 5 & 8191), p += $53691bda533d12d0$var$fdeb[dst];\n    } else $53691bda533d12d0$var$wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];\n    $53691bda533d12d0$var$wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar $53691bda533d12d0$var$deo = /*#__PURE__*/ new $53691bda533d12d0$var$u32([\n    65540,\n    131080,\n    131088,\n    131104,\n    262176,\n    1048704,\n    1048832,\n    2114560,\n    2117632\n]);\n// empty\nvar $53691bda533d12d0$var$et = /*#__PURE__*/ new $53691bda533d12d0$var$u8(0);\n// compresses data into a raw DEFLATE buffer\nvar $53691bda533d12d0$var$dflt = function(dat, lvl, plvl, pre, post, lst) {\n    var s = dat.length;\n    var o = new $53691bda533d12d0$var$u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var pos = 0;\n    if (!lvl || s < 8) for(var i = 0; i <= s; i += 65535){\n        // end\n        var e = i + 65535;\n        if (e < s) // write full block\n        pos = $53691bda533d12d0$var$wfblk(w, pos, dat.subarray(i, e));\n        else {\n            // write final block\n            w[i] = lst;\n            pos = $53691bda533d12d0$var$wfblk(w, pos, dat.subarray(i, s));\n        }\n    }\n    else {\n        var opt = $53691bda533d12d0$var$deo[lvl - 1];\n        var n = opt >>> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = new $53691bda533d12d0$var$u16(32768), head = new $53691bda533d12d0$var$u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function(i) {\n            return (dat[i] ^ dat[i + 1] << bs1_1 ^ dat[i + 2] << bs2_1) & msk_1;\n        };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new $53691bda533d12d0$var$u32(25000);\n        // length/literal freq   distance freq\n        var lf = new $53691bda533d12d0$var$u16(288), df = new $53691bda533d12d0$var$u16(32);\n        //  l/lcnt  exbits  index  l/lind  waitdx  bitpos\n        var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;\n        for(; i < s; ++i){\n            // hash value\n            // deopt when i > s - 3 - at end, deopt acceptable\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && rem > 423) {\n                    pos = $53691bda533d12d0$var$wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for(var j = 0; j < 286; ++j)lf[j] = 0;\n                    for(var j = 0; j < 30; ++j)df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while(dif <= maxd && --ch_1 && imod != pimod){\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for(; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl);\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn) break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for(var j = 0; j < mmd; ++j){\n                                    var ti = i - dif + j + 32768 & 32767;\n                                    var pti = prev[ti];\n                                    var cd = ti - pti + 32768 & 32767;\n                                    if (cd > md) md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += imod - pimod + 32768 & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one Uint32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | $53691bda533d12d0$var$revfl[l] << 18 | $53691bda533d12d0$var$revfd[d];\n                    var lin = $53691bda533d12d0$var$revfl[l] & 31, din = $53691bda533d12d0$var$revfd[d] & 31;\n                    eb += $53691bda533d12d0$var$fleb[lin] + $53691bda533d12d0$var$fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                } else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        pos = $53691bda533d12d0$var$wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        // this is the easiest way to avoid needing to maintain state\n        if (!lst && pos & 7) pos = $53691bda533d12d0$var$wfblk(w, pos + 1, $53691bda533d12d0$var$et);\n    }\n    return $53691bda533d12d0$var$slc(o, 0, pre + $53691bda533d12d0$var$shft(pos) + post);\n};\n// CRC32 table\nvar $53691bda533d12d0$var$crct = /*#__PURE__*/ function() {\n    var t = new $53691bda533d12d0$var$u32(256);\n    for(var i = 0; i < 256; ++i){\n        var c = i, k = 9;\n        while(--k)c = (c & 1 && 0xEDB88320) ^ c >>> 1;\n        t[i] = c;\n    }\n    return t;\n}();\n// CRC32\nvar $53691bda533d12d0$var$crc = function() {\n    var c = -1;\n    return {\n        p: function(d) {\n            // closures have awful performance\n            var cr = c;\n            for(var i = 0; i < d.length; ++i)cr = $53691bda533d12d0$var$crct[cr & 255 ^ d[i]] ^ cr >>> 8;\n            c = cr;\n        },\n        d: function() {\n            return ~c;\n        }\n    };\n};\n// Alder32\nvar $53691bda533d12d0$var$adler = function() {\n    var a = 1, b = 0;\n    return {\n        p: function(d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length;\n            for(var i = 0; i != l;){\n                var e = Math.min(i + 2655, l);\n                for(; i < e; ++i)m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function() {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | a >>> 8 << 16 | (b & 255) << 8 | b >>> 8;\n        }\n    };\n};\n// deflate with opts\nvar $53691bda533d12d0$var$dopt = function(dat, opt, pre, post, st) {\n    return $53691bda533d12d0$var$dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 12 + opt.mem, pre, post, !st);\n};\n// Walmart object spread\nvar $53691bda533d12d0$var$mrg = function(a, b) {\n    var o = {};\n    for(var k in a)o[k] = a[k];\n    for(var k in b)o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar $53691bda533d12d0$var$wcln = function(fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf(\"[\") + 1, st.lastIndexOf(\"]\")).replace(/ /g, \"\").split(\",\");\n    for(var i = 0; i < dt.length; ++i){\n        var v = dt[i], k = ks[i];\n        if (typeof v == \"function\") {\n            fnStr += \";\" + k + \"=\";\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf(\"[native code]\") != -1) {\n                    var spInd = st_1.indexOf(\" \", 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf(\"(\", spInd));\n                } else {\n                    fnStr += st_1;\n                    for(var t in v.prototype)fnStr += \";\" + k + \".prototype.\" + t + \"=\" + v.prototype[t].toString();\n                }\n            } else fnStr += st_1;\n        } else td[k] = v;\n    }\n    return [\n        fnStr,\n        td\n    ];\n};\nvar $53691bda533d12d0$var$ch = [];\n// clone bufs\nvar $53691bda533d12d0$var$cbfs = function(v) {\n    var tl = [];\n    for(var k in v)if (v[k] instanceof $53691bda533d12d0$var$u8 || v[k] instanceof $53691bda533d12d0$var$u16 || v[k] instanceof $53691bda533d12d0$var$u32) tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n    return tl;\n};\n// use a worker to execute code\nvar $53691bda533d12d0$var$wrkr = function(fns, init, id, cb) {\n    var _a;\n    if (!$53691bda533d12d0$var$ch[id]) {\n        var fnStr = \"\", td_1 = {}, m = fns.length - 1;\n        for(var i = 0; i < m; ++i)_a = $53691bda533d12d0$var$wcln(fns[i], fnStr, td_1), fnStr = _a[0], td_1 = _a[1];\n        $53691bda533d12d0$var$ch[id] = $53691bda533d12d0$var$wcln(fns[m], fnStr, td_1);\n    }\n    var td = $53691bda533d12d0$var$mrg({}, $53691bda533d12d0$var$ch[id][1]);\n    return $53691bda533d12d0$var$wk($53691bda533d12d0$var$ch[id][0] + \";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=\" + init.toString() + \"}\", id, td, $53691bda533d12d0$var$cbfs(td), cb);\n};\n// base async inflate fn\nvar $53691bda533d12d0$var$bInflt = function() {\n    return [\n        $53691bda533d12d0$var$u8,\n        $53691bda533d12d0$var$u16,\n        $53691bda533d12d0$var$u32,\n        $53691bda533d12d0$var$fleb,\n        $53691bda533d12d0$var$fdeb,\n        $53691bda533d12d0$var$clim,\n        $53691bda533d12d0$var$fl,\n        $53691bda533d12d0$var$fd,\n        $53691bda533d12d0$var$flrm,\n        $53691bda533d12d0$var$fdrm,\n        $53691bda533d12d0$var$rev,\n        $53691bda533d12d0$var$hMap,\n        $53691bda533d12d0$var$max,\n        $53691bda533d12d0$var$bits,\n        $53691bda533d12d0$var$bits16,\n        $53691bda533d12d0$var$shft,\n        $53691bda533d12d0$var$slc,\n        $53691bda533d12d0$var$inflt,\n        $53691bda533d12d0$export$90366d8b308ba94a,\n        $53691bda533d12d0$var$pbf,\n        $53691bda533d12d0$var$gu8\n    ];\n};\nvar $53691bda533d12d0$var$bDflt = function() {\n    return [\n        $53691bda533d12d0$var$u8,\n        $53691bda533d12d0$var$u16,\n        $53691bda533d12d0$var$u32,\n        $53691bda533d12d0$var$fleb,\n        $53691bda533d12d0$var$fdeb,\n        $53691bda533d12d0$var$clim,\n        $53691bda533d12d0$var$revfl,\n        $53691bda533d12d0$var$revfd,\n        $53691bda533d12d0$var$flm,\n        $53691bda533d12d0$var$flt,\n        $53691bda533d12d0$var$fdm,\n        $53691bda533d12d0$var$fdt,\n        $53691bda533d12d0$var$rev,\n        $53691bda533d12d0$var$deo,\n        $53691bda533d12d0$var$et,\n        $53691bda533d12d0$var$hMap,\n        $53691bda533d12d0$var$wbits,\n        $53691bda533d12d0$var$wbits16,\n        $53691bda533d12d0$var$hTree,\n        $53691bda533d12d0$var$ln,\n        $53691bda533d12d0$var$lc,\n        $53691bda533d12d0$var$clen,\n        $53691bda533d12d0$var$wfblk,\n        $53691bda533d12d0$var$wblk,\n        $53691bda533d12d0$var$shft,\n        $53691bda533d12d0$var$slc,\n        $53691bda533d12d0$var$dflt,\n        $53691bda533d12d0$var$dopt,\n        $53691bda533d12d0$export$21533ff51b8a0b4a,\n        $53691bda533d12d0$var$pbf\n    ];\n};\n// gzip extra\nvar $53691bda533d12d0$var$gze = function() {\n    return [\n        $53691bda533d12d0$var$gzh,\n        $53691bda533d12d0$var$gzhl,\n        $53691bda533d12d0$var$wbytes,\n        $53691bda533d12d0$var$crc,\n        $53691bda533d12d0$var$crct\n    ];\n};\n// gunzip extra\nvar $53691bda533d12d0$var$guze = function() {\n    return [\n        $53691bda533d12d0$var$gzs,\n        $53691bda533d12d0$var$gzl\n    ];\n};\n// zlib extra\nvar $53691bda533d12d0$var$zle = function() {\n    return [\n        $53691bda533d12d0$var$zlh,\n        $53691bda533d12d0$var$wbytes,\n        $53691bda533d12d0$var$adler\n    ];\n};\n// unzlib extra\nvar $53691bda533d12d0$var$zule = function() {\n    return [\n        $53691bda533d12d0$var$zlv\n    ];\n};\n// post buf\nvar $53691bda533d12d0$var$pbf = function(msg) {\n    return postMessage(msg, [\n        msg.buffer\n    ]);\n};\n// get u8\nvar $53691bda533d12d0$var$gu8 = function(o) {\n    return o && o.size && new $53691bda533d12d0$var$u8(o.size);\n};\n// async helper\nvar $53691bda533d12d0$var$cbify = function(dat, opts, fns, init, id, cb) {\n    var w = $53691bda533d12d0$var$wrkr(fns, init, id, function(err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([\n        dat,\n        opts\n    ], opts.consume ? [\n        dat.buffer\n    ] : []);\n    return function() {\n        w.terminate();\n    };\n};\n// auto stream\nvar $53691bda533d12d0$var$astrm = function(strm) {\n    strm.ondata = function(dat, final) {\n        return postMessage([\n            dat,\n            final\n        ], [\n            dat.buffer\n        ]);\n    };\n    return function(ev) {\n        return strm.push(ev.data[0], ev.data[1]);\n    };\n};\n// async stream attach\nvar $53691bda533d12d0$var$astrmify = function(fns, strm, opts, init, id) {\n    var t;\n    var w = $53691bda533d12d0$var$wrkr(fns, init, id, function(err, dat) {\n        if (err) w.terminate(), strm.ondata.call(strm, err);\n        else {\n            if (dat[1]) w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.push = function(d, f) {\n        if (t) throw \"stream finished\";\n        if (!strm.ondata) throw \"no stream handler\";\n        w.postMessage([\n            d,\n            t = f\n        ], [\n            d.buffer\n        ]);\n    };\n    strm.terminate = function() {\n        w.terminate();\n    };\n};\n// read 2 bytes\nvar $53691bda533d12d0$var$b2 = function(d, b) {\n    return d[b] | d[b + 1] << 8;\n};\n// read 4 bytes\nvar $53691bda533d12d0$var$b4 = function(d, b) {\n    return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;\n};\nvar $53691bda533d12d0$var$b8 = function(d, b) {\n    return $53691bda533d12d0$var$b4(d, b) + $53691bda533d12d0$var$b4(d, b + 4) * 4294967296;\n};\n// write bytes\nvar $53691bda533d12d0$var$wbytes = function(d, b, v) {\n    for(; v; ++b)d[b] = v, v >>>= 8;\n};\n// gzip header\nvar $53691bda533d12d0$var$gzh = function(c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0) $53691bda533d12d0$var$wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for(var i = 0; i <= fn.length; ++i)c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar $53691bda533d12d0$var$gzs = function(d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8) throw \"invalid gzip data\";\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4) st += d[10] | (d[11] << 8) + 2;\n    for(var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++]);\n    return st + (flg & 2);\n};\n// gzip length\nvar $53691bda533d12d0$var$gzl = function(d) {\n    var l = d.length;\n    return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;\n};\n// gzip header length\nvar $53691bda533d12d0$var$gzhl = function(o) {\n    return 10 + (o.filename && o.filename.length + 1 || 0);\n};\n// zlib header\nvar $53691bda533d12d0$var$zlh = function(c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = fl << 6 | (fl ? 32 - 2 * fl : 1);\n};\n// zlib valid\nvar $53691bda533d12d0$var$zlv = function(d) {\n    if ((d[0] & 15) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31) throw \"invalid zlib data\";\n    if (d[1] & 32) throw \"invalid zlib data: preset dictionaries not supported\";\n};\nfunction $53691bda533d12d0$var$AsyncCmpStrm(opts, cb) {\n    if (!cb && typeof opts == \"function\") cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n// zlib footer: -4 to -0 is Adler32\n/**\n * Streaming DEFLATE compression\n */ var $53691bda533d12d0$export$ae157b6234afe138 = /*#__PURE__*/ function() {\n    function Deflate(opts, cb) {\n        if (!cb && typeof opts == \"function\") cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n    }\n    Deflate.prototype.p = function(c, f) {\n        this.ondata($53691bda533d12d0$var$dopt(c, this.o, 0, 0, !f), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Deflate.prototype.push = function(chunk, final) {\n        if (this.d) throw \"stream finished\";\n        if (!this.ondata) throw \"no stream handler\";\n        this.d = final;\n        this.p(chunk, final || false);\n    };\n    return Deflate;\n}();\n/**\n * Asynchronous streaming DEFLATE compression\n */ var $53691bda533d12d0$export$84e526fabcba03e3 = /*#__PURE__*/ function() {\n    function AsyncDeflate(opts, cb) {\n        $53691bda533d12d0$var$astrmify([\n            $53691bda533d12d0$var$bDflt,\n            function() {\n                return [\n                    $53691bda533d12d0$var$astrm,\n                    $53691bda533d12d0$export$ae157b6234afe138\n                ];\n            }\n        ], this, $53691bda533d12d0$var$AsyncCmpStrm.call(this, opts, cb), function(ev) {\n            var strm = new $53691bda533d12d0$export$ae157b6234afe138(ev.data);\n            onmessage = $53691bda533d12d0$var$astrm(strm);\n        }, 6);\n    }\n    return AsyncDeflate;\n}();\nfunction $53691bda533d12d0$export$2316623ecd1285ab(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return $53691bda533d12d0$var$cbify(data, opts, [\n        $53691bda533d12d0$var$bDflt\n    ], function(ev) {\n        return $53691bda533d12d0$var$pbf($53691bda533d12d0$export$21533ff51b8a0b4a(ev.data[0], ev.data[1]));\n    }, 0, cb);\n}\nfunction $53691bda533d12d0$export$21533ff51b8a0b4a(data, opts) {\n    return $53691bda533d12d0$var$dopt(data, opts || {}, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */ var $53691bda533d12d0$export$d1de70a877d6e43c = /*#__PURE__*/ function() {\n    /**\n     * Creates an inflation stream\n     * @param cb The callback to call whenever data is inflated\n     */ function Inflate(cb) {\n        this.s = {};\n        this.p = new $53691bda533d12d0$var$u8(0);\n        this.ondata = cb;\n    }\n    Inflate.prototype.e = function(c) {\n        if (this.d) throw \"stream finished\";\n        if (!this.ondata) throw \"no stream handler\";\n        var l = this.p.length;\n        var n = new $53691bda533d12d0$var$u8(l + c.length);\n        n.set(this.p), n.set(c, l), this.p = n;\n    };\n    Inflate.prototype.c = function(final) {\n        this.d = this.s.i = final || false;\n        var bts = this.s.b;\n        var dt = $53691bda533d12d0$var$inflt(this.p, this.o, this.s);\n        this.ondata($53691bda533d12d0$var$slc(dt, bts, this.s.b), this.d);\n        this.o = $53691bda533d12d0$var$slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = $53691bda533d12d0$var$slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */ Inflate.prototype.push = function(chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}();\n/**\n * Asynchronous streaming DEFLATE decompression\n */ var $53691bda533d12d0$export$fff8358d6dbaa9cc = /*#__PURE__*/ function() {\n    /**\n     * Creates an asynchronous inflation stream\n     * @param cb The callback to call whenever data is deflated\n     */ function AsyncInflate(cb) {\n        this.ondata = cb;\n        $53691bda533d12d0$var$astrmify([\n            $53691bda533d12d0$var$bInflt,\n            function() {\n                return [\n                    $53691bda533d12d0$var$astrm,\n                    $53691bda533d12d0$export$d1de70a877d6e43c\n                ];\n            }\n        ], this, 0, function() {\n            var strm = new $53691bda533d12d0$export$d1de70a877d6e43c();\n            onmessage = $53691bda533d12d0$var$astrm(strm);\n        }, 7);\n    }\n    return AsyncInflate;\n}();\nfunction $53691bda533d12d0$export$cae1ce83fe4a1782(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return $53691bda533d12d0$var$cbify(data, opts, [\n        $53691bda533d12d0$var$bInflt\n    ], function(ev) {\n        return $53691bda533d12d0$var$pbf($53691bda533d12d0$export$90366d8b308ba94a(ev.data[0], $53691bda533d12d0$var$gu8(ev.data[1])));\n    }, 1, cb);\n}\nfunction $53691bda533d12d0$export$90366d8b308ba94a(data, out) {\n    return $53691bda533d12d0$var$inflt(data, out);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */ var $53691bda533d12d0$export$8e4b66d280bf8342 = /*#__PURE__*/ function() {\n    function Gzip(opts, cb) {\n        this.c = $53691bda533d12d0$var$crc();\n        this.l = 0;\n        this.v = 1;\n        $53691bda533d12d0$export$ae157b6234afe138.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Gzip.prototype.push = function(chunk, final) {\n        $53691bda533d12d0$export$ae157b6234afe138.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function(c, f) {\n        this.c.p(c);\n        this.l += c.length;\n        var raw = $53691bda533d12d0$var$dopt(c, this.o, this.v && $53691bda533d12d0$var$gzhl(this.o), f && 8, !f);\n        if (this.v) $53691bda533d12d0$var$gzh(raw, this.o), this.v = 0;\n        if (f) $53691bda533d12d0$var$wbytes(raw, raw.length - 8, this.c.d()), $53691bda533d12d0$var$wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    return Gzip;\n}();\n/**\n * Asynchronous streaming GZIP compression\n */ var $53691bda533d12d0$export$b4c75ae96cdf708b = /*#__PURE__*/ function() {\n    function AsyncGzip(opts, cb) {\n        $53691bda533d12d0$var$astrmify([\n            $53691bda533d12d0$var$bDflt,\n            $53691bda533d12d0$var$gze,\n            function() {\n                return [\n                    $53691bda533d12d0$var$astrm,\n                    $53691bda533d12d0$export$ae157b6234afe138,\n                    $53691bda533d12d0$export$8e4b66d280bf8342\n                ];\n            }\n        ], this, $53691bda533d12d0$var$AsyncCmpStrm.call(this, opts, cb), function(ev) {\n            var strm = new $53691bda533d12d0$export$8e4b66d280bf8342(ev.data);\n            onmessage = $53691bda533d12d0$var$astrm(strm);\n        }, 8);\n    }\n    return AsyncGzip;\n}();\nfunction $53691bda533d12d0$export$69f0ea7cf3a331a8(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return $53691bda533d12d0$var$cbify(data, opts, [\n        $53691bda533d12d0$var$bDflt,\n        $53691bda533d12d0$var$gze,\n        function() {\n            return [\n                $53691bda533d12d0$export$3d616c3fb3e15483\n            ];\n        }\n    ], function(ev) {\n        return $53691bda533d12d0$var$pbf($53691bda533d12d0$export$3d616c3fb3e15483(ev.data[0], ev.data[1]));\n    }, 2, cb);\n}\nfunction $53691bda533d12d0$export$3d616c3fb3e15483(data, opts) {\n    if (!opts) opts = {};\n    var c = $53691bda533d12d0$var$crc(), l = data.length;\n    c.p(data);\n    var d = $53691bda533d12d0$var$dopt(data, opts, $53691bda533d12d0$var$gzhl(opts), 8), s = d.length;\n    return $53691bda533d12d0$var$gzh(d, opts), $53691bda533d12d0$var$wbytes(d, s - 8, c.d()), $53691bda533d12d0$var$wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming GZIP decompression\n */ var $53691bda533d12d0$export$4cb607de6db70415 = /*#__PURE__*/ function() {\n    /**\n     * Creates a GUNZIP stream\n     * @param cb The callback to call whenever data is inflated\n     */ function Gunzip(cb) {\n        this.v = 1;\n        $53691bda533d12d0$export$d1de70a877d6e43c.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Gunzip.prototype.push = function(chunk, final) {\n        $53691bda533d12d0$export$d1de70a877d6e43c.prototype.e.call(this, chunk);\n        if (this.v) {\n            var s = this.p.length > 3 ? $53691bda533d12d0$var$gzs(this.p) : 4;\n            if (s >= this.p.length && !final) return;\n            this.p = this.p.subarray(s), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 8) throw \"invalid gzip stream\";\n            this.p = this.p.subarray(0, -8);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        $53691bda533d12d0$export$d1de70a877d6e43c.prototype.c.call(this, final);\n    };\n    return Gunzip;\n}();\n/**\n * Asynchronous streaming GZIP decompression\n */ var $53691bda533d12d0$export$d5adcdd968132151 = /*#__PURE__*/ function() {\n    /**\n     * Creates an asynchronous GUNZIP stream\n     * @param cb The callback to call whenever data is deflated\n     */ function AsyncGunzip(cb) {\n        this.ondata = cb;\n        $53691bda533d12d0$var$astrmify([\n            $53691bda533d12d0$var$bInflt,\n            $53691bda533d12d0$var$guze,\n            function() {\n                return [\n                    $53691bda533d12d0$var$astrm,\n                    $53691bda533d12d0$export$d1de70a877d6e43c,\n                    $53691bda533d12d0$export$4cb607de6db70415\n                ];\n            }\n        ], this, 0, function() {\n            var strm = new $53691bda533d12d0$export$4cb607de6db70415();\n            onmessage = $53691bda533d12d0$var$astrm(strm);\n        }, 9);\n    }\n    return AsyncGunzip;\n}();\nfunction $53691bda533d12d0$export$b6df3e950734d697(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return $53691bda533d12d0$var$cbify(data, opts, [\n        $53691bda533d12d0$var$bInflt,\n        $53691bda533d12d0$var$guze,\n        function() {\n            return [\n                $53691bda533d12d0$export$c80456f7aaba691c\n            ];\n        }\n    ], function(ev) {\n        return $53691bda533d12d0$var$pbf($53691bda533d12d0$export$c80456f7aaba691c(ev.data[0]));\n    }, 3, cb);\n}\nfunction $53691bda533d12d0$export$c80456f7aaba691c(data, out) {\n    return $53691bda533d12d0$var$inflt(data.subarray($53691bda533d12d0$var$gzs(data), -8), out || new $53691bda533d12d0$var$u8($53691bda533d12d0$var$gzl(data)));\n}\n/**\n * Streaming Zlib compression\n */ var $53691bda533d12d0$export$4187ccf2467013b9 = /*#__PURE__*/ function() {\n    function Zlib(opts, cb) {\n        this.c = $53691bda533d12d0$var$adler();\n        this.v = 1;\n        $53691bda533d12d0$export$ae157b6234afe138.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Zlib.prototype.push = function(chunk, final) {\n        $53691bda533d12d0$export$ae157b6234afe138.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function(c, f) {\n        this.c.p(c);\n        var raw = $53691bda533d12d0$var$dopt(c, this.o, this.v && 2, f && 4, !f);\n        if (this.v) $53691bda533d12d0$var$zlh(raw, this.o), this.v = 0;\n        if (f) $53691bda533d12d0$var$wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    return Zlib;\n}();\n/**\n * Asynchronous streaming Zlib compression\n */ var $53691bda533d12d0$export$bedbe3a2c2136490 = /*#__PURE__*/ function() {\n    function AsyncZlib(opts, cb) {\n        $53691bda533d12d0$var$astrmify([\n            $53691bda533d12d0$var$bDflt,\n            $53691bda533d12d0$var$zle,\n            function() {\n                return [\n                    $53691bda533d12d0$var$astrm,\n                    $53691bda533d12d0$export$ae157b6234afe138,\n                    $53691bda533d12d0$export$4187ccf2467013b9\n                ];\n            }\n        ], this, $53691bda533d12d0$var$AsyncCmpStrm.call(this, opts, cb), function(ev) {\n            var strm = new $53691bda533d12d0$export$4187ccf2467013b9(ev.data);\n            onmessage = $53691bda533d12d0$var$astrm(strm);\n        }, 10);\n    }\n    return AsyncZlib;\n}();\nfunction $53691bda533d12d0$export$925212de7058410b(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return $53691bda533d12d0$var$cbify(data, opts, [\n        $53691bda533d12d0$var$bDflt,\n        $53691bda533d12d0$var$zle,\n        function() {\n            return [\n                $53691bda533d12d0$export$f87121a6d50aff25\n            ];\n        }\n    ], function(ev) {\n        return $53691bda533d12d0$var$pbf($53691bda533d12d0$export$f87121a6d50aff25(ev.data[0], ev.data[1]));\n    }, 4, cb);\n}\nfunction $53691bda533d12d0$export$f87121a6d50aff25(data, opts) {\n    if (!opts) opts = {};\n    var a = $53691bda533d12d0$var$adler();\n    a.p(data);\n    var d = $53691bda533d12d0$var$dopt(data, opts, 2, 4);\n    return $53691bda533d12d0$var$zlh(d, opts), $53691bda533d12d0$var$wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */ var $53691bda533d12d0$export$af2424f875ff1b17 = /*#__PURE__*/ function() {\n    /**\n     * Creates a Zlib decompression stream\n     * @param cb The callback to call whenever data is inflated\n     */ function Unzlib(cb) {\n        this.v = 1;\n        $53691bda533d12d0$export$d1de70a877d6e43c.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Unzlib.prototype.push = function(chunk, final) {\n        $53691bda533d12d0$export$d1de70a877d6e43c.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 2 && !final) return;\n            this.p = this.p.subarray(2), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4) throw \"invalid zlib stream\";\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        $53691bda533d12d0$export$d1de70a877d6e43c.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}();\n/**\n * Asynchronous streaming Zlib decompression\n */ var $53691bda533d12d0$export$cf6668790220dcad = /*#__PURE__*/ function() {\n    /**\n     * Creates an asynchronous Zlib decompression stream\n     * @param cb The callback to call whenever data is deflated\n     */ function AsyncUnzlib(cb) {\n        this.ondata = cb;\n        $53691bda533d12d0$var$astrmify([\n            $53691bda533d12d0$var$bInflt,\n            $53691bda533d12d0$var$zule,\n            function() {\n                return [\n                    $53691bda533d12d0$var$astrm,\n                    $53691bda533d12d0$export$d1de70a877d6e43c,\n                    $53691bda533d12d0$export$af2424f875ff1b17\n                ];\n            }\n        ], this, 0, function() {\n            var strm = new $53691bda533d12d0$export$af2424f875ff1b17();\n            onmessage = $53691bda533d12d0$var$astrm(strm);\n        }, 11);\n    }\n    return AsyncUnzlib;\n}();\nfunction $53691bda533d12d0$export$ca7cbb494e731274(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return $53691bda533d12d0$var$cbify(data, opts, [\n        $53691bda533d12d0$var$bInflt,\n        $53691bda533d12d0$var$zule,\n        function() {\n            return [\n                $53691bda533d12d0$export$9ec8134f0f1b9fc6\n            ];\n        }\n    ], function(ev) {\n        return $53691bda533d12d0$var$pbf($53691bda533d12d0$export$9ec8134f0f1b9fc6(ev.data[0], $53691bda533d12d0$var$gu8(ev.data[1])));\n    }, 5, cb);\n}\nfunction $53691bda533d12d0$export$9ec8134f0f1b9fc6(data, out) {\n    return $53691bda533d12d0$var$inflt(($53691bda533d12d0$var$zlv(data), data.subarray(2, -4)), out);\n}\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */ var $53691bda533d12d0$export$578fe199ef655b76 = /*#__PURE__*/ function() {\n    /**\n     * Creates a decompression stream\n     * @param cb The callback to call whenever data is decompressed\n     */ function Decompress(cb) {\n        this.G = $53691bda533d12d0$export$4cb607de6db70415;\n        this.I = $53691bda533d12d0$export$d1de70a877d6e43c;\n        this.Z = $53691bda533d12d0$export$af2424f875ff1b17;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Decompress.prototype.push = function(chunk, final) {\n        if (!this.ondata) throw \"no stream handler\";\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new $53691bda533d12d0$var$u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            } else this.p = chunk;\n            if (this.p.length > 2) {\n                var _this_1 = this;\n                var cb = function() {\n                    _this_1.ondata.apply(_this_1, arguments);\n                };\n                this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(cb) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(cb) : new this.Z(cb);\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        } else this.s.push(chunk, final);\n    };\n    return Decompress;\n}();\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */ var $53691bda533d12d0$export$ae2c1d81988d4b43 = /*#__PURE__*/ function() {\n    /**\n   * Creates an asynchronous decompression stream\n   * @param cb The callback to call whenever data is decompressed\n   */ function AsyncDecompress(cb) {\n        this.G = $53691bda533d12d0$export$d5adcdd968132151;\n        this.I = $53691bda533d12d0$export$fff8358d6dbaa9cc;\n        this.Z = $53691bda533d12d0$export$cf6668790220dcad;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ AsyncDecompress.prototype.push = function(chunk, final) {\n        $53691bda533d12d0$export$578fe199ef655b76.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}();\nfunction $53691bda533d12d0$export$678d868aab8fb3c7(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return data[0] == 31 && data[1] == 139 && data[2] == 8 ? $53691bda533d12d0$export$b6df3e950734d697(data, opts, cb) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? $53691bda533d12d0$export$cae1ce83fe4a1782(data, opts, cb) : $53691bda533d12d0$export$ca7cbb494e731274(data, opts, cb);\n}\nfunction $53691bda533d12d0$export$c4bdbbbc9a4faabe(data, out) {\n    return data[0] == 31 && data[1] == 139 && data[2] == 8 ? $53691bda533d12d0$export$c80456f7aaba691c(data, out) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? $53691bda533d12d0$export$90366d8b308ba94a(data, out) : $53691bda533d12d0$export$9ec8134f0f1b9fc6(data, out);\n}\n// flatten a directory structure\nvar $53691bda533d12d0$var$fltn = function(d, p, t, o) {\n    for(var k in d){\n        var val = d[k], n = p + k;\n        if (val instanceof $53691bda533d12d0$var$u8) t[n] = [\n            val,\n            o\n        ];\n        else if (Array.isArray(val)) t[n] = [\n            val[0],\n            $53691bda533d12d0$var$mrg(o, val[1])\n        ];\n        else $53691bda533d12d0$var$fltn(val, n + \"/\", t, o);\n    }\n};\n// text encoder\nvar $53691bda533d12d0$var$te = typeof TextEncoder != \"undefined\" && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar $53691bda533d12d0$var$td = typeof TextDecoder != \"undefined\" && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar $53691bda533d12d0$var$tds = 0;\ntry {\n    $53691bda533d12d0$var$td.decode($53691bda533d12d0$var$et, {\n        stream: true\n    });\n    $53691bda533d12d0$var$tds = 1;\n} catch (e) {}\n// decode UTF8\nvar $53691bda533d12d0$var$dutf8 = function(d) {\n    for(var r = \"\", i = 0;;){\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length) return [\n            r,\n            $53691bda533d12d0$var$slc(d, i - 1)\n        ];\n        if (!eb) r += String.fromCharCode(c);\n        else if (eb == 3) c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | d[i++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);\n        else if (eb & 1) r += String.fromCharCode((c & 31) << 6 | d[i++] & 63);\n        else r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | d[i++] & 63);\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */ var $53691bda533d12d0$export$ba46860a31c72e94 = /*#__PURE__*/ function() {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */ function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if ($53691bda533d12d0$var$tds) this.t = new TextDecoder();\n        else this.p = $53691bda533d12d0$var$et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ DecodeUTF8.prototype.push = function(chunk, final) {\n        if (!this.ondata) throw \"no callback\";\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, {\n                stream: true\n            }), final);\n            if (final) {\n                if (this.t.decode().length) throw \"invalid utf-8 data\";\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p) throw \"stream finished\";\n        var dat = new $53691bda533d12d0$var$u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = $53691bda533d12d0$var$dutf8(dat), ch = _a[0], np = _a[1];\n        if (final) {\n            if (np.length) throw \"invalid utf-8 data\";\n            this.p = null;\n        } else this.p = np;\n        this.ondata(ch, final);\n    };\n    return DecodeUTF8;\n}();\n/**\n * Streaming UTF-8 encoding\n */ var $53691bda533d12d0$export$283f13d12b1b210e = /*#__PURE__*/ function() {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */ function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */ EncodeUTF8.prototype.push = function(chunk, final) {\n        if (!this.ondata) throw \"no callback\";\n        if (this.d) throw \"stream finished\";\n        this.ondata($53691bda533d12d0$export$366b39a6daa8ed7a(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}();\nfunction $53691bda533d12d0$export$366b39a6daa8ed7a(str, latin1) {\n    if (latin1) {\n        var ar_1 = new $53691bda533d12d0$var$u8(str.length);\n        for(var i = 0; i < str.length; ++i)ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if ($53691bda533d12d0$var$te) return $53691bda533d12d0$var$te.encode(str);\n    var l = str.length;\n    var ar = new $53691bda533d12d0$var$u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function(v) {\n        ar[ai++] = v;\n    };\n    for(var i = 0; i < l; ++i){\n        if (ai + 5 > ar.length) {\n            var n = new $53691bda533d12d0$var$u8(ai + 8 + (l - i << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1) w(c);\n        else if (c < 2048) w(192 | c >> 6), w(128 | c & 63);\n        else if (c > 55295 && c < 57344) c = 65536 + (c & 1047552) | str.charCodeAt(++i) & 1023, w(240 | c >> 18), w(128 | c >> 12 & 63), w(128 | c >> 6 & 63), w(128 | c & 63);\n        else w(224 | c >> 12), w(128 | c >> 6 & 63), w(128 | c & 63);\n    }\n    return $53691bda533d12d0$var$slc(ar, 0, ai);\n}\nfunction $53691bda533d12d0$export$adb211f8cb999894(dat, latin1) {\n    if (latin1) {\n        var r = \"\";\n        for(var i = 0; i < dat.length; i += 16384)r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    } else if ($53691bda533d12d0$var$td) return $53691bda533d12d0$var$td.decode(dat);\n    else {\n        var _a = $53691bda533d12d0$var$dutf8(dat), out = _a[0], ext = _a[1];\n        if (ext.length) throw \"invalid utf-8 data\";\n        return out;\n    }\n}\n// deflate bit flag\nvar $53691bda533d12d0$var$dbf = function(l) {\n    return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0;\n};\n// skip local zip header\nvar $53691bda533d12d0$var$slzh = function(d, b) {\n    return b + 30 + $53691bda533d12d0$var$b2(d, b + 26) + $53691bda533d12d0$var$b2(d, b + 28);\n};\n// read zip header\nvar $53691bda533d12d0$var$zh = function(d, b, z) {\n    var fnl = $53691bda533d12d0$var$b2(d, b + 28), fn = $53691bda533d12d0$export$adb211f8cb999894(d.subarray(b + 46, b + 46 + fnl), !($53691bda533d12d0$var$b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = $53691bda533d12d0$var$b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? $53691bda533d12d0$var$z64e(d, es) : [\n        bs,\n        $53691bda533d12d0$var$b4(d, b + 24),\n        $53691bda533d12d0$var$b4(d, b + 42)\n    ], sc = _a[0], su = _a[1], off = _a[2];\n    return [\n        $53691bda533d12d0$var$b2(d, b + 10),\n        sc,\n        su,\n        fn,\n        es + $53691bda533d12d0$var$b2(d, b + 30) + $53691bda533d12d0$var$b2(d, b + 32),\n        off\n    ];\n};\n// read zip64 extra field\nvar $53691bda533d12d0$var$z64e = function(d, b) {\n    for(; $53691bda533d12d0$var$b2(d, b) != 1; b += 4 + $53691bda533d12d0$var$b2(d, b + 2));\n    return [\n        $53691bda533d12d0$var$b8(d, b + 12),\n        $53691bda533d12d0$var$b8(d, b + 4),\n        $53691bda533d12d0$var$b8(d, b + 20)\n    ];\n};\n// extra field length\nvar $53691bda533d12d0$var$exfl = function(ex) {\n    var le = 0;\n    if (ex) for(var k in ex){\n        var l = ex[k].length;\n        if (l > 65535) throw \"extra field too long\";\n        le += l + 4;\n    }\n    return le;\n};\n// write zip header\nvar $53691bda533d12d0$var$wzh = function(d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = $53691bda533d12d0$var$exfl(ex);\n    $53691bda533d12d0$var$wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null) d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = f.flag << 1 | (c == null && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119) throw \"date not in range 1980-2099\";\n    $53691bda533d12d0$var$wbytes(d, b, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >>> 1), b += 4;\n    if (c != null) {\n        $53691bda533d12d0$var$wbytes(d, b, f.crc);\n        $53691bda533d12d0$var$wbytes(d, b + 4, c);\n        $53691bda533d12d0$var$wbytes(d, b + 8, f.size);\n    }\n    $53691bda533d12d0$var$wbytes(d, b + 12, fl);\n    $53691bda533d12d0$var$wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        $53691bda533d12d0$var$wbytes(d, b, col);\n        $53691bda533d12d0$var$wbytes(d, b + 6, f.attrs);\n        $53691bda533d12d0$var$wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) for(var k in ex){\n        var exf = ex[k], l = exf.length;\n        $53691bda533d12d0$var$wbytes(d, b, +k);\n        $53691bda533d12d0$var$wbytes(d, b + 2, l);\n        d.set(exf, b + 4), b += 4 + l;\n    }\n    if (col) d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar $53691bda533d12d0$var$wzf = function(o, b, c, d, e) {\n    $53691bda533d12d0$var$wbytes(o, b, 0x6054B50); // skip disk\n    $53691bda533d12d0$var$wbytes(o, b + 8, c);\n    $53691bda533d12d0$var$wbytes(o, b + 10, c);\n    $53691bda533d12d0$var$wbytes(o, b + 12, d);\n    $53691bda533d12d0$var$wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */ var $53691bda533d12d0$export$2b25194e1767ea06 = /*#__PURE__*/ function() {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */ function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = $53691bda533d12d0$var$crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */ ZipPassThrough.prototype.process = function(chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ ZipPassThrough.prototype.push = function(chunk, final) {\n        if (!this.ondata) throw \"no callback - add to ZIP archive before pushing\";\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final) this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}();\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */ var $53691bda533d12d0$export$f7e481ca646388b6 = /*#__PURE__*/ function() {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */ function ZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts) opts = {};\n        $53691bda533d12d0$export$2b25194e1767ea06.call(this, filename);\n        this.d = new $53691bda533d12d0$export$ae157b6234afe138(opts, function(dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = $53691bda533d12d0$var$dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function(chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        } catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ ZipDeflate.prototype.push = function(chunk, final) {\n        $53691bda533d12d0$export$2b25194e1767ea06.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}();\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */ var $53691bda533d12d0$export$ffb5e59e179924b2 = /*#__PURE__*/ function() {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */ function AsyncZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts) opts = {};\n        $53691bda533d12d0$export$2b25194e1767ea06.call(this, filename);\n        this.d = new $53691bda533d12d0$export$84e526fabcba03e3(opts, function(err, dat, final) {\n            _this_1.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = $53691bda533d12d0$var$dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function(chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ AsyncZipDeflate.prototype.push = function(chunk, final) {\n        $53691bda533d12d0$export$2b25194e1767ea06.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}();\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */ var $53691bda533d12d0$export$9a4d4a7c32a75d2f = /*#__PURE__*/ function() {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */ function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */ Zip.prototype.add = function(file) {\n        var _this_1 = this;\n        if (this.d & 2) throw \"stream finished\";\n        var f = $53691bda533d12d0$export$366b39a6daa8ed7a(file.filename), fl = f.length;\n        var com = file.comment, o = com && $53691bda533d12d0$export$366b39a6daa8ed7a(com);\n        var u = fl != file.filename.length || o && com.length != o.length;\n        var hl = fl + $53691bda533d12d0$var$exfl(file.extra) + 30;\n        if (fl > 65535) throw \"filename too long\";\n        var header = new $53691bda533d12d0$var$u8(hl);\n        $53691bda533d12d0$var$wzh(header, 0, file, f, u);\n        var chks = [\n            header\n        ];\n        var pAll = function() {\n            for(var _i = 0, chks_1 = chks; _i < chks_1.length; _i++){\n                var chk = chks_1[_i];\n                _this_1.ondata(null, chk, false);\n            }\n            chks = [];\n        };\n        var tr = this.d;\n        this.d = 0;\n        var ind = this.u.length;\n        var uf = $53691bda533d12d0$var$mrg(file, {\n            f: f,\n            u: u,\n            o: o,\n            t: function() {\n                if (file.terminate) file.terminate();\n            },\n            r: function() {\n                pAll();\n                if (tr) {\n                    var nxt = _this_1.u[ind + 1];\n                    if (nxt) nxt.r();\n                    else _this_1.d = 1;\n                }\n                tr = 1;\n            }\n        });\n        var cl = 0;\n        file.ondata = function(err, dat, final) {\n            if (err) {\n                _this_1.ondata(err, dat, final);\n                _this_1.terminate();\n            } else {\n                cl += dat.length;\n                chks.push(dat);\n                if (final) {\n                    var dd = new $53691bda533d12d0$var$u8(16);\n                    $53691bda533d12d0$var$wbytes(dd, 0, 0x8074B50);\n                    $53691bda533d12d0$var$wbytes(dd, 4, file.crc);\n                    $53691bda533d12d0$var$wbytes(dd, 8, cl);\n                    $53691bda533d12d0$var$wbytes(dd, 12, file.size);\n                    chks.push(dd);\n                    uf.c = cl, uf.b = hl + cl + 16, uf.crc = file.crc, uf.size = file.size;\n                    if (tr) uf.r();\n                    tr = 1;\n                } else if (tr) pAll();\n            }\n        };\n        this.u.push(uf);\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */ Zip.prototype.end = function() {\n        var _this_1 = this;\n        if (this.d & 2) {\n            if (this.d & 1) throw \"stream finishing\";\n            throw \"stream finished\";\n        }\n        if (this.d) this.e();\n        else this.u.push({\n            r: function() {\n                if (!(_this_1.d & 1)) return;\n                _this_1.u.splice(-1, 1);\n                _this_1.e();\n            },\n            t: function() {}\n        });\n        this.d = 3;\n    };\n    Zip.prototype.e = function() {\n        var bt = 0, l = 0, tl = 0;\n        for(var _i = 0, _a = this.u; _i < _a.length; _i++){\n            var f = _a[_i];\n            tl += 46 + f.f.length + $53691bda533d12d0$var$exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new $53691bda533d12d0$var$u8(tl + 22);\n        for(var _b = 0, _c = this.u; _b < _c.length; _b++){\n            var f = _c[_b];\n            $53691bda533d12d0$var$wzh(out, bt, f, f.f, f.u, f.c, l, f.o);\n            bt += 46 + f.f.length + $53691bda533d12d0$var$exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        $53691bda533d12d0$var$wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */ Zip.prototype.terminate = function() {\n        for(var _i = 0, _a = this.u; _i < _a.length; _i++){\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}();\nfunction $53691bda533d12d0$export$8901015135f2fb22(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    var r = {};\n    $53691bda533d12d0$var$fltn(data, \"\", r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function() {\n        for(var i = 0; i < term.length; ++i)term[i]();\n    };\n    var cbf = function() {\n        var out = new $53691bda533d12d0$var$u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for(var i = 0; i < slft; ++i){\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                $53691bda533d12d0$var$wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + $53691bda533d12d0$var$exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                $53691bda533d12d0$var$wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            } catch (e) {\n                return cb(e, null);\n            }\n        }\n        $53691bda533d12d0$var$wzf(out, o, files.length, cdl, oe);\n        cb(null, out);\n    };\n    if (!lft) cbf();\n    var _loop_1 = function(i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = $53691bda533d12d0$var$crc(), size = file.length;\n        c.p(file);\n        var f = $53691bda533d12d0$export$366b39a6daa8ed7a(fn), s = f.length;\n        var com = p.comment, m = com && $53691bda533d12d0$export$366b39a6daa8ed7a(com), ms = m && m.length;\n        var exl = $53691bda533d12d0$var$exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function(e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            } else {\n                var l = d.length;\n                files[i] = $53691bda533d12d0$var$mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || m && com.length != ms,\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft) cbf();\n            }\n        };\n        if (s > 65535) cbl(\"filename too long\", null);\n        if (!compression) cbl(null, file);\n        else if (size < 160000) try {\n            cbl(null, $53691bda533d12d0$export$21533ff51b8a0b4a(file, p));\n        } catch (e) {\n            cbl(e, null);\n        }\n        else term.push($53691bda533d12d0$export$2316623ecd1285ab(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for(var i = 0; i < slft; ++i)_loop_1(i);\n    return tAll;\n}\nfunction $53691bda533d12d0$export$eb1654f146d54eb3(data, opts) {\n    if (!opts) opts = {};\n    var r = {};\n    var files = [];\n    $53691bda533d12d0$var$fltn(data, \"\", r, opts);\n    var o = 0;\n    var tot = 0;\n    for(var fn in r){\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = $53691bda533d12d0$export$366b39a6daa8ed7a(fn), s = f.length;\n        var com = p.comment, m = com && $53691bda533d12d0$export$366b39a6daa8ed7a(com), ms = m && m.length;\n        var exl = $53691bda533d12d0$var$exfl(p.extra);\n        if (s > 65535) throw \"filename too long\";\n        var d = compression ? $53691bda533d12d0$export$21533ff51b8a0b4a(file, p) : file, l = d.length;\n        var c = $53691bda533d12d0$var$crc();\n        c.p(file);\n        files.push($53691bda533d12d0$var$mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || m && com.length != ms,\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new $53691bda533d12d0$var$u8(tot + 22), oe = o, cdl = tot - o;\n    for(var i = 0; i < files.length; ++i){\n        var f = files[i];\n        $53691bda533d12d0$var$wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + $53691bda533d12d0$var$exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        $53691bda533d12d0$var$wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    $53691bda533d12d0$var$wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Streaming pass-through decompression for ZIP archives\n */ var $53691bda533d12d0$export$93f81d5bbbb7c6bf = /*#__PURE__*/ function() {\n    function UnzipPassThrough() {}\n    UnzipPassThrough.prototype.push = function(data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}();\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */ var $53691bda533d12d0$export$eb188945cc39e642 = /*#__PURE__*/ function() {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */ function UnzipInflate() {\n        var _this_1 = this;\n        this.i = new $53691bda533d12d0$export$d1de70a877d6e43c(function(dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function(data, final) {\n        try {\n            this.i.push(data, final);\n        } catch (e) {\n            this.ondata(e, data, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}();\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */ var $53691bda533d12d0$export$6235d84645dad4f9 = /*#__PURE__*/ function() {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */ function AsyncUnzipInflate(_, sz) {\n        var _this_1 = this;\n        if (sz < 320000) this.i = new $53691bda533d12d0$export$d1de70a877d6e43c(function(dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n        else {\n            this.i = new $53691bda533d12d0$export$fff8358d6dbaa9cc(function(err, dat, final) {\n                _this_1.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function(data, final) {\n        if (this.i.terminate) data = $53691bda533d12d0$var$slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}();\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */ var $53691bda533d12d0$export$9b7485f84cbaaa56 = /*#__PURE__*/ function() {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */ function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: $53691bda533d12d0$export$93f81d5bbbb7c6bf\n        };\n        this.p = $53691bda533d12d0$var$et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Unzip.prototype.push = function(chunk, final) {\n        var _this_1 = this;\n        if (!this.onfile) throw \"no callback\";\n        if (!this.p) throw \"stream finished\";\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d) this.d.push(toAdd, !this.c);\n            else this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length) return this.push(chunk, final);\n        } else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length) buf = chunk;\n            else if (!chunk.length) buf = this.p;\n            else {\n                buf = new $53691bda533d12d0$var$u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function() {\n                var _a;\n                var sig = $53691bda533d12d0$var$b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = $53691bda533d12d0$var$b2(buf, i + 6), cmp_1 = $53691bda533d12d0$var$b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = $53691bda533d12d0$var$b2(buf, i + 26), es = $53691bda533d12d0$var$b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_2 = [];\n                        this_1.k.unshift(chks_2);\n                        f = 2;\n                        var sc_1 = $53691bda533d12d0$var$b4(buf, i + 18), su_1 = $53691bda533d12d0$var$b4(buf, i + 22);\n                        var fn_1 = $53691bda533d12d0$export$adb211f8cb999894(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) _a = dd ? [\n                            -2\n                        ] : $53691bda533d12d0$var$z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        else if (dd) sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function() {\n                                if (!file_1.ondata) throw \"no callback\";\n                                if (!sc_1) file_1.ondata(null, $53691bda533d12d0$var$et, true);\n                                else {\n                                    var ctr = _this_1.o[cmp_1];\n                                    if (!ctr) throw \"unknown compression type \" + cmp_1;\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function(err, dat, final) {\n                                        file_1.ondata(err, dat, final);\n                                    };\n                                    for(var _i = 0, chks_3 = chks_2; _i < chks_3.length; _i++){\n                                        var dat = chks_3[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this_1.k[0] == chks_2 && _this_1.c) _this_1.d = d_1;\n                                    else d_1.push($53691bda533d12d0$var$et, true);\n                                }\n                            },\n                            terminate: function() {\n                                if (d_1 && d_1.terminate) d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0) file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                } else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    } else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for(; i < l - 4; ++i){\n                var state_1 = _loop_2();\n                if (state_1 === \"break\") break;\n            }\n            this.p = $53691bda533d12d0$var$et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - ($53691bda533d12d0$var$b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add) add.push(dat, !!f);\n                else this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2) return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c) throw \"invalid zip file\";\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */ Unzip.prototype.register = function(decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}();\nfunction $53691bda533d12d0$export$23c8d3f8757cab88(data, cb) {\n    if (typeof cb != \"function\") throw \"no callback\";\n    var term = [];\n    var tAll = function() {\n        for(var i = 0; i < term.length; ++i)term[i]();\n    };\n    var files = {};\n    var e = data.length - 22;\n    for(; $53691bda533d12d0$var$b4(data, e) != 0x6054B50; --e)if (!e || data.length - e > 65558) {\n        cb(\"invalid zip file\", null);\n        return;\n    }\n    var lft = $53691bda533d12d0$var$b2(data, e + 8);\n    if (!lft) cb(null, {});\n    var c = lft;\n    var o = $53691bda533d12d0$var$b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = $53691bda533d12d0$var$b4(data, e - 12);\n        if ($53691bda533d12d0$var$b4(data, e) != 0x6064B50) {\n            cb(\"invalid zip file\", null);\n            return;\n        }\n        c = lft = $53691bda533d12d0$var$b4(data, e + 32);\n        o = $53691bda533d12d0$var$b4(data, e + 48);\n    }\n    var _loop_3 = function(i) {\n        var _a = $53691bda533d12d0$var$zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = $53691bda533d12d0$var$slzh(data, off);\n        o = no;\n        var cbl = function(e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            } else {\n                files[fn] = d;\n                if (!--lft) cb(null, files);\n            }\n        };\n        if (!c_1) cbl(null, $53691bda533d12d0$var$slc(data, b, b + sc));\n        else if (c_1 == 8) {\n            var infl = data.subarray(b, b + sc);\n            if (sc < 320000) try {\n                cbl(null, $53691bda533d12d0$export$90366d8b308ba94a(infl, new $53691bda533d12d0$var$u8(su)));\n            } catch (e) {\n                cbl(e, null);\n            }\n            else term.push($53691bda533d12d0$export$cae1ce83fe4a1782(infl, {\n                size: su\n            }, cbl));\n        } else cbl(\"unknown compression type \" + c_1, null);\n    };\n    for(var i = 0; i < c; ++i)_loop_3(i);\n    return tAll;\n}\nfunction $53691bda533d12d0$export$c757709326bb5901(data) {\n    var files = {};\n    var e = data.length - 22;\n    for(; $53691bda533d12d0$var$b4(data, e) != 0x6054B50; --e){\n        if (!e || data.length - e > 65558) throw \"invalid zip file\";\n    }\n    var c = $53691bda533d12d0$var$b2(data, e + 8);\n    if (!c) return {};\n    var o = $53691bda533d12d0$var$b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = $53691bda533d12d0$var$b4(data, e - 12);\n        if ($53691bda533d12d0$var$b4(data, e) != 0x6064B50) throw \"invalid zip file\";\n        c = $53691bda533d12d0$var$b4(data, e + 32);\n        o = $53691bda533d12d0$var$b4(data, e + 48);\n    }\n    for(var i = 0; i < c; ++i){\n        var _a = $53691bda533d12d0$var$zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = $53691bda533d12d0$var$slzh(data, off);\n        o = no;\n        if (!c_2) files[fn] = $53691bda533d12d0$var$slc(data, b, b + sc);\n        else if (c_2 == 8) files[fn] = $53691bda533d12d0$export$90366d8b308ba94a(data.subarray(b, b + sc), new $53691bda533d12d0$var$u8(su));\n        else throw \"unknown compression type \" + c_2;\n    }\n    return files;\n}\n\n});\n\nparcelRegister(\"cLt9Z\", function(module, exports) {\n\n$parcel$export(module.exports, \"NURBSCurve\", () => $94b07e67f83726ad$export$12efb26d7429b049);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $5joV2 = parcelRequire(\"5joV2\");\n/**\n * NURBS curve object\n *\n * Derives from Curve, overriding getPoint and getTangent.\n *\n * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.\n *\n **/ class $94b07e67f83726ad$export$12efb26d7429b049 extends (0, $ilwiq.Curve) {\n    constructor(degree, knots /* array of reals */ , controlPoints /* array of Vector(2|3|4) */ , startKnot /* index in knots */ , endKnot /* index in knots */ ){\n        super();\n        this.degree = degree;\n        this.knots = knots;\n        this.controlPoints = [];\n        // Used by periodic NURBS to remove hidden spans\n        this.startKnot = startKnot || 0;\n        this.endKnot = endKnot || this.knots.length - 1;\n        for(let i = 0; i < controlPoints.length; ++i){\n            // ensure Vector4 for control points\n            const point = controlPoints[i];\n            this.controlPoints[i] = new (0, $ilwiq.Vector4)(point.x, point.y, point.z, point.w);\n        }\n    }\n    getPoint(t, optionalTarget = new (0, $ilwiq.Vector3)()) {\n        const point = optionalTarget;\n        const u = this.knots[this.startKnot] + t * (this.knots[this.endKnot] - this.knots[this.startKnot]); // linear mapping t->u\n        // following results in (wx, wy, wz, w) homogeneous point\n        const hpoint = $5joV2.calcBSplinePoint(this.degree, this.knots, this.controlPoints, u);\n        if (hpoint.w !== 1.0) // project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)\n        hpoint.divideScalar(hpoint.w);\n        return point.set(hpoint.x, hpoint.y, hpoint.z);\n    }\n    getTangent(t, optionalTarget = new (0, $ilwiq.Vector3)()) {\n        const tangent = optionalTarget;\n        const u = this.knots[0] + t * (this.knots[this.knots.length - 1] - this.knots[0]);\n        const ders = $5joV2.calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, u, 1);\n        tangent.copy(ders[1]).normalize();\n        return tangent;\n    }\n}\n\n});\nparcelRegister(\"5joV2\", function(module, exports) {\n\n$parcel$export(module.exports, \"calcBSplinePoint\", () => $3de20e7c02944e1d$export$3672a5d5ca534534);\n$parcel$export(module.exports, \"calcNURBSDerivatives\", () => $3de20e7c02944e1d$export$692f68f163c8f6b);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n/**\n * NURBS utils\n *\n * See NURBSCurve and NURBSSurface.\n **/ /**************************************************************\n *\tNURBS Utils\n **************************************************************/ /*\nFinds knot vector span.\n\np : degree\nu : parametric value\nU : knot vector\n\nreturns the span\n*/ function $3de20e7c02944e1d$export$5d44f085c0641ab4(p, u, U) {\n    const n = U.length - p - 1;\n    if (u >= U[n]) return n - 1;\n    if (u <= U[p]) return p;\n    let low = p;\n    let high = n;\n    let mid = Math.floor((low + high) / 2);\n    while(u < U[mid] || u >= U[mid + 1]){\n        if (u < U[mid]) high = mid;\n        else low = mid;\n        mid = Math.floor((low + high) / 2);\n    }\n    return mid;\n}\n/*\nCalculate basis functions. See The NURBS Book, page 70, algorithm A2.2\n\nspan : span in which u lies\nu    : parametric point\np    : degree\nU    : knot vector\n\nreturns array[p+1] with basis functions values.\n*/ function $3de20e7c02944e1d$export$bbebd61f407f7f41(span, u, p, U) {\n    const N = [];\n    const left = [];\n    const right = [];\n    N[0] = 1.0;\n    for(let j = 1; j <= p; ++j){\n        left[j] = u - U[span + 1 - j];\n        right[j] = U[span + j] - u;\n        let saved = 0.0;\n        for(let r = 0; r < j; ++r){\n            const rv = right[r + 1];\n            const lv = left[j - r];\n            const temp = N[r] / (rv + lv);\n            N[r] = saved + rv * temp;\n            saved = lv * temp;\n        }\n        N[j] = saved;\n    }\n    return N;\n}\n/*\nCalculate B-Spline curve points. See The NURBS Book, page 82, algorithm A3.1.\n\np : degree of B-Spline\nU : knot vector\nP : control points (x, y, z, w)\nu : parametric point\n\nreturns point for given u\n*/ function $3de20e7c02944e1d$export$3672a5d5ca534534(p, U, P, u) {\n    const span = $3de20e7c02944e1d$export$5d44f085c0641ab4(p, u, U);\n    const N = $3de20e7c02944e1d$export$bbebd61f407f7f41(span, u, p, U);\n    const C = new (0, $ilwiq.Vector4)(0, 0, 0, 0);\n    for(let j = 0; j <= p; ++j){\n        const point = P[span - p + j];\n        const Nj = N[j];\n        const wNj = point.w * Nj;\n        C.x += point.x * wNj;\n        C.y += point.y * wNj;\n        C.z += point.z * wNj;\n        C.w += point.w * Nj;\n    }\n    return C;\n}\n/*\nCalculate basis functions derivatives. See The NURBS Book, page 72, algorithm A2.3.\n\nspan : span in which u lies\nu    : parametric point\np    : degree\nn    : number of derivatives to calculate\nU    : knot vector\n\nreturns array[n+1][p+1] with basis functions derivatives\n*/ function $3de20e7c02944e1d$export$70bfab2ede47286(span, u, p, n, U) {\n    const zeroArr = [];\n    for(let i = 0; i <= p; ++i)zeroArr[i] = 0.0;\n    const ders = [];\n    for(let i = 0; i <= n; ++i)ders[i] = zeroArr.slice(0);\n    const ndu = [];\n    for(let i = 0; i <= p; ++i)ndu[i] = zeroArr.slice(0);\n    ndu[0][0] = 1.0;\n    const left = zeroArr.slice(0);\n    const right = zeroArr.slice(0);\n    for(let j = 1; j <= p; ++j){\n        left[j] = u - U[span + 1 - j];\n        right[j] = U[span + j] - u;\n        let saved = 0.0;\n        for(let r = 0; r < j; ++r){\n            const rv = right[r + 1];\n            const lv = left[j - r];\n            ndu[j][r] = rv + lv;\n            const temp = ndu[r][j - 1] / ndu[j][r];\n            ndu[r][j] = saved + rv * temp;\n            saved = lv * temp;\n        }\n        ndu[j][j] = saved;\n    }\n    for(let j = 0; j <= p; ++j)ders[0][j] = ndu[j][p];\n    for(let r = 0; r <= p; ++r){\n        let s1 = 0;\n        let s2 = 1;\n        const a = [];\n        for(let i = 0; i <= p; ++i)a[i] = zeroArr.slice(0);\n        a[0][0] = 1.0;\n        for(let k = 1; k <= n; ++k){\n            let d = 0.0;\n            const rk = r - k;\n            const pk = p - k;\n            if (r >= k) {\n                a[s2][0] = a[s1][0] / ndu[pk + 1][rk];\n                d = a[s2][0] * ndu[rk][pk];\n            }\n            const j1 = rk >= -1 ? 1 : -rk;\n            const j2 = r - 1 <= pk ? k - 1 : p - r;\n            for(let j = j1; j <= j2; ++j){\n                a[s2][j] = (a[s1][j] - a[s1][j - 1]) / ndu[pk + 1][rk + j];\n                d += a[s2][j] * ndu[rk + j][pk];\n            }\n            if (r <= pk) {\n                a[s2][k] = -a[s1][k - 1] / ndu[pk + 1][r];\n                d += a[s2][k] * ndu[r][pk];\n            }\n            ders[k][r] = d;\n            const j = s1;\n            s1 = s2;\n            s2 = j;\n        }\n    }\n    let r = p;\n    for(let k = 1; k <= n; ++k){\n        for(let j = 0; j <= p; ++j)ders[k][j] *= r;\n        r *= p - k;\n    }\n    return ders;\n}\n/*\n\tCalculate derivatives of a B-Spline. See The NURBS Book, page 93, algorithm A3.2.\n\n\tp  : degree\n\tU  : knot vector\n\tP  : control points\n\tu  : Parametric points\n\tnd : number of derivatives\n\n\treturns array[d+1] with derivatives\n\t*/ function $3de20e7c02944e1d$export$ae5bff7435823e13(p, U, P, u, nd) {\n    const du = nd < p ? nd : p;\n    const CK = [];\n    const span = $3de20e7c02944e1d$export$5d44f085c0641ab4(p, u, U);\n    const nders = $3de20e7c02944e1d$export$70bfab2ede47286(span, u, p, du, U);\n    const Pw = [];\n    for(let i = 0; i < P.length; ++i){\n        const point = P[i].clone();\n        const w = point.w;\n        point.x *= w;\n        point.y *= w;\n        point.z *= w;\n        Pw[i] = point;\n    }\n    for(let k = 0; k <= du; ++k){\n        const point = Pw[span - p].clone().multiplyScalar(nders[k][0]);\n        for(let j = 1; j <= p; ++j)point.add(Pw[span - p + j].clone().multiplyScalar(nders[k][j]));\n        CK[k] = point;\n    }\n    for(let k = du + 1; k <= nd + 1; ++k)CK[k] = new (0, $ilwiq.Vector4)(0, 0, 0);\n    return CK;\n}\n/*\nCalculate \"K over I\"\n\nreturns k!/(i!(k-i)!)\n*/ function $3de20e7c02944e1d$export$3c88b91ac9312187(k, i) {\n    let nom = 1;\n    for(let j = 2; j <= k; ++j)nom *= j;\n    let denom = 1;\n    for(let j = 2; j <= i; ++j)denom *= j;\n    for(let j = 2; j <= k - i; ++j)denom *= j;\n    return nom / denom;\n}\n/*\nCalculate derivatives (0-nd) of rational curve. See The NURBS Book, page 127, algorithm A4.2.\n\nPders : result of function calcBSplineDerivatives\n\nreturns array with derivatives for rational curve.\n*/ function $3de20e7c02944e1d$export$66805edec2c1a55d(Pders) {\n    const nd = Pders.length;\n    const Aders = [];\n    const wders = [];\n    for(let i = 0; i < nd; ++i){\n        const point = Pders[i];\n        Aders[i] = new (0, $ilwiq.Vector3)(point.x, point.y, point.z);\n        wders[i] = point.w;\n    }\n    const CK = [];\n    for(let k = 0; k < nd; ++k){\n        const v = Aders[k].clone();\n        for(let i = 1; i <= k; ++i)v.sub(CK[k - i].clone().multiplyScalar($3de20e7c02944e1d$export$3c88b91ac9312187(k, i) * wders[i]));\n        CK[k] = v.divideScalar(wders[0]);\n    }\n    return CK;\n}\n/*\nCalculate NURBS curve derivatives. See The NURBS Book, page 127, algorithm A4.2.\n\np  : degree\nU  : knot vector\nP  : control points in homogeneous space\nu  : parametric points\nnd : number of derivatives\n\nreturns array with derivatives.\n*/ function $3de20e7c02944e1d$export$692f68f163c8f6b(p, U, P, u, nd) {\n    const Pders = $3de20e7c02944e1d$export$ae5bff7435823e13(p, U, P, u, nd);\n    return $3de20e7c02944e1d$export$66805edec2c1a55d(Pders);\n}\n/*\nCalculate rational B-Spline surface point. See The NURBS Book, page 134, algorithm A4.3.\n\np1, p2 : degrees of B-Spline surface\nU1, U2 : knot vectors\nP      : control points (x, y, z, w)\nu, v   : parametric values\n\nreturns point for given (u, v)\n*/ function $3de20e7c02944e1d$export$6574b03464941be7(p, q, U, V, P, u, v, target) {\n    const uspan = $3de20e7c02944e1d$export$5d44f085c0641ab4(p, u, U);\n    const vspan = $3de20e7c02944e1d$export$5d44f085c0641ab4(q, v, V);\n    const Nu = $3de20e7c02944e1d$export$bbebd61f407f7f41(uspan, u, p, U);\n    const Nv = $3de20e7c02944e1d$export$bbebd61f407f7f41(vspan, v, q, V);\n    const temp = [];\n    for(let l = 0; l <= q; ++l){\n        temp[l] = new (0, $ilwiq.Vector4)(0, 0, 0, 0);\n        for(let k = 0; k <= p; ++k){\n            const point = P[uspan - p + k][vspan - q + l].clone();\n            const w = point.w;\n            point.x *= w;\n            point.y *= w;\n            point.z *= w;\n            temp[l].add(point.multiplyScalar(Nu[k]));\n        }\n    }\n    const Sw = new (0, $ilwiq.Vector4)(0, 0, 0, 0);\n    for(let l = 0; l <= q; ++l)Sw.add(temp[l].multiplyScalar(Nv[l]));\n    Sw.divideScalar(Sw.w);\n    target.set(Sw.x, Sw.y, Sw.z);\n}\n\n});\n\n\n\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $qgTqt = parcelRequire(\"qgTqt\");\nconst $3d6a91fea9ae46ce$var$clock = new $ilwiq.Clock();\nconst $3d6a91fea9ae46ce$var$main_canvas = document.getElementById(\"second-canvas\");\nconst $3d6a91fea9ae46ce$var$n = 1;\nlet $3d6a91fea9ae46ce$var$cwidth = 640 / $3d6a91fea9ae46ce$var$n;\nlet $3d6a91fea9ae46ce$var$cheight = 640 / $3d6a91fea9ae46ce$var$n;\n$3d6a91fea9ae46ce$var$main_canvas.setAttribute(\"width\", $3d6a91fea9ae46ce$var$cwidth + \"px\");\n$3d6a91fea9ae46ce$var$main_canvas.setAttribute(\"height\", $3d6a91fea9ae46ce$var$cheight + \"px\");\nconst $3d6a91fea9ae46ce$var$scene = new $ilwiq.Scene();\nconst $3d6a91fea9ae46ce$var$camera = new $ilwiq.PerspectiveCamera(75, $3d6a91fea9ae46ce$var$main_canvas.clientWidth / $3d6a91fea9ae46ce$var$main_canvas.clientHeight, 0.1, 1000);\nconst $3d6a91fea9ae46ce$var$renderer = new $ilwiq.WebGLRenderer({\n    antialias: true,\n    canvas: $3d6a91fea9ae46ce$var$main_canvas\n});\n$3d6a91fea9ae46ce$var$camera.position.set(0, 5.5, 2.5);\n$3d6a91fea9ae46ce$var$camera.rotateY(0.2);\nvar $3d6a91fea9ae46ce$var$light = new $ilwiq.DirectionalLight(\"white\", 0.5);\n$3d6a91fea9ae46ce$var$light.position.set(1, 1, 1);\n$3d6a91fea9ae46ce$var$scene.add($3d6a91fea9ae46ce$var$light);\nvar $3d6a91fea9ae46ce$var$ambient = new $ilwiq.AmbientLight(\"white\", 0.5);\n$3d6a91fea9ae46ce$var$scene.add($3d6a91fea9ae46ce$var$ambient);\n$3d6a91fea9ae46ce$var$scene.background = new $ilwiq.Color(0x72809e); // dark\nlet $3d6a91fea9ae46ce$var$mixer;\nlet $3d6a91fea9ae46ce$var$head;\nconst $3d6a91fea9ae46ce$var$model = new Promise((res, rej)=>{\n    const loader = new (0, $qgTqt.FBXLoader)();\n    loader.load(\"./assets/low_poly_man.fbx\", (fbx)=>{\n        fbx.scale.setScalar(0.01);\n        fbx.traverse((c)=>{\n            c.castShadow = true;\n        });\n        $3d6a91fea9ae46ce$var$head = fbx.getObjectByName(\"mixamorigHead\");\n        res(fbx);\n    });\n});\nconst $3d6a91fea9ae46ce$var$animation1 = new Promise((res, rej)=>{\n    const loader = new (0, $qgTqt.FBXLoader)();\n    loader.load(\"./assets/Waving.fbx\", (fbx)=>{\n        res(fbx);\n    });\n});\nconst $3d6a91fea9ae46ce$var$animation2 = new Promise((res, rej)=>{\n    const loader = new (0, $qgTqt.FBXLoader)();\n    loader.load(\"./assets/Arm Stretching.fbx\", (fbx)=>{\n        res(fbx);\n    });\n});\nconst $3d6a91fea9ae46ce$var$combo = Promise.all([\n    $3d6a91fea9ae46ce$var$model,\n    $3d6a91fea9ae46ce$var$animation1,\n    $3d6a91fea9ae46ce$var$animation2\n]);\n$3d6a91fea9ae46ce$var$combo.then((object)=>{\n    $3d6a91fea9ae46ce$var$scene.add(object[0]);\n    $3d6a91fea9ae46ce$var$mixer = new $ilwiq.AnimationMixer(object[0]);\n    object[0].animations = object[1].animation;\n    const action1 = $3d6a91fea9ae46ce$var$mixer.clipAction(object[1].animations[0]);\n    action1._clip.name = \"waving\";\n    const action2 = $3d6a91fea9ae46ce$var$mixer.clipAction(object[2].animations[0]);\n    action2._clip.name = \"armstretching\";\n    action1.play();\n    // action1.loop = THREE.LoopOnce;\n    action2.loop = $ilwiq.LoopOnce;\n    let wave_counter = 0;\n    $3d6a91fea9ae46ce$var$mixer.addEventListener(\"finished\", function(e) {\n        if (e.action._clip.name == \"waving\" && wave_counter < 5) {\n            wave_counter++;\n            action1.reset();\n            action1.play();\n            if (wave_counter == 4) {\n                wave_counter = 0;\n                action1.stop();\n                action2.play();\n            }\n        } else if (e.action._clip.name == \"armstretching\") {\n            action2.stop();\n            action1.play();\n        }\n    });\n});\nconst $3d6a91fea9ae46ce$var$target = new $ilwiq.Object3D();\nconst $3d6a91fea9ae46ce$var$mousePosition = new $ilwiq.Vector2();\n$3d6a91fea9ae46ce$var$target.position.set(0.2, 5.2, 2); // good initial target position\nfunction $3d6a91fea9ae46ce$var$animate() {\n    const delta = $3d6a91fea9ae46ce$var$clock.getDelta();\n    if ($3d6a91fea9ae46ce$var$mixer) $3d6a91fea9ae46ce$var$mixer.update(delta);\n    if ($3d6a91fea9ae46ce$var$head) $3d6a91fea9ae46ce$var$head.lookAt($3d6a91fea9ae46ce$var$target.position);\n    requestAnimationFrame($3d6a91fea9ae46ce$var$animate);\n    $3d6a91fea9ae46ce$var$renderer.render($3d6a91fea9ae46ce$var$scene, $3d6a91fea9ae46ce$var$camera);\n}\n$3d6a91fea9ae46ce$var$animate();\nlet $3d6a91fea9ae46ce$var$mobile = false;\nif (window.matchMedia(\"(any-hover: none)\").matches) $3d6a91fea9ae46ce$var$mobile = true;\nlet $3d6a91fea9ae46ce$var$lastKnownScrollPosition = 0;\nlet $3d6a91fea9ae46ce$var$ticking = false;\nif (!$3d6a91fea9ae46ce$var$mobile) window.addEventListener(\"mousemove\", (e)=>{\n    $3d6a91fea9ae46ce$var$mousePosition.x = 2 * (e.clientX / window.innerWidth * 2 - 1);\n    $3d6a91fea9ae46ce$var$mousePosition.y = -2 * (e.clientY / window.innerHeight) * 2 + 7;\n    $3d6a91fea9ae46ce$var$target.position.set($3d6a91fea9ae46ce$var$mousePosition.x, $3d6a91fea9ae46ce$var$mousePosition.y, 2);\n});\nelse document.addEventListener(\"scroll\", (event)=>{\n    $3d6a91fea9ae46ce$var$lastKnownScrollPosition = window.scrollY;\n    if (!$3d6a91fea9ae46ce$var$ticking) {\n        window.requestAnimationFrame(()=>{\n            $3d6a91fea9ae46ce$var$doSomething($3d6a91fea9ae46ce$var$lastKnownScrollPosition);\n            $3d6a91fea9ae46ce$var$ticking = false;\n        });\n        $3d6a91fea9ae46ce$var$ticking = true;\n    }\n});\nfunction $3d6a91fea9ae46ce$var$doSomething(scrollPos) {\n    // Do something with the scroll position\n    $3d6a91fea9ae46ce$var$target.position.set(0.2, 5.2 * (1 - scrollPos / 1000), 2);\n}\n\n\n//# sourceMappingURL=index.e6f06ddd.js.map\n","import {\n\tAmbientLight,\n\tAnimationClip,\n\tBone,\n\tBufferGeometry,\n\tClampToEdgeWrapping,\n\tColor,\n\tDirectionalLight,\n\tEquirectangularReflectionMapping,\n\tEuler,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tGroup,\n\tLine,\n\tLineBasicMaterial,\n\tLoader,\n\tLoaderUtils,\n\tMathUtils,\n\tMatrix3,\n\tMatrix4,\n\tMesh,\n\tMeshLambertMaterial,\n\tMeshPhongMaterial,\n\tNumberKeyframeTrack,\n\tObject3D,\n\tOrthographicCamera,\n\tPerspectiveCamera,\n\tPointLight,\n\tPropertyBinding,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tRepeatWrapping,\n\tSkeleton,\n\tSkinnedMesh,\n\tSpotLight,\n\tTexture,\n\tTextureLoader,\n\tUint16BufferAttribute,\n\tVector3,\n\tVector4,\n\tVectorKeyframeTrack,\n\tsRGBEncoding\n} from 'three';\nimport * as fflate from '../libs/fflate.module.js';\nimport { NURBSCurve } from '../curves/NURBSCurve.js';\n\n/**\n * Loader loads FBX file and generates Group representing FBX scene.\n * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format\n * Versions lower than this may load but will probably have errors\n *\n * Needs Support:\n *  Morph normals / blend shape normals\n *\n * FBX format references:\n * \thttps://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)\n *\n * Binary format specification:\n *\thttps://code.blender.org/2013/08/fbx-binary-file-format-specification/\n */\n\n\nlet fbxTree;\nlet connections;\nlet sceneGraph;\n\nclass FBXLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( scope.path === '' ) ? LoaderUtils.extractUrlBase( url ) : scope.path;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( buffer, path ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( FBXBuffer, path ) {\n\n\t\tif ( isFbxFormatBinary( FBXBuffer ) ) {\n\n\t\t\tfbxTree = new BinaryParser().parse( FBXBuffer );\n\n\t\t} else {\n\n\t\t\tconst FBXText = convertArrayBufferToString( FBXBuffer );\n\n\t\t\tif ( ! isFbxFormatASCII( FBXText ) ) {\n\n\t\t\t\tthrow new Error( 'THREE.FBXLoader: Unknown format.' );\n\n\t\t\t}\n\n\t\t\tif ( getFbxVersion( FBXText ) < 7000 ) {\n\n\t\t\t\tthrow new Error( 'THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion( FBXText ) );\n\n\t\t\t}\n\n\t\t\tfbxTree = new TextParser().parse( FBXText );\n\n\t\t}\n\n\t\t// console.log( fbxTree );\n\n\t\tconst textureLoader = new TextureLoader( this.manager ).setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\treturn new FBXTreeParser( textureLoader, this.manager ).parse( fbxTree );\n\n\t}\n\n}\n\n// Parse the FBXTree object returned by the BinaryParser or TextParser and return a Group\nclass FBXTreeParser {\n\n\tconstructor( textureLoader, manager ) {\n\n\t\tthis.textureLoader = textureLoader;\n\t\tthis.manager = manager;\n\n\t}\n\n\tparse() {\n\n\t\tconnections = this.parseConnections();\n\n\t\tconst images = this.parseImages();\n\t\tconst textures = this.parseTextures( images );\n\t\tconst materials = this.parseMaterials( textures );\n\t\tconst deformers = this.parseDeformers();\n\t\tconst geometryMap = new GeometryParser().parse( deformers );\n\n\t\tthis.parseScene( deformers, geometryMap, materials );\n\n\t\treturn sceneGraph;\n\n\t}\n\n\t// Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )\n\t// and details the connection type\n\tparseConnections() {\n\n\t\tconst connectionMap = new Map();\n\n\t\tif ( 'Connections' in fbxTree ) {\n\n\t\t\tconst rawConnections = fbxTree.Connections.connections;\n\n\t\t\trawConnections.forEach( function ( rawConnection ) {\n\n\t\t\t\tconst fromID = rawConnection[ 0 ];\n\t\t\t\tconst toID = rawConnection[ 1 ];\n\t\t\t\tconst relationship = rawConnection[ 2 ];\n\n\t\t\t\tif ( ! connectionMap.has( fromID ) ) {\n\n\t\t\t\t\tconnectionMap.set( fromID, {\n\t\t\t\t\t\tparents: [],\n\t\t\t\t\t\tchildren: []\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tconst parentRelationship = { ID: toID, relationship: relationship };\n\t\t\t\tconnectionMap.get( fromID ).parents.push( parentRelationship );\n\n\t\t\t\tif ( ! connectionMap.has( toID ) ) {\n\n\t\t\t\t\tconnectionMap.set( toID, {\n\t\t\t\t\t\tparents: [],\n\t\t\t\t\t\tchildren: []\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tconst childRelationship = { ID: fromID, relationship: relationship };\n\t\t\t\tconnectionMap.get( toID ).children.push( childRelationship );\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn connectionMap;\n\n\t}\n\n\t// Parse FBXTree.Objects.Video for embedded image data\n\t// These images are connected to textures in FBXTree.Objects.Textures\n\t// via FBXTree.Connections.\n\tparseImages() {\n\n\t\tconst images = {};\n\t\tconst blobs = {};\n\n\t\tif ( 'Video' in fbxTree.Objects ) {\n\n\t\t\tconst videoNodes = fbxTree.Objects.Video;\n\n\t\t\tfor ( const nodeID in videoNodes ) {\n\n\t\t\t\tconst videoNode = videoNodes[ nodeID ];\n\n\t\t\t\tconst id = parseInt( nodeID );\n\n\t\t\t\timages[ id ] = videoNode.RelativeFilename || videoNode.Filename;\n\n\t\t\t\t// raw image data is in videoNode.Content\n\t\t\t\tif ( 'Content' in videoNode ) {\n\n\t\t\t\t\tconst arrayBufferContent = ( videoNode.Content instanceof ArrayBuffer ) && ( videoNode.Content.byteLength > 0 );\n\t\t\t\t\tconst base64Content = ( typeof videoNode.Content === 'string' ) && ( videoNode.Content !== '' );\n\n\t\t\t\t\tif ( arrayBufferContent || base64Content ) {\n\n\t\t\t\t\t\tconst image = this.parseImage( videoNodes[ nodeID ] );\n\n\t\t\t\t\t\tblobs[ videoNode.RelativeFilename || videoNode.Filename ] = image;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( const id in images ) {\n\n\t\t\tconst filename = images[ id ];\n\n\t\t\tif ( blobs[ filename ] !== undefined ) images[ id ] = blobs[ filename ];\n\t\t\telse images[ id ] = images[ id ].split( '\\\\' ).pop();\n\n\t\t}\n\n\t\treturn images;\n\n\t}\n\n\t// Parse embedded image data in FBXTree.Video.Content\n\tparseImage( videoNode ) {\n\n\t\tconst content = videoNode.Content;\n\t\tconst fileName = videoNode.RelativeFilename || videoNode.Filename;\n\t\tconst extension = fileName.slice( fileName.lastIndexOf( '.' ) + 1 ).toLowerCase();\n\n\t\tlet type;\n\n\t\tswitch ( extension ) {\n\n\t\t\tcase 'bmp':\n\n\t\t\t\ttype = 'image/bmp';\n\t\t\t\tbreak;\n\n\t\t\tcase 'jpg':\n\t\t\tcase 'jpeg':\n\n\t\t\t\ttype = 'image/jpeg';\n\t\t\t\tbreak;\n\n\t\t\tcase 'png':\n\n\t\t\t\ttype = 'image/png';\n\t\t\t\tbreak;\n\n\t\t\tcase 'tif':\n\n\t\t\t\ttype = 'image/tiff';\n\t\t\t\tbreak;\n\n\t\t\tcase 'tga':\n\n\t\t\t\tif ( this.manager.getHandler( '.tga' ) === null ) {\n\n\t\t\t\t\tconsole.warn( 'FBXLoader: TGA loader not found, skipping ', fileName );\n\n\t\t\t\t}\n\n\t\t\t\ttype = 'image/tga';\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tconsole.warn( 'FBXLoader: Image type \"' + extension + '\" is not supported.' );\n\t\t\t\treturn;\n\n\t\t}\n\n\t\tif ( typeof content === 'string' ) { // ASCII format\n\n\t\t\treturn 'data:' + type + ';base64,' + content;\n\n\t\t} else { // Binary Format\n\n\t\t\tconst array = new Uint8Array( content );\n\t\t\treturn window.URL.createObjectURL( new Blob( [ array ], { type: type } ) );\n\n\t\t}\n\n\t}\n\n\t// Parse nodes in FBXTree.Objects.Texture\n\t// These contain details such as UV scaling, cropping, rotation etc and are connected\n\t// to images in FBXTree.Objects.Video\n\tparseTextures( images ) {\n\n\t\tconst textureMap = new Map();\n\n\t\tif ( 'Texture' in fbxTree.Objects ) {\n\n\t\t\tconst textureNodes = fbxTree.Objects.Texture;\n\t\t\tfor ( const nodeID in textureNodes ) {\n\n\t\t\t\tconst texture = this.parseTexture( textureNodes[ nodeID ], images );\n\t\t\t\ttextureMap.set( parseInt( nodeID ), texture );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn textureMap;\n\n\t}\n\n\t// Parse individual node in FBXTree.Objects.Texture\n\tparseTexture( textureNode, images ) {\n\n\t\tconst texture = this.loadTexture( textureNode, images );\n\n\t\ttexture.ID = textureNode.id;\n\n\t\ttexture.name = textureNode.attrName;\n\n\t\tconst wrapModeU = textureNode.WrapModeU;\n\t\tconst wrapModeV = textureNode.WrapModeV;\n\n\t\tconst valueU = wrapModeU !== undefined ? wrapModeU.value : 0;\n\t\tconst valueV = wrapModeV !== undefined ? wrapModeV.value : 0;\n\n\t\t// http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a\n\t\t// 0: repeat(default), 1: clamp\n\n\t\ttexture.wrapS = valueU === 0 ? RepeatWrapping : ClampToEdgeWrapping;\n\t\ttexture.wrapT = valueV === 0 ? RepeatWrapping : ClampToEdgeWrapping;\n\n\t\tif ( 'Scaling' in textureNode ) {\n\n\t\t\tconst values = textureNode.Scaling.value;\n\n\t\t\ttexture.repeat.x = values[ 0 ];\n\t\t\ttexture.repeat.y = values[ 1 ];\n\n\t\t}\n\n\t\tif ( 'Translation' in textureNode ) {\n\n\t\t\tconst values = textureNode.Translation.value;\n\n\t\t\ttexture.offset.x = values[ 0 ];\n\t\t\ttexture.offset.y = values[ 1 ];\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\t// load a texture specified as a blob or data URI, or via an external URL using TextureLoader\n\tloadTexture( textureNode, images ) {\n\n\t\tlet fileName;\n\n\t\tconst currentPath = this.textureLoader.path;\n\n\t\tconst children = connections.get( textureNode.id ).children;\n\n\t\tif ( children !== undefined && children.length > 0 && images[ children[ 0 ].ID ] !== undefined ) {\n\n\t\t\tfileName = images[ children[ 0 ].ID ];\n\n\t\t\tif ( fileName.indexOf( 'blob:' ) === 0 || fileName.indexOf( 'data:' ) === 0 ) {\n\n\t\t\t\tthis.textureLoader.setPath( undefined );\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet texture;\n\n\t\tconst extension = textureNode.FileName.slice( - 3 ).toLowerCase();\n\n\t\tif ( extension === 'tga' ) {\n\n\t\t\tconst loader = this.manager.getHandler( '.tga' );\n\n\t\t\tif ( loader === null ) {\n\n\t\t\t\tconsole.warn( 'FBXLoader: TGA loader not found, creating placeholder texture for', textureNode.RelativeFilename );\n\t\t\t\ttexture = new Texture();\n\n\t\t\t} else {\n\n\t\t\t\tloader.setPath( this.textureLoader.path );\n\t\t\t\ttexture = loader.load( fileName );\n\n\t\t\t}\n\n\t\t} else if ( extension === 'psd' ) {\n\n\t\t\tconsole.warn( 'FBXLoader: PSD textures are not supported, creating placeholder texture for', textureNode.RelativeFilename );\n\t\t\ttexture = new Texture();\n\n\t\t} else {\n\n\t\t\ttexture = this.textureLoader.load( fileName );\n\n\t\t}\n\n\t\tthis.textureLoader.setPath( currentPath );\n\n\t\treturn texture;\n\n\t}\n\n\t// Parse nodes in FBXTree.Objects.Material\n\tparseMaterials( textureMap ) {\n\n\t\tconst materialMap = new Map();\n\n\t\tif ( 'Material' in fbxTree.Objects ) {\n\n\t\t\tconst materialNodes = fbxTree.Objects.Material;\n\n\t\t\tfor ( const nodeID in materialNodes ) {\n\n\t\t\t\tconst material = this.parseMaterial( materialNodes[ nodeID ], textureMap );\n\n\t\t\t\tif ( material !== null ) materialMap.set( parseInt( nodeID ), material );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materialMap;\n\n\t}\n\n\t// Parse single node in FBXTree.Objects.Material\n\t// Materials are connected to texture maps in FBXTree.Objects.Textures\n\t// FBX format currently only supports Lambert and Phong shading models\n\tparseMaterial( materialNode, textureMap ) {\n\n\t\tconst ID = materialNode.id;\n\t\tconst name = materialNode.attrName;\n\t\tlet type = materialNode.ShadingModel;\n\n\t\t// Case where FBX wraps shading model in property object.\n\t\tif ( typeof type === 'object' ) {\n\n\t\t\ttype = type.value;\n\n\t\t}\n\n\t\t// Ignore unused materials which don't have any connections.\n\t\tif ( ! connections.has( ID ) ) return null;\n\n\t\tconst parameters = this.parseParameters( materialNode, textureMap, ID );\n\n\t\tlet material;\n\n\t\tswitch ( type.toLowerCase() ) {\n\n\t\t\tcase 'phong':\n\t\t\t\tmaterial = new MeshPhongMaterial();\n\t\t\t\tbreak;\n\t\t\tcase 'lambert':\n\t\t\t\tmaterial = new MeshLambertMaterial();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tconsole.warn( 'THREE.FBXLoader: unknown material type \"%s\". Defaulting to MeshPhongMaterial.', type );\n\t\t\t\tmaterial = new MeshPhongMaterial();\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tmaterial.setValues( parameters );\n\t\tmaterial.name = name;\n\n\t\treturn material;\n\n\t}\n\n\t// Parse FBX material and return parameters suitable for a three.js material\n\t// Also parse the texture map and return any textures associated with the material\n\tparseParameters( materialNode, textureMap, ID ) {\n\n\t\tconst parameters = {};\n\n\t\tif ( materialNode.BumpFactor ) {\n\n\t\t\tparameters.bumpScale = materialNode.BumpFactor.value;\n\n\t\t}\n\n\t\tif ( materialNode.Diffuse ) {\n\n\t\t\tparameters.color = new Color().fromArray( materialNode.Diffuse.value ).convertSRGBToLinear();\n\n\t\t} else if ( materialNode.DiffuseColor && ( materialNode.DiffuseColor.type === 'Color' || materialNode.DiffuseColor.type === 'ColorRGB' ) ) {\n\n\t\t\t// The blender exporter exports diffuse here instead of in materialNode.Diffuse\n\t\t\tparameters.color = new Color().fromArray( materialNode.DiffuseColor.value ).convertSRGBToLinear();\n\n\t\t}\n\n\t\tif ( materialNode.DisplacementFactor ) {\n\n\t\t\tparameters.displacementScale = materialNode.DisplacementFactor.value;\n\n\t\t}\n\n\t\tif ( materialNode.Emissive ) {\n\n\t\t\tparameters.emissive = new Color().fromArray( materialNode.Emissive.value ).convertSRGBToLinear();\n\n\t\t} else if ( materialNode.EmissiveColor && ( materialNode.EmissiveColor.type === 'Color' || materialNode.EmissiveColor.type === 'ColorRGB' ) ) {\n\n\t\t\t// The blender exporter exports emissive color here instead of in materialNode.Emissive\n\t\t\tparameters.emissive = new Color().fromArray( materialNode.EmissiveColor.value ).convertSRGBToLinear();\n\n\t\t}\n\n\t\tif ( materialNode.EmissiveFactor ) {\n\n\t\t\tparameters.emissiveIntensity = parseFloat( materialNode.EmissiveFactor.value );\n\n\t\t}\n\n\t\tif ( materialNode.Opacity ) {\n\n\t\t\tparameters.opacity = parseFloat( materialNode.Opacity.value );\n\n\t\t}\n\n\t\tif ( parameters.opacity < 1.0 ) {\n\n\t\t\tparameters.transparent = true;\n\n\t\t}\n\n\t\tif ( materialNode.ReflectionFactor ) {\n\n\t\t\tparameters.reflectivity = materialNode.ReflectionFactor.value;\n\n\t\t}\n\n\t\tif ( materialNode.Shininess ) {\n\n\t\t\tparameters.shininess = materialNode.Shininess.value;\n\n\t\t}\n\n\t\tif ( materialNode.Specular ) {\n\n\t\t\tparameters.specular = new Color().fromArray( materialNode.Specular.value ).convertSRGBToLinear();\n\n\t\t} else if ( materialNode.SpecularColor && materialNode.SpecularColor.type === 'Color' ) {\n\n\t\t\t// The blender exporter exports specular color here instead of in materialNode.Specular\n\t\t\tparameters.specular = new Color().fromArray( materialNode.SpecularColor.value ).convertSRGBToLinear();\n\n\t\t}\n\n\t\tconst scope = this;\n\t\tconnections.get( ID ).children.forEach( function ( child ) {\n\n\t\t\tconst type = child.relationship;\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'Bump':\n\t\t\t\t\tparameters.bumpMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Maya|TEX_ao_map':\n\t\t\t\t\tparameters.aoMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DiffuseColor':\n\t\t\t\tcase 'Maya|TEX_color_map':\n\t\t\t\t\tparameters.map = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\tif ( parameters.map !== undefined ) {\n\n\t\t\t\t\t\tparameters.map.encoding = sRGBEncoding;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DisplacementColor':\n\t\t\t\t\tparameters.displacementMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'EmissiveColor':\n\t\t\t\t\tparameters.emissiveMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\tif ( parameters.emissiveMap !== undefined ) {\n\n\t\t\t\t\t\tparameters.emissiveMap.encoding = sRGBEncoding;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'NormalMap':\n\t\t\t\tcase 'Maya|TEX_normal_map':\n\t\t\t\t\tparameters.normalMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ReflectionColor':\n\t\t\t\t\tparameters.envMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\tif ( parameters.envMap !== undefined ) {\n\n\t\t\t\t\t\tparameters.envMap.mapping = EquirectangularReflectionMapping;\n\t\t\t\t\t\tparameters.envMap.encoding = sRGBEncoding;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpecularColor':\n\t\t\t\t\tparameters.specularMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\tif ( parameters.specularMap !== undefined ) {\n\n\t\t\t\t\t\tparameters.specularMap.encoding = sRGBEncoding;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'TransparentColor':\n\t\t\t\tcase 'TransparencyFactor':\n\t\t\t\t\tparameters.alphaMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\tparameters.transparent = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'AmbientColor':\n\t\t\t\tcase 'ShininessExponent': // AKA glossiness map\n\t\t\t\tcase 'SpecularFactor': // AKA specularLevel\n\t\t\t\tcase 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn parameters;\n\n\t}\n\n\t// get a texture from the textureMap for use by a material.\n\tgetTexture( textureMap, id ) {\n\n\t\t// if the texture is a layered texture, just use the first layer and issue a warning\n\t\tif ( 'LayeredTexture' in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture ) {\n\n\t\t\tconsole.warn( 'THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.' );\n\t\t\tid = connections.get( id ).children[ 0 ].ID;\n\n\t\t}\n\n\t\treturn textureMap.get( id );\n\n\t}\n\n\t// Parse nodes in FBXTree.Objects.Deformer\n\t// Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here\n\t// Generates map of Skeleton-like objects for use later when generating and binding skeletons.\n\tparseDeformers() {\n\n\t\tconst skeletons = {};\n\t\tconst morphTargets = {};\n\n\t\tif ( 'Deformer' in fbxTree.Objects ) {\n\n\t\t\tconst DeformerNodes = fbxTree.Objects.Deformer;\n\n\t\t\tfor ( const nodeID in DeformerNodes ) {\n\n\t\t\t\tconst deformerNode = DeformerNodes[ nodeID ];\n\n\t\t\t\tconst relationships = connections.get( parseInt( nodeID ) );\n\n\t\t\t\tif ( deformerNode.attrType === 'Skin' ) {\n\n\t\t\t\t\tconst skeleton = this.parseSkeleton( relationships, DeformerNodes );\n\t\t\t\t\tskeleton.ID = nodeID;\n\n\t\t\t\t\tif ( relationships.parents.length > 1 ) console.warn( 'THREE.FBXLoader: skeleton attached to more than one geometry is not supported.' );\n\t\t\t\t\tskeleton.geometryID = relationships.parents[ 0 ].ID;\n\n\t\t\t\t\tskeletons[ nodeID ] = skeleton;\n\n\t\t\t\t} else if ( deformerNode.attrType === 'BlendShape' ) {\n\n\t\t\t\t\tconst morphTarget = {\n\t\t\t\t\t\tid: nodeID,\n\t\t\t\t\t};\n\n\t\t\t\t\tmorphTarget.rawTargets = this.parseMorphTargets( relationships, DeformerNodes );\n\t\t\t\t\tmorphTarget.id = nodeID;\n\n\t\t\t\t\tif ( relationships.parents.length > 1 ) console.warn( 'THREE.FBXLoader: morph target attached to more than one geometry is not supported.' );\n\n\t\t\t\t\tmorphTargets[ nodeID ] = morphTarget;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tskeletons: skeletons,\n\t\t\tmorphTargets: morphTargets,\n\n\t\t};\n\n\t}\n\n\t// Parse single nodes in FBXTree.Objects.Deformer\n\t// The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'\n\t// Each skin node represents a skeleton and each cluster node represents a bone\n\tparseSkeleton( relationships, deformerNodes ) {\n\n\t\tconst rawBones = [];\n\n\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\tconst boneNode = deformerNodes[ child.ID ];\n\n\t\t\tif ( boneNode.attrType !== 'Cluster' ) return;\n\n\t\t\tconst rawBone = {\n\n\t\t\t\tID: child.ID,\n\t\t\t\tindices: [],\n\t\t\t\tweights: [],\n\t\t\t\ttransformLink: new Matrix4().fromArray( boneNode.TransformLink.a ),\n\t\t\t\t// transform: new Matrix4().fromArray( boneNode.Transform.a ),\n\t\t\t\t// linkMode: boneNode.Mode,\n\n\t\t\t};\n\n\t\t\tif ( 'Indexes' in boneNode ) {\n\n\t\t\t\trawBone.indices = boneNode.Indexes.a;\n\t\t\t\trawBone.weights = boneNode.Weights.a;\n\n\t\t\t}\n\n\t\t\trawBones.push( rawBone );\n\n\t\t} );\n\n\t\treturn {\n\n\t\t\trawBones: rawBones,\n\t\t\tbones: []\n\n\t\t};\n\n\t}\n\n\t// The top level morph deformer node has type \"BlendShape\" and sub nodes have type \"BlendShapeChannel\"\n\tparseMorphTargets( relationships, deformerNodes ) {\n\n\t\tconst rawMorphTargets = [];\n\n\t\tfor ( let i = 0; i < relationships.children.length; i ++ ) {\n\n\t\t\tconst child = relationships.children[ i ];\n\n\t\t\tconst morphTargetNode = deformerNodes[ child.ID ];\n\n\t\t\tconst rawMorphTarget = {\n\n\t\t\t\tname: morphTargetNode.attrName,\n\t\t\t\tinitialWeight: morphTargetNode.DeformPercent,\n\t\t\t\tid: morphTargetNode.id,\n\t\t\t\tfullWeights: morphTargetNode.FullWeights.a\n\n\t\t\t};\n\n\t\t\tif ( morphTargetNode.attrType !== 'BlendShapeChannel' ) return;\n\n\t\t\trawMorphTarget.geoID = connections.get( parseInt( child.ID ) ).children.filter( function ( child ) {\n\n\t\t\t\treturn child.relationship === undefined;\n\n\t\t\t} )[ 0 ].ID;\n\n\t\t\trawMorphTargets.push( rawMorphTarget );\n\n\t\t}\n\n\t\treturn rawMorphTargets;\n\n\t}\n\n\t// create the main Group() to be returned by the loader\n\tparseScene( deformers, geometryMap, materialMap ) {\n\n\t\tsceneGraph = new Group();\n\n\t\tconst modelMap = this.parseModels( deformers.skeletons, geometryMap, materialMap );\n\n\t\tconst modelNodes = fbxTree.Objects.Model;\n\n\t\tconst scope = this;\n\t\tmodelMap.forEach( function ( model ) {\n\n\t\t\tconst modelNode = modelNodes[ model.ID ];\n\t\t\tscope.setLookAtProperties( model, modelNode );\n\n\t\t\tconst parentConnections = connections.get( model.ID ).parents;\n\n\t\t\tparentConnections.forEach( function ( connection ) {\n\n\t\t\t\tconst parent = modelMap.get( connection.ID );\n\t\t\t\tif ( parent !== undefined ) parent.add( model );\n\n\t\t\t} );\n\n\t\t\tif ( model.parent === null ) {\n\n\t\t\t\tsceneGraph.add( model );\n\n\t\t\t}\n\n\n\t\t} );\n\n\t\tthis.bindSkeleton( deformers.skeletons, geometryMap, modelMap );\n\n\t\tthis.createAmbientLight();\n\n\t\tsceneGraph.traverse( function ( node ) {\n\n\t\t\tif ( node.userData.transformData ) {\n\n\t\t\t\tif ( node.parent ) {\n\n\t\t\t\t\tnode.userData.transformData.parentMatrix = node.parent.matrix;\n\t\t\t\t\tnode.userData.transformData.parentMatrixWorld = node.parent.matrixWorld;\n\n\t\t\t\t}\n\n\t\t\t\tconst transform = generateTransform( node.userData.transformData );\n\n\t\t\t\tnode.applyMatrix4( transform );\n\t\t\t\tnode.updateWorldMatrix();\n\n\t\t\t}\n\n\t\t} );\n\n\t\tconst animations = new AnimationParser().parse();\n\n\t\t// if all the models where already combined in a single group, just return that\n\t\tif ( sceneGraph.children.length === 1 && sceneGraph.children[ 0 ].isGroup ) {\n\n\t\t\tsceneGraph.children[ 0 ].animations = animations;\n\t\t\tsceneGraph = sceneGraph.children[ 0 ];\n\n\t\t}\n\n\t\tsceneGraph.animations = animations;\n\n\t}\n\n\t// parse nodes in FBXTree.Objects.Model\n\tparseModels( skeletons, geometryMap, materialMap ) {\n\n\t\tconst modelMap = new Map();\n\t\tconst modelNodes = fbxTree.Objects.Model;\n\n\t\tfor ( const nodeID in modelNodes ) {\n\n\t\t\tconst id = parseInt( nodeID );\n\t\t\tconst node = modelNodes[ nodeID ];\n\t\t\tconst relationships = connections.get( id );\n\n\t\t\tlet model = this.buildSkeleton( relationships, skeletons, id, node.attrName );\n\n\t\t\tif ( ! model ) {\n\n\t\t\t\tswitch ( node.attrType ) {\n\n\t\t\t\t\tcase 'Camera':\n\t\t\t\t\t\tmodel = this.createCamera( relationships );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Light':\n\t\t\t\t\t\tmodel = this.createLight( relationships );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Mesh':\n\t\t\t\t\t\tmodel = this.createMesh( relationships, geometryMap, materialMap );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'NurbsCurve':\n\t\t\t\t\t\tmodel = this.createCurve( relationships, geometryMap );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'LimbNode':\n\t\t\t\t\tcase 'Root':\n\t\t\t\t\t\tmodel = new Bone();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Null':\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tmodel = new Group();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tmodel.name = node.attrName ? PropertyBinding.sanitizeNodeName( node.attrName ) : '';\n\n\t\t\t\tmodel.ID = id;\n\n\t\t\t}\n\n\t\t\tthis.getTransformData( model, node );\n\t\t\tmodelMap.set( id, model );\n\n\t\t}\n\n\t\treturn modelMap;\n\n\t}\n\n\tbuildSkeleton( relationships, skeletons, id, name ) {\n\n\t\tlet bone = null;\n\n\t\trelationships.parents.forEach( function ( parent ) {\n\n\t\t\tfor ( const ID in skeletons ) {\n\n\t\t\t\tconst skeleton = skeletons[ ID ];\n\n\t\t\t\tskeleton.rawBones.forEach( function ( rawBone, i ) {\n\n\t\t\t\t\tif ( rawBone.ID === parent.ID ) {\n\n\t\t\t\t\t\tconst subBone = bone;\n\t\t\t\t\t\tbone = new Bone();\n\n\t\t\t\t\t\tbone.matrixWorld.copy( rawBone.transformLink );\n\n\t\t\t\t\t\t// set name and id here - otherwise in cases where \"subBone\" is created it will not have a name / id\n\n\t\t\t\t\t\tbone.name = name ? PropertyBinding.sanitizeNodeName( name ) : '';\n\t\t\t\t\t\tbone.ID = id;\n\n\t\t\t\t\t\tskeleton.bones[ i ] = bone;\n\n\t\t\t\t\t\t// In cases where a bone is shared between multiple meshes\n\t\t\t\t\t\t// duplicate the bone here and and it as a child of the first bone\n\t\t\t\t\t\tif ( subBone !== null ) {\n\n\t\t\t\t\t\t\tbone.add( subBone );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn bone;\n\n\t}\n\n\t// create a PerspectiveCamera or OrthographicCamera\n\tcreateCamera( relationships ) {\n\n\t\tlet model;\n\t\tlet cameraAttribute;\n\n\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\tconst attr = fbxTree.Objects.NodeAttribute[ child.ID ];\n\n\t\t\tif ( attr !== undefined ) {\n\n\t\t\t\tcameraAttribute = attr;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( cameraAttribute === undefined ) {\n\n\t\t\tmodel = new Object3D();\n\n\t\t} else {\n\n\t\t\tlet type = 0;\n\t\t\tif ( cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1 ) {\n\n\t\t\t\ttype = 1;\n\n\t\t\t}\n\n\t\t\tlet nearClippingPlane = 1;\n\t\t\tif ( cameraAttribute.NearPlane !== undefined ) {\n\n\t\t\t\tnearClippingPlane = cameraAttribute.NearPlane.value / 1000;\n\n\t\t\t}\n\n\t\t\tlet farClippingPlane = 1000;\n\t\t\tif ( cameraAttribute.FarPlane !== undefined ) {\n\n\t\t\t\tfarClippingPlane = cameraAttribute.FarPlane.value / 1000;\n\n\t\t\t}\n\n\n\t\t\tlet width = window.innerWidth;\n\t\t\tlet height = window.innerHeight;\n\n\t\t\tif ( cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined ) {\n\n\t\t\t\twidth = cameraAttribute.AspectWidth.value;\n\t\t\t\theight = cameraAttribute.AspectHeight.value;\n\n\t\t\t}\n\n\t\t\tconst aspect = width / height;\n\n\t\t\tlet fov = 45;\n\t\t\tif ( cameraAttribute.FieldOfView !== undefined ) {\n\n\t\t\t\tfov = cameraAttribute.FieldOfView.value;\n\n\t\t\t}\n\n\t\t\tconst focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 0: // Perspective\n\t\t\t\t\tmodel = new PerspectiveCamera( fov, aspect, nearClippingPlane, farClippingPlane );\n\t\t\t\t\tif ( focalLength !== null ) model.setFocalLength( focalLength );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1: // Orthographic\n\t\t\t\t\tmodel = new OrthographicCamera( - width / 2, width / 2, height / 2, - height / 2, nearClippingPlane, farClippingPlane );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Unknown camera type ' + type + '.' );\n\t\t\t\t\tmodel = new Object3D();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn model;\n\n\t}\n\n\t// Create a DirectionalLight, PointLight or SpotLight\n\tcreateLight( relationships ) {\n\n\t\tlet model;\n\t\tlet lightAttribute;\n\n\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\tconst attr = fbxTree.Objects.NodeAttribute[ child.ID ];\n\n\t\t\tif ( attr !== undefined ) {\n\n\t\t\t\tlightAttribute = attr;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( lightAttribute === undefined ) {\n\n\t\t\tmodel = new Object3D();\n\n\t\t} else {\n\n\t\t\tlet type;\n\n\t\t\t// LightType can be undefined for Point lights\n\t\t\tif ( lightAttribute.LightType === undefined ) {\n\n\t\t\t\ttype = 0;\n\n\t\t\t} else {\n\n\t\t\t\ttype = lightAttribute.LightType.value;\n\n\t\t\t}\n\n\t\t\tlet color = 0xffffff;\n\n\t\t\tif ( lightAttribute.Color !== undefined ) {\n\n\t\t\t\tcolor = new Color().fromArray( lightAttribute.Color.value ).convertSRGBToLinear();\n\n\t\t\t}\n\n\t\t\tlet intensity = ( lightAttribute.Intensity === undefined ) ? 1 : lightAttribute.Intensity.value / 100;\n\n\t\t\t// light disabled\n\t\t\tif ( lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0 ) {\n\n\t\t\t\tintensity = 0;\n\n\t\t\t}\n\n\t\t\tlet distance = 0;\n\t\t\tif ( lightAttribute.FarAttenuationEnd !== undefined ) {\n\n\t\t\t\tif ( lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0 ) {\n\n\t\t\t\t\tdistance = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdistance = lightAttribute.FarAttenuationEnd.value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?\n\t\t\tconst decay = 1;\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 0: // Point\n\t\t\t\t\tmodel = new PointLight( color, intensity, distance, decay );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1: // Directional\n\t\t\t\t\tmodel = new DirectionalLight( color, intensity );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2: // Spot\n\t\t\t\t\tlet angle = Math.PI / 3;\n\n\t\t\t\t\tif ( lightAttribute.InnerAngle !== undefined ) {\n\n\t\t\t\t\t\tangle = MathUtils.degToRad( lightAttribute.InnerAngle.value );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet penumbra = 0;\n\t\t\t\t\tif ( lightAttribute.OuterAngle !== undefined ) {\n\n\t\t\t\t\t\t// TODO: this is not correct - FBX calculates outer and inner angle in degrees\n\t\t\t\t\t\t// with OuterAngle > InnerAngle && OuterAngle <= Math.PI\n\t\t\t\t\t\t// while three.js uses a penumbra between (0, 1) to attenuate the inner angle\n\t\t\t\t\t\tpenumbra = MathUtils.degToRad( lightAttribute.OuterAngle.value );\n\t\t\t\t\t\tpenumbra = Math.max( penumbra, 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmodel = new SpotLight( color, intensity, distance, angle, penumbra, decay );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a PointLight.' );\n\t\t\t\t\tmodel = new PointLight( color, intensity );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1 ) {\n\n\t\t\t\tmodel.castShadow = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn model;\n\n\t}\n\n\tcreateMesh( relationships, geometryMap, materialMap ) {\n\n\t\tlet model;\n\t\tlet geometry = null;\n\t\tlet material = null;\n\t\tconst materials = [];\n\n\t\t// get geometry and materials(s) from connections\n\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\tif ( geometryMap.has( child.ID ) ) {\n\n\t\t\t\tgeometry = geometryMap.get( child.ID );\n\n\t\t\t}\n\n\t\t\tif ( materialMap.has( child.ID ) ) {\n\n\t\t\t\tmaterials.push( materialMap.get( child.ID ) );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( materials.length > 1 ) {\n\n\t\t\tmaterial = materials;\n\n\t\t} else if ( materials.length > 0 ) {\n\n\t\t\tmaterial = materials[ 0 ];\n\n\t\t} else {\n\n\t\t\tmaterial = new MeshPhongMaterial( { color: 0xcccccc } );\n\t\t\tmaterials.push( material );\n\n\t\t}\n\n\t\tif ( 'color' in geometry.attributes ) {\n\n\t\t\tmaterials.forEach( function ( material ) {\n\n\t\t\t\tmaterial.vertexColors = true;\n\n\t\t\t} );\n\n\t\t}\n\n\t\tif ( geometry.FBX_Deformer ) {\n\n\t\t\tmodel = new SkinnedMesh( geometry, material );\n\t\t\tmodel.normalizeSkinWeights();\n\n\t\t} else {\n\n\t\t\tmodel = new Mesh( geometry, material );\n\n\t\t}\n\n\t\treturn model;\n\n\t}\n\n\tcreateCurve( relationships, geometryMap ) {\n\n\t\tconst geometry = relationships.children.reduce( function ( geo, child ) {\n\n\t\t\tif ( geometryMap.has( child.ID ) ) geo = geometryMap.get( child.ID );\n\n\t\t\treturn geo;\n\n\t\t}, null );\n\n\t\t// FBX does not list materials for Nurbs lines, so we'll just put our own in here.\n\t\tconst material = new LineBasicMaterial( { color: 0x3300ff, linewidth: 1 } );\n\t\treturn new Line( geometry, material );\n\n\t}\n\n\t// parse the model node for transform data\n\tgetTransformData( model, modelNode ) {\n\n\t\tconst transformData = {};\n\n\t\tif ( 'InheritType' in modelNode ) transformData.inheritType = parseInt( modelNode.InheritType.value );\n\n\t\tif ( 'RotationOrder' in modelNode ) transformData.eulerOrder = getEulerOrder( modelNode.RotationOrder.value );\n\t\telse transformData.eulerOrder = 'ZYX';\n\n\t\tif ( 'Lcl_Translation' in modelNode ) transformData.translation = modelNode.Lcl_Translation.value;\n\n\t\tif ( 'PreRotation' in modelNode ) transformData.preRotation = modelNode.PreRotation.value;\n\t\tif ( 'Lcl_Rotation' in modelNode ) transformData.rotation = modelNode.Lcl_Rotation.value;\n\t\tif ( 'PostRotation' in modelNode ) transformData.postRotation = modelNode.PostRotation.value;\n\n\t\tif ( 'Lcl_Scaling' in modelNode ) transformData.scale = modelNode.Lcl_Scaling.value;\n\n\t\tif ( 'ScalingOffset' in modelNode ) transformData.scalingOffset = modelNode.ScalingOffset.value;\n\t\tif ( 'ScalingPivot' in modelNode ) transformData.scalingPivot = modelNode.ScalingPivot.value;\n\n\t\tif ( 'RotationOffset' in modelNode ) transformData.rotationOffset = modelNode.RotationOffset.value;\n\t\tif ( 'RotationPivot' in modelNode ) transformData.rotationPivot = modelNode.RotationPivot.value;\n\n\t\tmodel.userData.transformData = transformData;\n\n\t}\n\n\tsetLookAtProperties( model, modelNode ) {\n\n\t\tif ( 'LookAtProperty' in modelNode ) {\n\n\t\t\tconst children = connections.get( model.ID ).children;\n\n\t\t\tchildren.forEach( function ( child ) {\n\n\t\t\t\tif ( child.relationship === 'LookAtProperty' ) {\n\n\t\t\t\t\tconst lookAtTarget = fbxTree.Objects.Model[ child.ID ];\n\n\t\t\t\t\tif ( 'Lcl_Translation' in lookAtTarget ) {\n\n\t\t\t\t\t\tconst pos = lookAtTarget.Lcl_Translation.value;\n\n\t\t\t\t\t\t// DirectionalLight, SpotLight\n\t\t\t\t\t\tif ( model.target !== undefined ) {\n\n\t\t\t\t\t\t\tmodel.target.position.fromArray( pos );\n\t\t\t\t\t\t\tsceneGraph.add( model.target );\n\n\t\t\t\t\t\t} else { // Cameras and other Object3Ds\n\n\t\t\t\t\t\t\tmodel.lookAt( new Vector3().fromArray( pos ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\tbindSkeleton( skeletons, geometryMap, modelMap ) {\n\n\t\tconst bindMatrices = this.parsePoseNodes();\n\n\t\tfor ( const ID in skeletons ) {\n\n\t\t\tconst skeleton = skeletons[ ID ];\n\n\t\t\tconst parents = connections.get( parseInt( skeleton.ID ) ).parents;\n\n\t\t\tparents.forEach( function ( parent ) {\n\n\t\t\t\tif ( geometryMap.has( parent.ID ) ) {\n\n\t\t\t\t\tconst geoID = parent.ID;\n\t\t\t\t\tconst geoRelationships = connections.get( geoID );\n\n\t\t\t\t\tgeoRelationships.parents.forEach( function ( geoConnParent ) {\n\n\t\t\t\t\t\tif ( modelMap.has( geoConnParent.ID ) ) {\n\n\t\t\t\t\t\t\tconst model = modelMap.get( geoConnParent.ID );\n\n\t\t\t\t\t\t\tmodel.bind( new Skeleton( skeleton.bones ), bindMatrices[ geoConnParent.ID ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\tparsePoseNodes() {\n\n\t\tconst bindMatrices = {};\n\n\t\tif ( 'Pose' in fbxTree.Objects ) {\n\n\t\t\tconst BindPoseNode = fbxTree.Objects.Pose;\n\n\t\t\tfor ( const nodeID in BindPoseNode ) {\n\n\t\t\t\tif ( BindPoseNode[ nodeID ].attrType === 'BindPose' && BindPoseNode[ nodeID ].NbPoseNodes > 0 ) {\n\n\t\t\t\t\tconst poseNodes = BindPoseNode[ nodeID ].PoseNode;\n\n\t\t\t\t\tif ( Array.isArray( poseNodes ) ) {\n\n\t\t\t\t\t\tposeNodes.forEach( function ( poseNode ) {\n\n\t\t\t\t\t\t\tbindMatrices[ poseNode.Node ] = new Matrix4().fromArray( poseNode.Matrix.a );\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbindMatrices[ poseNodes.Node ] = new Matrix4().fromArray( poseNodes.Matrix.a );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bindMatrices;\n\n\t}\n\n\t// Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light\n\tcreateAmbientLight() {\n\n\t\tif ( 'GlobalSettings' in fbxTree && 'AmbientColor' in fbxTree.GlobalSettings ) {\n\n\t\t\tconst ambientColor = fbxTree.GlobalSettings.AmbientColor.value;\n\t\t\tconst r = ambientColor[ 0 ];\n\t\t\tconst g = ambientColor[ 1 ];\n\t\t\tconst b = ambientColor[ 2 ];\n\n\t\t\tif ( r !== 0 || g !== 0 || b !== 0 ) {\n\n\t\t\t\tconst color = new Color( r, g, b ).convertSRGBToLinear();\n\t\t\t\tsceneGraph.add( new AmbientLight( color, 1 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n// parse Geometry data from FBXTree and return map of BufferGeometries\nclass GeometryParser {\n\n\tconstructor() {\n\n\t\tthis.negativeMaterialIndices = false;\n\n\t}\n\n\t// Parse nodes in FBXTree.Objects.Geometry\n\tparse( deformers ) {\n\n\t\tconst geometryMap = new Map();\n\n\t\tif ( 'Geometry' in fbxTree.Objects ) {\n\n\t\t\tconst geoNodes = fbxTree.Objects.Geometry;\n\n\t\t\tfor ( const nodeID in geoNodes ) {\n\n\t\t\t\tconst relationships = connections.get( parseInt( nodeID ) );\n\t\t\t\tconst geo = this.parseGeometry( relationships, geoNodes[ nodeID ], deformers );\n\n\t\t\t\tgeometryMap.set( parseInt( nodeID ), geo );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// report warnings\n\n\t\tif ( this.negativeMaterialIndices === true ) {\n\n\t\t\tconsole.warn( 'THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected.' );\n\n\t\t}\n\n\t\treturn geometryMap;\n\n\t}\n\n\t// Parse single node in FBXTree.Objects.Geometry\n\tparseGeometry( relationships, geoNode, deformers ) {\n\n\t\tswitch ( geoNode.attrType ) {\n\n\t\t\tcase 'Mesh':\n\t\t\t\treturn this.parseMeshGeometry( relationships, geoNode, deformers );\n\t\t\t\tbreak;\n\n\t\t\tcase 'NurbsCurve':\n\t\t\t\treturn this.parseNurbsGeometry( geoNode );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t// Parse single node mesh geometry in FBXTree.Objects.Geometry\n\tparseMeshGeometry( relationships, geoNode, deformers ) {\n\n\t\tconst skeletons = deformers.skeletons;\n\t\tconst morphTargets = [];\n\n\t\tconst modelNodes = relationships.parents.map( function ( parent ) {\n\n\t\t\treturn fbxTree.Objects.Model[ parent.ID ];\n\n\t\t} );\n\n\t\t// don't create geometry if it is not associated with any models\n\t\tif ( modelNodes.length === 0 ) return;\n\n\t\tconst skeleton = relationships.children.reduce( function ( skeleton, child ) {\n\n\t\t\tif ( skeletons[ child.ID ] !== undefined ) skeleton = skeletons[ child.ID ];\n\n\t\t\treturn skeleton;\n\n\t\t}, null );\n\n\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\tif ( deformers.morphTargets[ child.ID ] !== undefined ) {\n\n\t\t\t\tmorphTargets.push( deformers.morphTargets[ child.ID ] );\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// Assume one model and get the preRotation from that\n\t\t// if there is more than one model associated with the geometry this may cause problems\n\t\tconst modelNode = modelNodes[ 0 ];\n\n\t\tconst transformData = {};\n\n\t\tif ( 'RotationOrder' in modelNode ) transformData.eulerOrder = getEulerOrder( modelNode.RotationOrder.value );\n\t\tif ( 'InheritType' in modelNode ) transformData.inheritType = parseInt( modelNode.InheritType.value );\n\n\t\tif ( 'GeometricTranslation' in modelNode ) transformData.translation = modelNode.GeometricTranslation.value;\n\t\tif ( 'GeometricRotation' in modelNode ) transformData.rotation = modelNode.GeometricRotation.value;\n\t\tif ( 'GeometricScaling' in modelNode ) transformData.scale = modelNode.GeometricScaling.value;\n\n\t\tconst transform = generateTransform( transformData );\n\n\t\treturn this.genGeometry( geoNode, skeleton, morphTargets, transform );\n\n\t}\n\n\t// Generate a BufferGeometry from a node in FBXTree.Objects.Geometry\n\tgenGeometry( geoNode, skeleton, morphTargets, preTransform ) {\n\n\t\tconst geo = new BufferGeometry();\n\t\tif ( geoNode.attrName ) geo.name = geoNode.attrName;\n\n\t\tconst geoInfo = this.parseGeoNode( geoNode, skeleton );\n\t\tconst buffers = this.genBuffers( geoInfo );\n\n\t\tconst positionAttribute = new Float32BufferAttribute( buffers.vertex, 3 );\n\n\t\tpositionAttribute.applyMatrix4( preTransform );\n\n\t\tgeo.setAttribute( 'position', positionAttribute );\n\n\t\tif ( buffers.colors.length > 0 ) {\n\n\t\t\tgeo.setAttribute( 'color', new Float32BufferAttribute( buffers.colors, 3 ) );\n\n\t\t}\n\n\t\tif ( skeleton ) {\n\n\t\t\tgeo.setAttribute( 'skinIndex', new Uint16BufferAttribute( buffers.weightsIndices, 4 ) );\n\n\t\t\tgeo.setAttribute( 'skinWeight', new Float32BufferAttribute( buffers.vertexWeights, 4 ) );\n\n\t\t\t// used later to bind the skeleton to the model\n\t\t\tgeo.FBX_Deformer = skeleton;\n\n\t\t}\n\n\t\tif ( buffers.normal.length > 0 ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( preTransform );\n\n\t\t\tconst normalAttribute = new Float32BufferAttribute( buffers.normal, 3 );\n\t\t\tnormalAttribute.applyNormalMatrix( normalMatrix );\n\n\t\t\tgeo.setAttribute( 'normal', normalAttribute );\n\n\t\t}\n\n\t\tbuffers.uvs.forEach( function ( uvBuffer, i ) {\n\n\t\t\t// subsequent uv buffers are called 'uv1', 'uv2', ...\n\t\t\tlet name = 'uv' + ( i + 1 ).toString();\n\n\t\t\t// the first uv buffer is just called 'uv'\n\t\t\tif ( i === 0 ) {\n\n\t\t\t\tname = 'uv';\n\n\t\t\t}\n\n\t\t\tgeo.setAttribute( name, new Float32BufferAttribute( buffers.uvs[ i ], 2 ) );\n\n\t\t} );\n\n\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\n\n\t\t\t// Convert the material indices of each vertex into rendering groups on the geometry.\n\t\t\tlet prevMaterialIndex = buffers.materialIndex[ 0 ];\n\t\t\tlet startIndex = 0;\n\n\t\t\tbuffers.materialIndex.forEach( function ( currentIndex, i ) {\n\n\t\t\t\tif ( currentIndex !== prevMaterialIndex ) {\n\n\t\t\t\t\tgeo.addGroup( startIndex, i - startIndex, prevMaterialIndex );\n\n\t\t\t\t\tprevMaterialIndex = currentIndex;\n\t\t\t\t\tstartIndex = i;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\t// the loop above doesn't add the last group, do that here.\n\t\t\tif ( geo.groups.length > 0 ) {\n\n\t\t\t\tconst lastGroup = geo.groups[ geo.groups.length - 1 ];\n\t\t\t\tconst lastIndex = lastGroup.start + lastGroup.count;\n\n\t\t\t\tif ( lastIndex !== buffers.materialIndex.length ) {\n\n\t\t\t\t\tgeo.addGroup( lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// case where there are multiple materials but the whole geometry is only\n\t\t\t// using one of them\n\t\t\tif ( geo.groups.length === 0 ) {\n\n\t\t\t\tgeo.addGroup( 0, buffers.materialIndex.length, buffers.materialIndex[ 0 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.addMorphTargets( geo, geoNode, morphTargets, preTransform );\n\n\t\treturn geo;\n\n\t}\n\n\tparseGeoNode( geoNode, skeleton ) {\n\n\t\tconst geoInfo = {};\n\n\t\tgeoInfo.vertexPositions = ( geoNode.Vertices !== undefined ) ? geoNode.Vertices.a : [];\n\t\tgeoInfo.vertexIndices = ( geoNode.PolygonVertexIndex !== undefined ) ? geoNode.PolygonVertexIndex.a : [];\n\n\t\tif ( geoNode.LayerElementColor ) {\n\n\t\t\tgeoInfo.color = this.parseVertexColors( geoNode.LayerElementColor[ 0 ] );\n\n\t\t}\n\n\t\tif ( geoNode.LayerElementMaterial ) {\n\n\t\t\tgeoInfo.material = this.parseMaterialIndices( geoNode.LayerElementMaterial[ 0 ] );\n\n\t\t}\n\n\t\tif ( geoNode.LayerElementNormal ) {\n\n\t\t\tgeoInfo.normal = this.parseNormals( geoNode.LayerElementNormal[ 0 ] );\n\n\t\t}\n\n\t\tif ( geoNode.LayerElementUV ) {\n\n\t\t\tgeoInfo.uv = [];\n\n\t\t\tlet i = 0;\n\t\t\twhile ( geoNode.LayerElementUV[ i ] ) {\n\n\t\t\t\tif ( geoNode.LayerElementUV[ i ].UV ) {\n\n\t\t\t\t\tgeoInfo.uv.push( this.parseUVs( geoNode.LayerElementUV[ i ] ) );\n\n\t\t\t\t}\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeoInfo.weightTable = {};\n\n\t\tif ( skeleton !== null ) {\n\n\t\t\tgeoInfo.skeleton = skeleton;\n\n\t\t\tskeleton.rawBones.forEach( function ( rawBone, i ) {\n\n\t\t\t\t// loop over the bone's vertex indices and weights\n\t\t\t\trawBone.indices.forEach( function ( index, j ) {\n\n\t\t\t\t\tif ( geoInfo.weightTable[ index ] === undefined ) geoInfo.weightTable[ index ] = [];\n\n\t\t\t\t\tgeoInfo.weightTable[ index ].push( {\n\n\t\t\t\t\t\tid: i,\n\t\t\t\t\t\tweight: rawBone.weights[ j ],\n\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn geoInfo;\n\n\t}\n\n\tgenBuffers( geoInfo ) {\n\n\t\tconst buffers = {\n\t\t\tvertex: [],\n\t\t\tnormal: [],\n\t\t\tcolors: [],\n\t\t\tuvs: [],\n\t\t\tmaterialIndex: [],\n\t\t\tvertexWeights: [],\n\t\t\tweightsIndices: [],\n\t\t};\n\n\t\tlet polygonIndex = 0;\n\t\tlet faceLength = 0;\n\t\tlet displayedWeightsWarning = false;\n\n\t\t// these will hold data for a single face\n\t\tlet facePositionIndexes = [];\n\t\tlet faceNormals = [];\n\t\tlet faceColors = [];\n\t\tlet faceUVs = [];\n\t\tlet faceWeights = [];\n\t\tlet faceWeightIndices = [];\n\n\t\tconst scope = this;\n\t\tgeoInfo.vertexIndices.forEach( function ( vertexIndex, polygonVertexIndex ) {\n\n\t\t\tlet materialIndex;\n\t\t\tlet endOfFace = false;\n\n\t\t\t// Face index and vertex index arrays are combined in a single array\n\t\t\t// A cube with quad faces looks like this:\n\t\t\t// PolygonVertexIndex: *24 {\n\t\t\t//  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5\n\t\t\t//  }\n\t\t\t// Negative numbers mark the end of a face - first face here is 0, 1, 3, -3\n\t\t\t// to find index of last vertex bit shift the index: ^ - 1\n\t\t\tif ( vertexIndex < 0 ) {\n\n\t\t\t\tvertexIndex = vertexIndex ^ - 1; // equivalent to ( x * -1 ) - 1\n\t\t\t\tendOfFace = true;\n\n\t\t\t}\n\n\t\t\tlet weightIndices = [];\n\t\t\tlet weights = [];\n\n\t\t\tfacePositionIndexes.push( vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2 );\n\n\t\t\tif ( geoInfo.color ) {\n\n\t\t\t\tconst data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color );\n\n\t\t\t\tfaceColors.push( data[ 0 ], data[ 1 ], data[ 2 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.skeleton ) {\n\n\t\t\t\tif ( geoInfo.weightTable[ vertexIndex ] !== undefined ) {\n\n\t\t\t\t\tgeoInfo.weightTable[ vertexIndex ].forEach( function ( wt ) {\n\n\t\t\t\t\t\tweights.push( wt.weight );\n\t\t\t\t\t\tweightIndices.push( wt.id );\n\n\t\t\t\t\t} );\n\n\n\t\t\t\t}\n\n\t\t\t\tif ( weights.length > 4 ) {\n\n\t\t\t\t\tif ( ! displayedWeightsWarning ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.' );\n\t\t\t\t\t\tdisplayedWeightsWarning = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst wIndex = [ 0, 0, 0, 0 ];\n\t\t\t\t\tconst Weight = [ 0, 0, 0, 0 ];\n\n\t\t\t\t\tweights.forEach( function ( weight, weightIndex ) {\n\n\t\t\t\t\t\tlet currentWeight = weight;\n\t\t\t\t\t\tlet currentIndex = weightIndices[ weightIndex ];\n\n\t\t\t\t\t\tWeight.forEach( function ( comparedWeight, comparedWeightIndex, comparedWeightArray ) {\n\n\t\t\t\t\t\t\tif ( currentWeight > comparedWeight ) {\n\n\t\t\t\t\t\t\t\tcomparedWeightArray[ comparedWeightIndex ] = currentWeight;\n\t\t\t\t\t\t\t\tcurrentWeight = comparedWeight;\n\n\t\t\t\t\t\t\t\tconst tmp = wIndex[ comparedWeightIndex ];\n\t\t\t\t\t\t\t\twIndex[ comparedWeightIndex ] = currentIndex;\n\t\t\t\t\t\t\t\tcurrentIndex = tmp;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tweightIndices = wIndex;\n\t\t\t\t\tweights = Weight;\n\n\t\t\t\t}\n\n\t\t\t\t// if the weight array is shorter than 4 pad with 0s\n\t\t\t\twhile ( weights.length < 4 ) {\n\n\t\t\t\t\tweights.push( 0 );\n\t\t\t\t\tweightIndices.push( 0 );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0; i < 4; ++ i ) {\n\n\t\t\t\t\tfaceWeights.push( weights[ i ] );\n\t\t\t\t\tfaceWeightIndices.push( weightIndices[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.normal ) {\n\n\t\t\t\tconst data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal );\n\n\t\t\t\tfaceNormals.push( data[ 0 ], data[ 1 ], data[ 2 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\n\n\t\t\t\tmaterialIndex = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material )[ 0 ];\n\n\t\t\t\tif ( materialIndex < 0 ) {\n\n\t\t\t\t\tscope.negativeMaterialIndices = true;\n\t\t\t\t\tmaterialIndex = 0; // fallback\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.uv ) {\n\n\t\t\t\tgeoInfo.uv.forEach( function ( uv, i ) {\n\n\t\t\t\t\tconst data = getData( polygonVertexIndex, polygonIndex, vertexIndex, uv );\n\n\t\t\t\t\tif ( faceUVs[ i ] === undefined ) {\n\n\t\t\t\t\t\tfaceUVs[ i ] = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaceUVs[ i ].push( data[ 0 ] );\n\t\t\t\t\tfaceUVs[ i ].push( data[ 1 ] );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfaceLength ++;\n\n\t\t\tif ( endOfFace ) {\n\n\t\t\t\tif ( faceLength > 4 ) console.warn( 'THREE.FBXLoader: Polygons with more than four sides are not supported. Make sure to triangulate the geometry during export.' );\n\n\t\t\t\tscope.genFace( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength );\n\n\t\t\t\tpolygonIndex ++;\n\t\t\t\tfaceLength = 0;\n\n\t\t\t\t// reset arrays for the next face\n\t\t\t\tfacePositionIndexes = [];\n\t\t\t\tfaceNormals = [];\n\t\t\t\tfaceColors = [];\n\t\t\t\tfaceUVs = [];\n\t\t\t\tfaceWeights = [];\n\t\t\t\tfaceWeightIndices = [];\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn buffers;\n\n\t}\n\n\t// Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris\n\tgenFace( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength ) {\n\n\t\tfor ( let i = 2; i < faceLength; i ++ ) {\n\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 0 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 1 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 2 ] ] );\n\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 + 1 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 + 2 ] ] );\n\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 + 1 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 + 2 ] ] );\n\n\t\t\tif ( geoInfo.skeleton ) {\n\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 0 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 1 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 2 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 3 ] );\n\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 1 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 2 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 3 ] );\n\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 + 1 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 + 2 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 + 3 ] );\n\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 0 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 1 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 2 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 3 ] );\n\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 1 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 2 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 3 ] );\n\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 + 1 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 + 2 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 + 3 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.color ) {\n\n\t\t\t\tbuffers.colors.push( faceColors[ 0 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ 1 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ 2 ] );\n\n\t\t\t\tbuffers.colors.push( faceColors[ ( i - 1 ) * 3 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ ( i - 1 ) * 3 + 1 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ ( i - 1 ) * 3 + 2 ] );\n\n\t\t\t\tbuffers.colors.push( faceColors[ i * 3 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ i * 3 + 1 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ i * 3 + 2 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\n\n\t\t\t\tbuffers.materialIndex.push( materialIndex );\n\t\t\t\tbuffers.materialIndex.push( materialIndex );\n\t\t\t\tbuffers.materialIndex.push( materialIndex );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.normal ) {\n\n\t\t\t\tbuffers.normal.push( faceNormals[ 0 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ 1 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ 2 ] );\n\n\t\t\t\tbuffers.normal.push( faceNormals[ ( i - 1 ) * 3 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ ( i - 1 ) * 3 + 1 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ ( i - 1 ) * 3 + 2 ] );\n\n\t\t\t\tbuffers.normal.push( faceNormals[ i * 3 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ i * 3 + 1 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ i * 3 + 2 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.uv ) {\n\n\t\t\t\tgeoInfo.uv.forEach( function ( uv, j ) {\n\n\t\t\t\t\tif ( buffers.uvs[ j ] === undefined ) buffers.uvs[ j ] = [];\n\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ 0 ] );\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ 1 ] );\n\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ ( i - 1 ) * 2 ] );\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ ( i - 1 ) * 2 + 1 ] );\n\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ i * 2 ] );\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ i * 2 + 1 ] );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\taddMorphTargets( parentGeo, parentGeoNode, morphTargets, preTransform ) {\n\n\t\tif ( morphTargets.length === 0 ) return;\n\n\t\tparentGeo.morphTargetsRelative = true;\n\n\t\tparentGeo.morphAttributes.position = [];\n\t\t// parentGeo.morphAttributes.normal = []; // not implemented\n\n\t\tconst scope = this;\n\t\tmorphTargets.forEach( function ( morphTarget ) {\n\n\t\t\tmorphTarget.rawTargets.forEach( function ( rawTarget ) {\n\n\t\t\t\tconst morphGeoNode = fbxTree.Objects.Geometry[ rawTarget.geoID ];\n\n\t\t\t\tif ( morphGeoNode !== undefined ) {\n\n\t\t\t\t\tscope.genMorphGeometry( parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\t// a morph geometry node is similar to a standard  node, and the node is also contained\n\t// in FBXTree.Objects.Geometry, however it can only have attributes for position, normal\n\t// and a special attribute Index defining which vertices of the original geometry are affected\n\t// Normal and position attributes only have data for the vertices that are affected by the morph\n\tgenMorphGeometry( parentGeo, parentGeoNode, morphGeoNode, preTransform, name ) {\n\n\t\tconst vertexIndices = ( parentGeoNode.PolygonVertexIndex !== undefined ) ? parentGeoNode.PolygonVertexIndex.a : [];\n\n\t\tconst morphPositionsSparse = ( morphGeoNode.Vertices !== undefined ) ? morphGeoNode.Vertices.a : [];\n\t\tconst indices = ( morphGeoNode.Indexes !== undefined ) ? morphGeoNode.Indexes.a : [];\n\n\t\tconst length = parentGeo.attributes.position.count * 3;\n\t\tconst morphPositions = new Float32Array( length );\n\n\t\tfor ( let i = 0; i < indices.length; i ++ ) {\n\n\t\t\tconst morphIndex = indices[ i ] * 3;\n\n\t\t\tmorphPositions[ morphIndex ] = morphPositionsSparse[ i * 3 ];\n\t\t\tmorphPositions[ morphIndex + 1 ] = morphPositionsSparse[ i * 3 + 1 ];\n\t\t\tmorphPositions[ morphIndex + 2 ] = morphPositionsSparse[ i * 3 + 2 ];\n\n\t\t}\n\n\t\t// TODO: add morph normal support\n\t\tconst morphGeoInfo = {\n\t\t\tvertexIndices: vertexIndices,\n\t\t\tvertexPositions: morphPositions,\n\n\t\t};\n\n\t\tconst morphBuffers = this.genBuffers( morphGeoInfo );\n\n\t\tconst positionAttribute = new Float32BufferAttribute( morphBuffers.vertex, 3 );\n\t\tpositionAttribute.name = name || morphGeoNode.attrName;\n\n\t\tpositionAttribute.applyMatrix4( preTransform );\n\n\t\tparentGeo.morphAttributes.position.push( positionAttribute );\n\n\t}\n\n\t// Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists\n\tparseNormals( NormalNode ) {\n\n\t\tconst mappingType = NormalNode.MappingInformationType;\n\t\tconst referenceType = NormalNode.ReferenceInformationType;\n\t\tconst buffer = NormalNode.Normals.a;\n\t\tlet indexBuffer = [];\n\t\tif ( referenceType === 'IndexToDirect' ) {\n\n\t\t\tif ( 'NormalIndex' in NormalNode ) {\n\n\t\t\t\tindexBuffer = NormalNode.NormalIndex.a;\n\n\t\t\t} else if ( 'NormalsIndex' in NormalNode ) {\n\n\t\t\t\tindexBuffer = NormalNode.NormalsIndex.a;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\t\t\tdataSize: 3,\n\t\t\tbuffer: buffer,\n\t\t\tindices: indexBuffer,\n\t\t\tmappingType: mappingType,\n\t\t\treferenceType: referenceType\n\t\t};\n\n\t}\n\n\t// Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists\n\tparseUVs( UVNode ) {\n\n\t\tconst mappingType = UVNode.MappingInformationType;\n\t\tconst referenceType = UVNode.ReferenceInformationType;\n\t\tconst buffer = UVNode.UV.a;\n\t\tlet indexBuffer = [];\n\t\tif ( referenceType === 'IndexToDirect' ) {\n\n\t\t\tindexBuffer = UVNode.UVIndex.a;\n\n\t\t}\n\n\t\treturn {\n\t\t\tdataSize: 2,\n\t\t\tbuffer: buffer,\n\t\t\tindices: indexBuffer,\n\t\t\tmappingType: mappingType,\n\t\t\treferenceType: referenceType\n\t\t};\n\n\t}\n\n\t// Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists\n\tparseVertexColors( ColorNode ) {\n\n\t\tconst mappingType = ColorNode.MappingInformationType;\n\t\tconst referenceType = ColorNode.ReferenceInformationType;\n\t\tconst buffer = ColorNode.Colors.a;\n\t\tlet indexBuffer = [];\n\t\tif ( referenceType === 'IndexToDirect' ) {\n\n\t\t\tindexBuffer = ColorNode.ColorIndex.a;\n\n\t\t}\n\n\t\tfor ( let i = 0, c = new Color(); i < buffer.length; i += 4 ) {\n\n\t\t\tc.fromArray( buffer, i ).convertSRGBToLinear().toArray( buffer, i );\n\n\t\t}\n\n\t\treturn {\n\t\t\tdataSize: 4,\n\t\t\tbuffer: buffer,\n\t\t\tindices: indexBuffer,\n\t\t\tmappingType: mappingType,\n\t\t\treferenceType: referenceType\n\t\t};\n\n\t}\n\n\t// Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists\n\tparseMaterialIndices( MaterialNode ) {\n\n\t\tconst mappingType = MaterialNode.MappingInformationType;\n\t\tconst referenceType = MaterialNode.ReferenceInformationType;\n\n\t\tif ( mappingType === 'NoMappingInformation' ) {\n\n\t\t\treturn {\n\t\t\t\tdataSize: 1,\n\t\t\t\tbuffer: [ 0 ],\n\t\t\t\tindices: [ 0 ],\n\t\t\t\tmappingType: 'AllSame',\n\t\t\t\treferenceType: referenceType\n\t\t\t};\n\n\t\t}\n\n\t\tconst materialIndexBuffer = MaterialNode.Materials.a;\n\n\t\t// Since materials are stored as indices, there's a bit of a mismatch between FBX and what\n\t\t// we expect.So we create an intermediate buffer that points to the index in the buffer,\n\t\t// for conforming with the other functions we've written for other data.\n\t\tconst materialIndices = [];\n\n\t\tfor ( let i = 0; i < materialIndexBuffer.length; ++ i ) {\n\n\t\t\tmaterialIndices.push( i );\n\n\t\t}\n\n\t\treturn {\n\t\t\tdataSize: 1,\n\t\t\tbuffer: materialIndexBuffer,\n\t\t\tindices: materialIndices,\n\t\t\tmappingType: mappingType,\n\t\t\treferenceType: referenceType\n\t\t};\n\n\t}\n\n\t// Generate a NurbGeometry from a node in FBXTree.Objects.Geometry\n\tparseNurbsGeometry( geoNode ) {\n\n\t\tconst order = parseInt( geoNode.Order );\n\n\t\tif ( isNaN( order ) ) {\n\n\t\t\tconsole.error( 'THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id );\n\t\t\treturn new BufferGeometry();\n\n\t\t}\n\n\t\tconst degree = order - 1;\n\n\t\tconst knots = geoNode.KnotVector.a;\n\t\tconst controlPoints = [];\n\t\tconst pointsValues = geoNode.Points.a;\n\n\t\tfor ( let i = 0, l = pointsValues.length; i < l; i += 4 ) {\n\n\t\t\tcontrolPoints.push( new Vector4().fromArray( pointsValues, i ) );\n\n\t\t}\n\n\t\tlet startKnot, endKnot;\n\n\t\tif ( geoNode.Form === 'Closed' ) {\n\n\t\t\tcontrolPoints.push( controlPoints[ 0 ] );\n\n\t\t} else if ( geoNode.Form === 'Periodic' ) {\n\n\t\t\tstartKnot = degree;\n\t\t\tendKnot = knots.length - 1 - startKnot;\n\n\t\t\tfor ( let i = 0; i < degree; ++ i ) {\n\n\t\t\t\tcontrolPoints.push( controlPoints[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst curve = new NURBSCurve( degree, knots, controlPoints, startKnot, endKnot );\n\t\tconst points = curve.getPoints( controlPoints.length * 12 );\n\n\t\treturn new BufferGeometry().setFromPoints( points );\n\n\t}\n\n}\n\n// parse animation data from FBXTree\nclass AnimationParser {\n\n\t// take raw animation clips and turn them into three.js animation clips\n\tparse() {\n\n\t\tconst animationClips = [];\n\n\t\tconst rawClips = this.parseClips();\n\n\t\tif ( rawClips !== undefined ) {\n\n\t\t\tfor ( const key in rawClips ) {\n\n\t\t\t\tconst rawClip = rawClips[ key ];\n\n\t\t\t\tconst clip = this.addClip( rawClip );\n\n\t\t\t\tanimationClips.push( clip );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn animationClips;\n\n\t}\n\n\tparseClips() {\n\n\t\t// since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,\n\t\t// if this is undefined we can safely assume there are no animations\n\t\tif ( fbxTree.Objects.AnimationCurve === undefined ) return undefined;\n\n\t\tconst curveNodesMap = this.parseAnimationCurveNodes();\n\n\t\tthis.parseAnimationCurves( curveNodesMap );\n\n\t\tconst layersMap = this.parseAnimationLayers( curveNodesMap );\n\t\tconst rawClips = this.parseAnimStacks( layersMap );\n\n\t\treturn rawClips;\n\n\t}\n\n\t// parse nodes in FBXTree.Objects.AnimationCurveNode\n\t// each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )\n\t// and is referenced by an AnimationLayer\n\tparseAnimationCurveNodes() {\n\n\t\tconst rawCurveNodes = fbxTree.Objects.AnimationCurveNode;\n\n\t\tconst curveNodesMap = new Map();\n\n\t\tfor ( const nodeID in rawCurveNodes ) {\n\n\t\t\tconst rawCurveNode = rawCurveNodes[ nodeID ];\n\n\t\t\tif ( rawCurveNode.attrName.match( /S|R|T|DeformPercent/ ) !== null ) {\n\n\t\t\t\tconst curveNode = {\n\n\t\t\t\t\tid: rawCurveNode.id,\n\t\t\t\t\tattr: rawCurveNode.attrName,\n\t\t\t\t\tcurves: {},\n\n\t\t\t\t};\n\n\t\t\t\tcurveNodesMap.set( curveNode.id, curveNode );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn curveNodesMap;\n\n\t}\n\n\t// parse nodes in FBXTree.Objects.AnimationCurve and connect them up to\n\t// previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated\n\t// axis ( e.g. times and values of x rotation)\n\tparseAnimationCurves( curveNodesMap ) {\n\n\t\tconst rawCurves = fbxTree.Objects.AnimationCurve;\n\n\t\t// TODO: Many values are identical up to roundoff error, but won't be optimised\n\t\t// e.g. position times: [0, 0.4, 0. 8]\n\t\t// position values: [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.235384487103147e-7, 93.67520904541016, -0.9982695579528809]\n\t\t// clearly, this should be optimised to\n\t\t// times: [0], positions [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809]\n\t\t// this shows up in nearly every FBX file, and generally time array is length > 100\n\n\t\tfor ( const nodeID in rawCurves ) {\n\n\t\t\tconst animationCurve = {\n\n\t\t\t\tid: rawCurves[ nodeID ].id,\n\t\t\t\ttimes: rawCurves[ nodeID ].KeyTime.a.map( convertFBXTimeToSeconds ),\n\t\t\t\tvalues: rawCurves[ nodeID ].KeyValueFloat.a,\n\n\t\t\t};\n\n\t\t\tconst relationships = connections.get( animationCurve.id );\n\n\t\t\tif ( relationships !== undefined ) {\n\n\t\t\t\tconst animationCurveID = relationships.parents[ 0 ].ID;\n\t\t\t\tconst animationCurveRelationship = relationships.parents[ 0 ].relationship;\n\n\t\t\t\tif ( animationCurveRelationship.match( /X/ ) ) {\n\n\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'x' ] = animationCurve;\n\n\t\t\t\t} else if ( animationCurveRelationship.match( /Y/ ) ) {\n\n\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'y' ] = animationCurve;\n\n\t\t\t\t} else if ( animationCurveRelationship.match( /Z/ ) ) {\n\n\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'z' ] = animationCurve;\n\n\t\t\t\t} else if ( animationCurveRelationship.match( /DeformPercent/ ) && curveNodesMap.has( animationCurveID ) ) {\n\n\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'morph' ] = animationCurve;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references\n\t// to various AnimationCurveNodes and is referenced by an AnimationStack node\n\t// note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack\n\tparseAnimationLayers( curveNodesMap ) {\n\n\t\tconst rawLayers = fbxTree.Objects.AnimationLayer;\n\n\t\tconst layersMap = new Map();\n\n\t\tfor ( const nodeID in rawLayers ) {\n\n\t\t\tconst layerCurveNodes = [];\n\n\t\t\tconst connection = connections.get( parseInt( nodeID ) );\n\n\t\t\tif ( connection !== undefined ) {\n\n\t\t\t\t// all the animationCurveNodes used in the layer\n\t\t\t\tconst children = connection.children;\n\n\t\t\t\tchildren.forEach( function ( child, i ) {\n\n\t\t\t\t\tif ( curveNodesMap.has( child.ID ) ) {\n\n\t\t\t\t\t\tconst curveNode = curveNodesMap.get( child.ID );\n\n\t\t\t\t\t\t// check that the curves are defined for at least one axis, otherwise ignore the curveNode\n\t\t\t\t\t\tif ( curveNode.curves.x !== undefined || curveNode.curves.y !== undefined || curveNode.curves.z !== undefined ) {\n\n\t\t\t\t\t\t\tif ( layerCurveNodes[ i ] === undefined ) {\n\n\t\t\t\t\t\t\t\tconst modelID = connections.get( child.ID ).parents.filter( function ( parent ) {\n\n\t\t\t\t\t\t\t\t\treturn parent.relationship !== undefined;\n\n\t\t\t\t\t\t\t\t} )[ 0 ].ID;\n\n\t\t\t\t\t\t\t\tif ( modelID !== undefined ) {\n\n\t\t\t\t\t\t\t\t\tconst rawModel = fbxTree.Objects.Model[ modelID.toString() ];\n\n\t\t\t\t\t\t\t\t\tif ( rawModel === undefined ) {\n\n\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Encountered a unused curve.', child );\n\t\t\t\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tconst node = {\n\n\t\t\t\t\t\t\t\t\t\tmodelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName( rawModel.attrName ) : '',\n\t\t\t\t\t\t\t\t\t\tID: rawModel.id,\n\t\t\t\t\t\t\t\t\t\tinitialPosition: [ 0, 0, 0 ],\n\t\t\t\t\t\t\t\t\t\tinitialRotation: [ 0, 0, 0 ],\n\t\t\t\t\t\t\t\t\t\tinitialScale: [ 1, 1, 1 ],\n\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\tsceneGraph.traverse( function ( child ) {\n\n\t\t\t\t\t\t\t\t\t\tif ( child.ID === rawModel.id ) {\n\n\t\t\t\t\t\t\t\t\t\t\tnode.transform = child.matrix;\n\n\t\t\t\t\t\t\t\t\t\t\tif ( child.userData.transformData ) node.eulerOrder = child.userData.transformData.eulerOrder;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t\t\tif ( ! node.transform ) node.transform = new Matrix4();\n\n\t\t\t\t\t\t\t\t\t// if the animated model is pre rotated, we'll have to apply the pre rotations to every\n\t\t\t\t\t\t\t\t\t// animation value as well\n\t\t\t\t\t\t\t\t\tif ( 'PreRotation' in rawModel ) node.preRotation = rawModel.PreRotation.value;\n\t\t\t\t\t\t\t\t\tif ( 'PostRotation' in rawModel ) node.postRotation = rawModel.PostRotation.value;\n\n\t\t\t\t\t\t\t\t\tlayerCurveNodes[ i ] = node;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( layerCurveNodes[ i ] ) layerCurveNodes[ i ][ curveNode.attr ] = curveNode;\n\n\t\t\t\t\t\t} else if ( curveNode.curves.morph !== undefined ) {\n\n\t\t\t\t\t\t\tif ( layerCurveNodes[ i ] === undefined ) {\n\n\t\t\t\t\t\t\t\tconst deformerID = connections.get( child.ID ).parents.filter( function ( parent ) {\n\n\t\t\t\t\t\t\t\t\treturn parent.relationship !== undefined;\n\n\t\t\t\t\t\t\t\t} )[ 0 ].ID;\n\n\t\t\t\t\t\t\t\tconst morpherID = connections.get( deformerID ).parents[ 0 ].ID;\n\t\t\t\t\t\t\t\tconst geoID = connections.get( morpherID ).parents[ 0 ].ID;\n\n\t\t\t\t\t\t\t\t// assuming geometry is not used in more than one model\n\t\t\t\t\t\t\t\tconst modelID = connections.get( geoID ).parents[ 0 ].ID;\n\n\t\t\t\t\t\t\t\tconst rawModel = fbxTree.Objects.Model[ modelID ];\n\n\t\t\t\t\t\t\t\tconst node = {\n\n\t\t\t\t\t\t\t\t\tmodelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName( rawModel.attrName ) : '',\n\t\t\t\t\t\t\t\t\tmorphName: fbxTree.Objects.Deformer[ deformerID ].attrName,\n\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tlayerCurveNodes[ i ] = node;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlayerCurveNodes[ i ][ curveNode.attr ] = curveNode;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tlayersMap.set( parseInt( nodeID ), layerCurveNodes );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn layersMap;\n\n\t}\n\n\t// parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation\n\t// hierarchy. Each Stack node will be used to create a AnimationClip\n\tparseAnimStacks( layersMap ) {\n\n\t\tconst rawStacks = fbxTree.Objects.AnimationStack;\n\n\t\t// connect the stacks (clips) up to the layers\n\t\tconst rawClips = {};\n\n\t\tfor ( const nodeID in rawStacks ) {\n\n\t\t\tconst children = connections.get( parseInt( nodeID ) ).children;\n\n\t\t\tif ( children.length > 1 ) {\n\n\t\t\t\t// it seems like stacks will always be associated with a single layer. But just in case there are files\n\t\t\t\t// where there are multiple layers per stack, we'll display a warning\n\t\t\t\tconsole.warn( 'THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.' );\n\n\t\t\t}\n\n\t\t\tconst layer = layersMap.get( children[ 0 ].ID );\n\n\t\t\trawClips[ nodeID ] = {\n\n\t\t\t\tname: rawStacks[ nodeID ].attrName,\n\t\t\t\tlayer: layer,\n\n\t\t\t};\n\n\t\t}\n\n\t\treturn rawClips;\n\n\t}\n\n\taddClip( rawClip ) {\n\n\t\tlet tracks = [];\n\n\t\tconst scope = this;\n\t\trawClip.layer.forEach( function ( rawTracks ) {\n\n\t\t\ttracks = tracks.concat( scope.generateTracks( rawTracks ) );\n\n\t\t} );\n\n\t\treturn new AnimationClip( rawClip.name, - 1, tracks );\n\n\t}\n\n\tgenerateTracks( rawTracks ) {\n\n\t\tconst tracks = [];\n\n\t\tlet initialPosition = new Vector3();\n\t\tlet initialRotation = new Quaternion();\n\t\tlet initialScale = new Vector3();\n\n\t\tif ( rawTracks.transform ) rawTracks.transform.decompose( initialPosition, initialRotation, initialScale );\n\n\t\tinitialPosition = initialPosition.toArray();\n\t\tinitialRotation = new Euler().setFromQuaternion( initialRotation, rawTracks.eulerOrder ).toArray();\n\t\tinitialScale = initialScale.toArray();\n\n\t\tif ( rawTracks.T !== undefined && Object.keys( rawTracks.T.curves ).length > 0 ) {\n\n\t\t\tconst positionTrack = this.generateVectorTrack( rawTracks.modelName, rawTracks.T.curves, initialPosition, 'position' );\n\t\t\tif ( positionTrack !== undefined ) tracks.push( positionTrack );\n\n\t\t}\n\n\t\tif ( rawTracks.R !== undefined && Object.keys( rawTracks.R.curves ).length > 0 ) {\n\n\t\t\tconst rotationTrack = this.generateRotationTrack( rawTracks.modelName, rawTracks.R.curves, initialRotation, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder );\n\t\t\tif ( rotationTrack !== undefined ) tracks.push( rotationTrack );\n\n\t\t}\n\n\t\tif ( rawTracks.S !== undefined && Object.keys( rawTracks.S.curves ).length > 0 ) {\n\n\t\t\tconst scaleTrack = this.generateVectorTrack( rawTracks.modelName, rawTracks.S.curves, initialScale, 'scale' );\n\t\t\tif ( scaleTrack !== undefined ) tracks.push( scaleTrack );\n\n\t\t}\n\n\t\tif ( rawTracks.DeformPercent !== undefined ) {\n\n\t\t\tconst morphTrack = this.generateMorphTrack( rawTracks );\n\t\t\tif ( morphTrack !== undefined ) tracks.push( morphTrack );\n\n\t\t}\n\n\t\treturn tracks;\n\n\t}\n\n\tgenerateVectorTrack( modelName, curves, initialValue, type ) {\n\n\t\tconst times = this.getTimesForAllAxes( curves );\n\t\tconst values = this.getKeyframeTrackValues( times, curves, initialValue );\n\n\t\treturn new VectorKeyframeTrack( modelName + '.' + type, times, values );\n\n\t}\n\n\tgenerateRotationTrack( modelName, curves, initialValue, preRotation, postRotation, eulerOrder ) {\n\n\t\tif ( curves.x !== undefined ) {\n\n\t\t\tthis.interpolateRotations( curves.x );\n\t\t\tcurves.x.values = curves.x.values.map( MathUtils.degToRad );\n\n\t\t}\n\n\t\tif ( curves.y !== undefined ) {\n\n\t\t\tthis.interpolateRotations( curves.y );\n\t\t\tcurves.y.values = curves.y.values.map( MathUtils.degToRad );\n\n\t\t}\n\n\t\tif ( curves.z !== undefined ) {\n\n\t\t\tthis.interpolateRotations( curves.z );\n\t\t\tcurves.z.values = curves.z.values.map( MathUtils.degToRad );\n\n\t\t}\n\n\t\tconst times = this.getTimesForAllAxes( curves );\n\t\tconst values = this.getKeyframeTrackValues( times, curves, initialValue );\n\n\t\tif ( preRotation !== undefined ) {\n\n\t\t\tpreRotation = preRotation.map( MathUtils.degToRad );\n\t\t\tpreRotation.push( eulerOrder );\n\n\t\t\tpreRotation = new Euler().fromArray( preRotation );\n\t\t\tpreRotation = new Quaternion().setFromEuler( preRotation );\n\n\t\t}\n\n\t\tif ( postRotation !== undefined ) {\n\n\t\t\tpostRotation = postRotation.map( MathUtils.degToRad );\n\t\t\tpostRotation.push( eulerOrder );\n\n\t\t\tpostRotation = new Euler().fromArray( postRotation );\n\t\t\tpostRotation = new Quaternion().setFromEuler( postRotation ).invert();\n\n\t\t}\n\n\t\tconst quaternion = new Quaternion();\n\t\tconst euler = new Euler();\n\n\t\tconst quaternionValues = [];\n\n\t\tfor ( let i = 0; i < values.length; i += 3 ) {\n\n\t\t\teuler.set( values[ i ], values[ i + 1 ], values[ i + 2 ], eulerOrder );\n\n\t\t\tquaternion.setFromEuler( euler );\n\n\t\t\tif ( preRotation !== undefined ) quaternion.premultiply( preRotation );\n\t\t\tif ( postRotation !== undefined ) quaternion.multiply( postRotation );\n\n\t\t\tquaternion.toArray( quaternionValues, ( i / 3 ) * 4 );\n\n\t\t}\n\n\t\treturn new QuaternionKeyframeTrack( modelName + '.quaternion', times, quaternionValues );\n\n\t}\n\n\tgenerateMorphTrack( rawTracks ) {\n\n\t\tconst curves = rawTracks.DeformPercent.curves.morph;\n\t\tconst values = curves.values.map( function ( val ) {\n\n\t\t\treturn val / 100;\n\n\t\t} );\n\n\t\tconst morphNum = sceneGraph.getObjectByName( rawTracks.modelName ).morphTargetDictionary[ rawTracks.morphName ];\n\n\t\treturn new NumberKeyframeTrack( rawTracks.modelName + '.morphTargetInfluences[' + morphNum + ']', curves.times, values );\n\n\t}\n\n\t// For all animated objects, times are defined separately for each axis\n\t// Here we'll combine the times into one sorted array without duplicates\n\tgetTimesForAllAxes( curves ) {\n\n\t\tlet times = [];\n\n\t\t// first join together the times for each axis, if defined\n\t\tif ( curves.x !== undefined ) times = times.concat( curves.x.times );\n\t\tif ( curves.y !== undefined ) times = times.concat( curves.y.times );\n\t\tif ( curves.z !== undefined ) times = times.concat( curves.z.times );\n\n\t\t// then sort them\n\t\ttimes = times.sort( function ( a, b ) {\n\n\t\t\treturn a - b;\n\n\t\t} );\n\n\t\t// and remove duplicates\n\t\tif ( times.length > 1 ) {\n\n\t\t\tlet targetIndex = 1;\n\t\t\tlet lastValue = times[ 0 ];\n\t\t\tfor ( let i = 1; i < times.length; i ++ ) {\n\n\t\t\t\tconst currentValue = times[ i ];\n\t\t\t\tif ( currentValue !== lastValue ) {\n\n\t\t\t\t\ttimes[ targetIndex ] = currentValue;\n\t\t\t\t\tlastValue = currentValue;\n\t\t\t\t\ttargetIndex ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttimes = times.slice( 0, targetIndex );\n\n\t\t}\n\n\t\treturn times;\n\n\t}\n\n\tgetKeyframeTrackValues( times, curves, initialValue ) {\n\n\t\tconst prevValue = initialValue;\n\n\t\tconst values = [];\n\n\t\tlet xIndex = - 1;\n\t\tlet yIndex = - 1;\n\t\tlet zIndex = - 1;\n\n\t\ttimes.forEach( function ( time ) {\n\n\t\t\tif ( curves.x ) xIndex = curves.x.times.indexOf( time );\n\t\t\tif ( curves.y ) yIndex = curves.y.times.indexOf( time );\n\t\t\tif ( curves.z ) zIndex = curves.z.times.indexOf( time );\n\n\t\t\t// if there is an x value defined for this frame, use that\n\t\t\tif ( xIndex !== - 1 ) {\n\n\t\t\t\tconst xValue = curves.x.values[ xIndex ];\n\t\t\t\tvalues.push( xValue );\n\t\t\t\tprevValue[ 0 ] = xValue;\n\n\t\t\t} else {\n\n\t\t\t\t// otherwise use the x value from the previous frame\n\t\t\t\tvalues.push( prevValue[ 0 ] );\n\n\t\t\t}\n\n\t\t\tif ( yIndex !== - 1 ) {\n\n\t\t\t\tconst yValue = curves.y.values[ yIndex ];\n\t\t\t\tvalues.push( yValue );\n\t\t\t\tprevValue[ 1 ] = yValue;\n\n\t\t\t} else {\n\n\t\t\t\tvalues.push( prevValue[ 1 ] );\n\n\t\t\t}\n\n\t\t\tif ( zIndex !== - 1 ) {\n\n\t\t\t\tconst zValue = curves.z.values[ zIndex ];\n\t\t\t\tvalues.push( zValue );\n\t\t\t\tprevValue[ 2 ] = zValue;\n\n\t\t\t} else {\n\n\t\t\t\tvalues.push( prevValue[ 2 ] );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn values;\n\n\t}\n\n\t// Rotations are defined as Euler angles which can have values  of any size\n\t// These will be converted to quaternions which don't support values greater than\n\t// PI, so we'll interpolate large rotations\n\tinterpolateRotations( curve ) {\n\n\t\tfor ( let i = 1; i < curve.values.length; i ++ ) {\n\n\t\t\tconst initialValue = curve.values[ i - 1 ];\n\t\t\tconst valuesSpan = curve.values[ i ] - initialValue;\n\n\t\t\tconst absoluteSpan = Math.abs( valuesSpan );\n\n\t\t\tif ( absoluteSpan >= 180 ) {\n\n\t\t\t\tconst numSubIntervals = absoluteSpan / 180;\n\n\t\t\t\tconst step = valuesSpan / numSubIntervals;\n\t\t\t\tlet nextValue = initialValue + step;\n\n\t\t\t\tconst initialTime = curve.times[ i - 1 ];\n\t\t\t\tconst timeSpan = curve.times[ i ] - initialTime;\n\t\t\t\tconst interval = timeSpan / numSubIntervals;\n\t\t\t\tlet nextTime = initialTime + interval;\n\n\t\t\t\tconst interpolatedTimes = [];\n\t\t\t\tconst interpolatedValues = [];\n\n\t\t\t\twhile ( nextTime < curve.times[ i ] ) {\n\n\t\t\t\t\tinterpolatedTimes.push( nextTime );\n\t\t\t\t\tnextTime += interval;\n\n\t\t\t\t\tinterpolatedValues.push( nextValue );\n\t\t\t\t\tnextValue += step;\n\n\t\t\t\t}\n\n\t\t\t\tcurve.times = inject( curve.times, i, interpolatedTimes );\n\t\t\t\tcurve.values = inject( curve.values, i, interpolatedValues );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n// parse an FBX file in ASCII format\nclass TextParser {\n\n\tgetPrevNode() {\n\n\t\treturn this.nodeStack[ this.currentIndent - 2 ];\n\n\t}\n\n\tgetCurrentNode() {\n\n\t\treturn this.nodeStack[ this.currentIndent - 1 ];\n\n\t}\n\n\tgetCurrentProp() {\n\n\t\treturn this.currentProp;\n\n\t}\n\n\tpushStack( node ) {\n\n\t\tthis.nodeStack.push( node );\n\t\tthis.currentIndent += 1;\n\n\t}\n\n\tpopStack() {\n\n\t\tthis.nodeStack.pop();\n\t\tthis.currentIndent -= 1;\n\n\t}\n\n\tsetCurrentProp( val, name ) {\n\n\t\tthis.currentProp = val;\n\t\tthis.currentPropName = name;\n\n\t}\n\n\tparse( text ) {\n\n\t\tthis.currentIndent = 0;\n\n\t\tthis.allNodes = new FBXTree();\n\t\tthis.nodeStack = [];\n\t\tthis.currentProp = [];\n\t\tthis.currentPropName = '';\n\n\t\tconst scope = this;\n\n\t\tconst split = text.split( /[\\r\\n]+/ );\n\n\t\tsplit.forEach( function ( line, i ) {\n\n\t\t\tconst matchComment = line.match( /^[\\s\\t]*;/ );\n\t\t\tconst matchEmpty = line.match( /^[\\s\\t]*$/ );\n\n\t\t\tif ( matchComment || matchEmpty ) return;\n\n\t\t\tconst matchBeginning = line.match( '^\\\\t{' + scope.currentIndent + '}(\\\\w+):(.*){', '' );\n\t\t\tconst matchProperty = line.match( '^\\\\t{' + ( scope.currentIndent ) + '}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)' );\n\t\t\tconst matchEnd = line.match( '^\\\\t{' + ( scope.currentIndent - 1 ) + '}}' );\n\n\t\t\tif ( matchBeginning ) {\n\n\t\t\t\tscope.parseNodeBegin( line, matchBeginning );\n\n\t\t\t} else if ( matchProperty ) {\n\n\t\t\t\tscope.parseNodeProperty( line, matchProperty, split[ ++ i ] );\n\n\t\t\t} else if ( matchEnd ) {\n\n\t\t\t\tscope.popStack();\n\n\t\t\t} else if ( line.match( /^[^\\s\\t}]/ ) ) {\n\n\t\t\t\t// large arrays are split over multiple lines terminated with a ',' character\n\t\t\t\t// if this is encountered the line needs to be joined to the previous line\n\t\t\t\tscope.parseNodePropertyContinued( line );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn this.allNodes;\n\n\t}\n\n\tparseNodeBegin( line, property ) {\n\n\t\tconst nodeName = property[ 1 ].trim().replace( /^\"/, '' ).replace( /\"$/, '' );\n\n\t\tconst nodeAttrs = property[ 2 ].split( ',' ).map( function ( attr ) {\n\n\t\t\treturn attr.trim().replace( /^\"/, '' ).replace( /\"$/, '' );\n\n\t\t} );\n\n\t\tconst node = { name: nodeName };\n\t\tconst attrs = this.parseNodeAttr( nodeAttrs );\n\n\t\tconst currentNode = this.getCurrentNode();\n\n\t\t// a top node\n\t\tif ( this.currentIndent === 0 ) {\n\n\t\t\tthis.allNodes.add( nodeName, node );\n\n\t\t} else { // a subnode\n\n\t\t\t// if the subnode already exists, append it\n\t\t\tif ( nodeName in currentNode ) {\n\n\t\t\t\t// special case Pose needs PoseNodes as an array\n\t\t\t\tif ( nodeName === 'PoseNode' ) {\n\n\t\t\t\t\tcurrentNode.PoseNode.push( node );\n\n\t\t\t\t} else if ( currentNode[ nodeName ].id !== undefined ) {\n\n\t\t\t\t\tcurrentNode[ nodeName ] = {};\n\t\t\t\t\tcurrentNode[ nodeName ][ currentNode[ nodeName ].id ] = currentNode[ nodeName ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( attrs.id !== '' ) currentNode[ nodeName ][ attrs.id ] = node;\n\n\t\t\t} else if ( typeof attrs.id === 'number' ) {\n\n\t\t\t\tcurrentNode[ nodeName ] = {};\n\t\t\t\tcurrentNode[ nodeName ][ attrs.id ] = node;\n\n\t\t\t} else if ( nodeName !== 'Properties70' ) {\n\n\t\t\t\tif ( nodeName === 'PoseNode' )\tcurrentNode[ nodeName ] = [ node ];\n\t\t\t\telse currentNode[ nodeName ] = node;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( typeof attrs.id === 'number' ) node.id = attrs.id;\n\t\tif ( attrs.name !== '' ) node.attrName = attrs.name;\n\t\tif ( attrs.type !== '' ) node.attrType = attrs.type;\n\n\t\tthis.pushStack( node );\n\n\t}\n\n\tparseNodeAttr( attrs ) {\n\n\t\tlet id = attrs[ 0 ];\n\n\t\tif ( attrs[ 0 ] !== '' ) {\n\n\t\t\tid = parseInt( attrs[ 0 ] );\n\n\t\t\tif ( isNaN( id ) ) {\n\n\t\t\t\tid = attrs[ 0 ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet name = '', type = '';\n\n\t\tif ( attrs.length > 1 ) {\n\n\t\t\tname = attrs[ 1 ].replace( /^(\\w+)::/, '' );\n\t\t\ttype = attrs[ 2 ];\n\n\t\t}\n\n\t\treturn { id: id, name: name, type: type };\n\n\t}\n\n\tparseNodeProperty( line, property, contentLine ) {\n\n\t\tlet propName = property[ 1 ].replace( /^\"/, '' ).replace( /\"$/, '' ).trim();\n\t\tlet propValue = property[ 2 ].replace( /^\"/, '' ).replace( /\"$/, '' ).trim();\n\n\t\t// for special case: base64 image data follows \"Content: ,\" line\n\t\t//\tContent: ,\n\t\t//\t \"/9j/4RDaRXhpZgAATU0A...\"\n\t\tif ( propName === 'Content' && propValue === ',' ) {\n\n\t\t\tpropValue = contentLine.replace( /\"/g, '' ).replace( /,$/, '' ).trim();\n\n\t\t}\n\n\t\tconst currentNode = this.getCurrentNode();\n\t\tconst parentName = currentNode.name;\n\n\t\tif ( parentName === 'Properties70' ) {\n\n\t\t\tthis.parseNodeSpecialProperty( line, propName, propValue );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Connections\n\t\tif ( propName === 'C' ) {\n\n\t\t\tconst connProps = propValue.split( ',' ).slice( 1 );\n\t\t\tconst from = parseInt( connProps[ 0 ] );\n\t\t\tconst to = parseInt( connProps[ 1 ] );\n\n\t\t\tlet rest = propValue.split( ',' ).slice( 3 );\n\n\t\t\trest = rest.map( function ( elem ) {\n\n\t\t\t\treturn elem.trim().replace( /^\"/, '' );\n\n\t\t\t} );\n\n\t\t\tpropName = 'connections';\n\t\t\tpropValue = [ from, to ];\n\t\t\tappend( propValue, rest );\n\n\t\t\tif ( currentNode[ propName ] === undefined ) {\n\n\t\t\t\tcurrentNode[ propName ] = [];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Node\n\t\tif ( propName === 'Node' ) currentNode.id = propValue;\n\n\t\t// connections\n\t\tif ( propName in currentNode && Array.isArray( currentNode[ propName ] ) ) {\n\n\t\t\tcurrentNode[ propName ].push( propValue );\n\n\t\t} else {\n\n\t\t\tif ( propName !== 'a' ) currentNode[ propName ] = propValue;\n\t\t\telse currentNode.a = propValue;\n\n\t\t}\n\n\t\tthis.setCurrentProp( currentNode, propName );\n\n\t\t// convert string to array, unless it ends in ',' in which case more will be added to it\n\t\tif ( propName === 'a' && propValue.slice( - 1 ) !== ',' ) {\n\n\t\t\tcurrentNode.a = parseNumberArray( propValue );\n\n\t\t}\n\n\t}\n\n\tparseNodePropertyContinued( line ) {\n\n\t\tconst currentNode = this.getCurrentNode();\n\n\t\tcurrentNode.a += line;\n\n\t\t// if the line doesn't end in ',' we have reached the end of the property value\n\t\t// so convert the string to an array\n\t\tif ( line.slice( - 1 ) !== ',' ) {\n\n\t\t\tcurrentNode.a = parseNumberArray( currentNode.a );\n\n\t\t}\n\n\t}\n\n\t// parse \"Property70\"\n\tparseNodeSpecialProperty( line, propName, propValue ) {\n\n\t\t// split this\n\t\t// P: \"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\",1,1,1\n\t\t// into array like below\n\t\t// [\"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\", \"1,1,1\" ]\n\t\tconst props = propValue.split( '\",' ).map( function ( prop ) {\n\n\t\t\treturn prop.trim().replace( /^\\\"/, '' ).replace( /\\s/, '_' );\n\n\t\t} );\n\n\t\tconst innerPropName = props[ 0 ];\n\t\tconst innerPropType1 = props[ 1 ];\n\t\tconst innerPropType2 = props[ 2 ];\n\t\tconst innerPropFlag = props[ 3 ];\n\t\tlet innerPropValue = props[ 4 ];\n\n\t\t// cast values where needed, otherwise leave as strings\n\t\tswitch ( innerPropType1 ) {\n\n\t\t\tcase 'int':\n\t\t\tcase 'enum':\n\t\t\tcase 'bool':\n\t\t\tcase 'ULongLong':\n\t\t\tcase 'double':\n\t\t\tcase 'Number':\n\t\t\tcase 'FieldOfView':\n\t\t\t\tinnerPropValue = parseFloat( innerPropValue );\n\t\t\t\tbreak;\n\n\t\t\tcase 'Color':\n\t\t\tcase 'ColorRGB':\n\t\t\tcase 'Vector3D':\n\t\t\tcase 'Lcl_Translation':\n\t\t\tcase 'Lcl_Rotation':\n\t\t\tcase 'Lcl_Scaling':\n\t\t\t\tinnerPropValue = parseNumberArray( innerPropValue );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t// CAUTION: these props must append to parent's parent\n\t\tthis.getPrevNode()[ innerPropName ] = {\n\n\t\t\t'type': innerPropType1,\n\t\t\t'type2': innerPropType2,\n\t\t\t'flag': innerPropFlag,\n\t\t\t'value': innerPropValue\n\n\t\t};\n\n\t\tthis.setCurrentProp( this.getPrevNode(), innerPropName );\n\n\t}\n\n}\n\n// Parse an FBX file in Binary format\nclass BinaryParser {\n\n\tparse( buffer ) {\n\n\t\tconst reader = new BinaryReader( buffer );\n\t\treader.skip( 23 ); // skip magic 23 bytes\n\n\t\tconst version = reader.getUint32();\n\n\t\tif ( version < 6400 ) {\n\n\t\t\tthrow new Error( 'THREE.FBXLoader: FBX version not supported, FileVersion: ' + version );\n\n\t\t}\n\n\t\tconst allNodes = new FBXTree();\n\n\t\twhile ( ! this.endOfContent( reader ) ) {\n\n\t\t\tconst node = this.parseNode( reader, version );\n\t\t\tif ( node !== null ) allNodes.add( node.name, node );\n\n\t\t}\n\n\t\treturn allNodes;\n\n\t}\n\n\t// Check if reader has reached the end of content.\n\tendOfContent( reader ) {\n\n\t\t// footer size: 160bytes + 16-byte alignment padding\n\t\t// - 16bytes: magic\n\t\t// - padding til 16-byte alignment (at least 1byte?)\n\t\t//\t(seems like some exporters embed fixed 15 or 16bytes?)\n\t\t// - 4bytes: magic\n\t\t// - 4bytes: version\n\t\t// - 120bytes: zero\n\t\t// - 16bytes: magic\n\t\tif ( reader.size() % 16 === 0 ) {\n\n\t\t\treturn ( ( reader.getOffset() + 160 + 16 ) & ~ 0xf ) >= reader.size();\n\n\t\t} else {\n\n\t\t\treturn reader.getOffset() + 160 + 16 >= reader.size();\n\n\t\t}\n\n\t}\n\n\t// recursively parse nodes until the end of the file is reached\n\tparseNode( reader, version ) {\n\n\t\tconst node = {};\n\n\t\t// The first three data sizes depends on version.\n\t\tconst endOffset = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();\n\t\tconst numProperties = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();\n\n\t\t( version >= 7500 ) ? reader.getUint64() : reader.getUint32(); // the returned propertyListLen is not used\n\n\t\tconst nameLen = reader.getUint8();\n\t\tconst name = reader.getString( nameLen );\n\n\t\t// Regards this node as NULL-record if endOffset is zero\n\t\tif ( endOffset === 0 ) return null;\n\n\t\tconst propertyList = [];\n\n\t\tfor ( let i = 0; i < numProperties; i ++ ) {\n\n\t\t\tpropertyList.push( this.parseProperty( reader ) );\n\n\t\t}\n\n\t\t// Regards the first three elements in propertyList as id, attrName, and attrType\n\t\tconst id = propertyList.length > 0 ? propertyList[ 0 ] : '';\n\t\tconst attrName = propertyList.length > 1 ? propertyList[ 1 ] : '';\n\t\tconst attrType = propertyList.length > 2 ? propertyList[ 2 ] : '';\n\n\t\t// check if this node represents just a single property\n\t\t// like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}\n\t\tnode.singleProperty = ( numProperties === 1 && reader.getOffset() === endOffset ) ? true : false;\n\n\t\twhile ( endOffset > reader.getOffset() ) {\n\n\t\t\tconst subNode = this.parseNode( reader, version );\n\n\t\t\tif ( subNode !== null ) this.parseSubNode( name, node, subNode );\n\n\t\t}\n\n\t\tnode.propertyList = propertyList; // raw property list used by parent\n\n\t\tif ( typeof id === 'number' ) node.id = id;\n\t\tif ( attrName !== '' ) node.attrName = attrName;\n\t\tif ( attrType !== '' ) node.attrType = attrType;\n\t\tif ( name !== '' ) node.name = name;\n\n\t\treturn node;\n\n\t}\n\n\tparseSubNode( name, node, subNode ) {\n\n\t\t// special case: child node is single property\n\t\tif ( subNode.singleProperty === true ) {\n\n\t\t\tconst value = subNode.propertyList[ 0 ];\n\n\t\t\tif ( Array.isArray( value ) ) {\n\n\t\t\t\tnode[ subNode.name ] = subNode;\n\n\t\t\t\tsubNode.a = value;\n\n\t\t\t} else {\n\n\t\t\t\tnode[ subNode.name ] = value;\n\n\t\t\t}\n\n\t\t} else if ( name === 'Connections' && subNode.name === 'C' ) {\n\n\t\t\tconst array = [];\n\n\t\t\tsubNode.propertyList.forEach( function ( property, i ) {\n\n\t\t\t\t// first Connection is FBX type (OO, OP, etc.). We'll discard these\n\t\t\t\tif ( i !== 0 ) array.push( property );\n\n\t\t\t} );\n\n\t\t\tif ( node.connections === undefined ) {\n\n\t\t\t\tnode.connections = [];\n\n\t\t\t}\n\n\t\t\tnode.connections.push( array );\n\n\t\t} else if ( subNode.name === 'Properties70' ) {\n\n\t\t\tconst keys = Object.keys( subNode );\n\n\t\t\tkeys.forEach( function ( key ) {\n\n\t\t\t\tnode[ key ] = subNode[ key ];\n\n\t\t\t} );\n\n\t\t} else if ( name === 'Properties70' && subNode.name === 'P' ) {\n\n\t\t\tlet innerPropName = subNode.propertyList[ 0 ];\n\t\t\tlet innerPropType1 = subNode.propertyList[ 1 ];\n\t\t\tconst innerPropType2 = subNode.propertyList[ 2 ];\n\t\t\tconst innerPropFlag = subNode.propertyList[ 3 ];\n\t\t\tlet innerPropValue;\n\n\t\t\tif ( innerPropName.indexOf( 'Lcl ' ) === 0 ) innerPropName = innerPropName.replace( 'Lcl ', 'Lcl_' );\n\t\t\tif ( innerPropType1.indexOf( 'Lcl ' ) === 0 ) innerPropType1 = innerPropType1.replace( 'Lcl ', 'Lcl_' );\n\n\t\t\tif ( innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf( 'Lcl_' ) === 0 ) {\n\n\t\t\t\tinnerPropValue = [\n\t\t\t\t\tsubNode.propertyList[ 4 ],\n\t\t\t\t\tsubNode.propertyList[ 5 ],\n\t\t\t\t\tsubNode.propertyList[ 6 ]\n\t\t\t\t];\n\n\t\t\t} else {\n\n\t\t\t\tinnerPropValue = subNode.propertyList[ 4 ];\n\n\t\t\t}\n\n\t\t\t// this will be copied to parent, see above\n\t\t\tnode[ innerPropName ] = {\n\n\t\t\t\t'type': innerPropType1,\n\t\t\t\t'type2': innerPropType2,\n\t\t\t\t'flag': innerPropFlag,\n\t\t\t\t'value': innerPropValue\n\n\t\t\t};\n\n\t\t} else if ( node[ subNode.name ] === undefined ) {\n\n\t\t\tif ( typeof subNode.id === 'number' ) {\n\n\t\t\t\tnode[ subNode.name ] = {};\n\t\t\t\tnode[ subNode.name ][ subNode.id ] = subNode;\n\n\t\t\t} else {\n\n\t\t\t\tnode[ subNode.name ] = subNode;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( subNode.name === 'PoseNode' ) {\n\n\t\t\t\tif ( ! Array.isArray( node[ subNode.name ] ) ) {\n\n\t\t\t\t\tnode[ subNode.name ] = [ node[ subNode.name ] ];\n\n\t\t\t\t}\n\n\t\t\t\tnode[ subNode.name ].push( subNode );\n\n\t\t\t} else if ( node[ subNode.name ][ subNode.id ] === undefined ) {\n\n\t\t\t\tnode[ subNode.name ][ subNode.id ] = subNode;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tparseProperty( reader ) {\n\n\t\tconst type = reader.getString( 1 );\n\t\tlet length;\n\n\t\tswitch ( type ) {\n\n\t\t\tcase 'C':\n\t\t\t\treturn reader.getBoolean();\n\n\t\t\tcase 'D':\n\t\t\t\treturn reader.getFloat64();\n\n\t\t\tcase 'F':\n\t\t\t\treturn reader.getFloat32();\n\n\t\t\tcase 'I':\n\t\t\t\treturn reader.getInt32();\n\n\t\t\tcase 'L':\n\t\t\t\treturn reader.getInt64();\n\n\t\t\tcase 'R':\n\t\t\t\tlength = reader.getUint32();\n\t\t\t\treturn reader.getArrayBuffer( length );\n\n\t\t\tcase 'S':\n\t\t\t\tlength = reader.getUint32();\n\t\t\t\treturn reader.getString( length );\n\n\t\t\tcase 'Y':\n\t\t\t\treturn reader.getInt16();\n\n\t\t\tcase 'b':\n\t\t\tcase 'c':\n\t\t\tcase 'd':\n\t\t\tcase 'f':\n\t\t\tcase 'i':\n\t\t\tcase 'l':\n\n\t\t\t\tconst arrayLength = reader.getUint32();\n\t\t\t\tconst encoding = reader.getUint32(); // 0: non-compressed, 1: compressed\n\t\t\t\tconst compressedLength = reader.getUint32();\n\n\t\t\t\tif ( encoding === 0 ) {\n\n\t\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t\tcase 'b':\n\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\treturn reader.getBooleanArray( arrayLength );\n\n\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\treturn reader.getFloat64Array( arrayLength );\n\n\t\t\t\t\t\tcase 'f':\n\t\t\t\t\t\t\treturn reader.getFloat32Array( arrayLength );\n\n\t\t\t\t\t\tcase 'i':\n\t\t\t\t\t\t\treturn reader.getInt32Array( arrayLength );\n\n\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\treturn reader.getInt64Array( arrayLength );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst data = fflate.unzlibSync( new Uint8Array( reader.getArrayBuffer( compressedLength ) ) );\n\t\t\t\tconst reader2 = new BinaryReader( data.buffer );\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'b':\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\treturn reader2.getBooleanArray( arrayLength );\n\n\t\t\t\t\tcase 'd':\n\t\t\t\t\t\treturn reader2.getFloat64Array( arrayLength );\n\n\t\t\t\t\tcase 'f':\n\t\t\t\t\t\treturn reader2.getFloat32Array( arrayLength );\n\n\t\t\t\t\tcase 'i':\n\t\t\t\t\t\treturn reader2.getInt32Array( arrayLength );\n\n\t\t\t\t\tcase 'l':\n\t\t\t\t\t\treturn reader2.getInt64Array( arrayLength );\n\n\t\t\t\t}\n\n\t\t\t\tbreak; // cannot happen but is required by the DeepScan\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'THREE.FBXLoader: Unknown property type ' + type );\n\n\t\t}\n\n\t}\n\n}\n\nclass BinaryReader {\n\n\tconstructor( buffer, littleEndian ) {\n\n\t\tthis.dv = new DataView( buffer );\n\t\tthis.offset = 0;\n\t\tthis.littleEndian = ( littleEndian !== undefined ) ? littleEndian : true;\n\t\tthis._textDecoder = new TextDecoder();\n\n\t}\n\n\tgetOffset() {\n\n\t\treturn this.offset;\n\n\t}\n\n\tsize() {\n\n\t\treturn this.dv.buffer.byteLength;\n\n\t}\n\n\tskip( length ) {\n\n\t\tthis.offset += length;\n\n\t}\n\n\t// seems like true/false representation depends on exporter.\n\t// true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)\n\t// then sees LSB.\n\tgetBoolean() {\n\n\t\treturn ( this.getUint8() & 1 ) === 1;\n\n\t}\n\n\tgetBooleanArray( size ) {\n\n\t\tconst a = [];\n\n\t\tfor ( let i = 0; i < size; i ++ ) {\n\n\t\t\ta.push( this.getBoolean() );\n\n\t\t}\n\n\t\treturn a;\n\n\t}\n\n\tgetUint8() {\n\n\t\tconst value = this.dv.getUint8( this.offset );\n\t\tthis.offset += 1;\n\t\treturn value;\n\n\t}\n\n\tgetInt16() {\n\n\t\tconst value = this.dv.getInt16( this.offset, this.littleEndian );\n\t\tthis.offset += 2;\n\t\treturn value;\n\n\t}\n\n\tgetInt32() {\n\n\t\tconst value = this.dv.getInt32( this.offset, this.littleEndian );\n\t\tthis.offset += 4;\n\t\treturn value;\n\n\t}\n\n\tgetInt32Array( size ) {\n\n\t\tconst a = [];\n\n\t\tfor ( let i = 0; i < size; i ++ ) {\n\n\t\t\ta.push( this.getInt32() );\n\n\t\t}\n\n\t\treturn a;\n\n\t}\n\n\tgetUint32() {\n\n\t\tconst value = this.dv.getUint32( this.offset, this.littleEndian );\n\t\tthis.offset += 4;\n\t\treturn value;\n\n\t}\n\n\t// JavaScript doesn't support 64-bit integer so calculate this here\n\t// 1 << 32 will return 1 so using multiply operation instead here.\n\t// There's a possibility that this method returns wrong value if the value\n\t// is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.\n\t// TODO: safely handle 64-bit integer\n\tgetInt64() {\n\n\t\tlet low, high;\n\n\t\tif ( this.littleEndian ) {\n\n\t\t\tlow = this.getUint32();\n\t\t\thigh = this.getUint32();\n\n\t\t} else {\n\n\t\t\thigh = this.getUint32();\n\t\t\tlow = this.getUint32();\n\n\t\t}\n\n\t\t// calculate negative value\n\t\tif ( high & 0x80000000 ) {\n\n\t\t\thigh = ~ high & 0xFFFFFFFF;\n\t\t\tlow = ~ low & 0xFFFFFFFF;\n\n\t\t\tif ( low === 0xFFFFFFFF ) high = ( high + 1 ) & 0xFFFFFFFF;\n\n\t\t\tlow = ( low + 1 ) & 0xFFFFFFFF;\n\n\t\t\treturn - ( high * 0x100000000 + low );\n\n\t\t}\n\n\t\treturn high * 0x100000000 + low;\n\n\t}\n\n\tgetInt64Array( size ) {\n\n\t\tconst a = [];\n\n\t\tfor ( let i = 0; i < size; i ++ ) {\n\n\t\t\ta.push( this.getInt64() );\n\n\t\t}\n\n\t\treturn a;\n\n\t}\n\n\t// Note: see getInt64() comment\n\tgetUint64() {\n\n\t\tlet low, high;\n\n\t\tif ( this.littleEndian ) {\n\n\t\t\tlow = this.getUint32();\n\t\t\thigh = this.getUint32();\n\n\t\t} else {\n\n\t\t\thigh = this.getUint32();\n\t\t\tlow = this.getUint32();\n\n\t\t}\n\n\t\treturn high * 0x100000000 + low;\n\n\t}\n\n\tgetFloat32() {\n\n\t\tconst value = this.dv.getFloat32( this.offset, this.littleEndian );\n\t\tthis.offset += 4;\n\t\treturn value;\n\n\t}\n\n\tgetFloat32Array( size ) {\n\n\t\tconst a = [];\n\n\t\tfor ( let i = 0; i < size; i ++ ) {\n\n\t\t\ta.push( this.getFloat32() );\n\n\t\t}\n\n\t\treturn a;\n\n\t}\n\n\tgetFloat64() {\n\n\t\tconst value = this.dv.getFloat64( this.offset, this.littleEndian );\n\t\tthis.offset += 8;\n\t\treturn value;\n\n\t}\n\n\tgetFloat64Array( size ) {\n\n\t\tconst a = [];\n\n\t\tfor ( let i = 0; i < size; i ++ ) {\n\n\t\t\ta.push( this.getFloat64() );\n\n\t\t}\n\n\t\treturn a;\n\n\t}\n\n\tgetArrayBuffer( size ) {\n\n\t\tconst value = this.dv.buffer.slice( this.offset, this.offset + size );\n\t\tthis.offset += size;\n\t\treturn value;\n\n\t}\n\n\tgetString( size ) {\n\n\t\tconst start = this.offset;\n\t\tlet a = new Uint8Array( this.dv.buffer, start, size );\n\n\t\tthis.skip( size );\n\n\t\tconst nullByte = a.indexOf( 0 );\n\t\tif ( nullByte >= 0 ) a = new Uint8Array( this.dv.buffer, start, nullByte );\n\n\t\treturn this._textDecoder.decode( a );\n\n\t}\n\n}\n\n// FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)\n// and BinaryParser( FBX Binary format)\nclass FBXTree {\n\n\tadd( key, val ) {\n\n\t\tthis[ key ] = val;\n\n\t}\n\n}\n\n// ************** UTILITY FUNCTIONS **************\n\nfunction isFbxFormatBinary( buffer ) {\n\n\tconst CORRECT = 'Kaydara\\u0020FBX\\u0020Binary\\u0020\\u0020\\0';\n\n\treturn buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString( buffer, 0, CORRECT.length );\n\n}\n\nfunction isFbxFormatASCII( text ) {\n\n\tconst CORRECT = [ 'K', 'a', 'y', 'd', 'a', 'r', 'a', '\\\\', 'F', 'B', 'X', '\\\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\\\', '\\\\' ];\n\n\tlet cursor = 0;\n\n\tfunction read( offset ) {\n\n\t\tconst result = text[ offset - 1 ];\n\t\ttext = text.slice( cursor + offset );\n\t\tcursor ++;\n\t\treturn result;\n\n\t}\n\n\tfor ( let i = 0; i < CORRECT.length; ++ i ) {\n\n\t\tconst num = read( 1 );\n\t\tif ( num === CORRECT[ i ] ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\treturn true;\n\n}\n\nfunction getFbxVersion( text ) {\n\n\tconst versionRegExp = /FBXVersion: (\\d+)/;\n\tconst match = text.match( versionRegExp );\n\n\tif ( match ) {\n\n\t\tconst version = parseInt( match[ 1 ] );\n\t\treturn version;\n\n\t}\n\n\tthrow new Error( 'THREE.FBXLoader: Cannot find the version number for the file given.' );\n\n}\n\n// Converts FBX ticks into real time seconds.\nfunction convertFBXTimeToSeconds( time ) {\n\n\treturn time / 46186158000;\n\n}\n\nconst dataArray = [];\n\n// extracts the data from the correct position in the FBX array based on indexing type\nfunction getData( polygonVertexIndex, polygonIndex, vertexIndex, infoObject ) {\n\n\tlet index;\n\n\tswitch ( infoObject.mappingType ) {\n\n\t\tcase 'ByPolygonVertex' :\n\t\t\tindex = polygonVertexIndex;\n\t\t\tbreak;\n\t\tcase 'ByPolygon' :\n\t\t\tindex = polygonIndex;\n\t\t\tbreak;\n\t\tcase 'ByVertice' :\n\t\t\tindex = vertexIndex;\n\t\t\tbreak;\n\t\tcase 'AllSame' :\n\t\t\tindex = infoObject.indices[ 0 ];\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tconsole.warn( 'THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType );\n\n\t}\n\n\tif ( infoObject.referenceType === 'IndexToDirect' ) index = infoObject.indices[ index ];\n\n\tconst from = index * infoObject.dataSize;\n\tconst to = from + infoObject.dataSize;\n\n\treturn slice( dataArray, infoObject.buffer, from, to );\n\n}\n\nconst tempEuler = new Euler();\nconst tempVec = new Vector3();\n\n// generate transformation from FBX transform data\n// ref: https://help.autodesk.com/view/FBX/2017/ENU/?guid=__files_GUID_10CDD63C_79C1_4F2D_BB28_AD2BE65A02ED_htm\n// ref: http://docs.autodesk.com/FBX/2014/ENU/FBX-SDK-Documentation/index.html?url=cpp_ref/_transformations_2main_8cxx-example.html,topicNumber=cpp_ref__transformations_2main_8cxx_example_htmlfc10a1e1-b18d-4e72-9dc0-70d0f1959f5e\nfunction generateTransform( transformData ) {\n\n\tconst lTranslationM = new Matrix4();\n\tconst lPreRotationM = new Matrix4();\n\tconst lRotationM = new Matrix4();\n\tconst lPostRotationM = new Matrix4();\n\n\tconst lScalingM = new Matrix4();\n\tconst lScalingPivotM = new Matrix4();\n\tconst lScalingOffsetM = new Matrix4();\n\tconst lRotationOffsetM = new Matrix4();\n\tconst lRotationPivotM = new Matrix4();\n\n\tconst lParentGX = new Matrix4();\n\tconst lParentLX = new Matrix4();\n\tconst lGlobalT = new Matrix4();\n\n\tconst inheritType = ( transformData.inheritType ) ? transformData.inheritType : 0;\n\n\tif ( transformData.translation ) lTranslationM.setPosition( tempVec.fromArray( transformData.translation ) );\n\n\tif ( transformData.preRotation ) {\n\n\t\tconst array = transformData.preRotation.map( MathUtils.degToRad );\n\t\tarray.push( transformData.eulerOrder || Euler.DEFAULT_ORDER );\n\t\tlPreRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );\n\n\t}\n\n\tif ( transformData.rotation ) {\n\n\t\tconst array = transformData.rotation.map( MathUtils.degToRad );\n\t\tarray.push( transformData.eulerOrder || Euler.DEFAULT_ORDER );\n\t\tlRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );\n\n\t}\n\n\tif ( transformData.postRotation ) {\n\n\t\tconst array = transformData.postRotation.map( MathUtils.degToRad );\n\t\tarray.push( transformData.eulerOrder || Euler.DEFAULT_ORDER );\n\t\tlPostRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );\n\t\tlPostRotationM.invert();\n\n\t}\n\n\tif ( transformData.scale ) lScalingM.scale( tempVec.fromArray( transformData.scale ) );\n\n\t// Pivots and offsets\n\tif ( transformData.scalingOffset ) lScalingOffsetM.setPosition( tempVec.fromArray( transformData.scalingOffset ) );\n\tif ( transformData.scalingPivot ) lScalingPivotM.setPosition( tempVec.fromArray( transformData.scalingPivot ) );\n\tif ( transformData.rotationOffset ) lRotationOffsetM.setPosition( tempVec.fromArray( transformData.rotationOffset ) );\n\tif ( transformData.rotationPivot ) lRotationPivotM.setPosition( tempVec.fromArray( transformData.rotationPivot ) );\n\n\t// parent transform\n\tif ( transformData.parentMatrixWorld ) {\n\n\t\tlParentLX.copy( transformData.parentMatrix );\n\t\tlParentGX.copy( transformData.parentMatrixWorld );\n\n\t}\n\n\tconst lLRM = lPreRotationM.clone().multiply( lRotationM ).multiply( lPostRotationM );\n\t// Global Rotation\n\tconst lParentGRM = new Matrix4();\n\tlParentGRM.extractRotation( lParentGX );\n\n\t// Global Shear*Scaling\n\tconst lParentTM = new Matrix4();\n\tlParentTM.copyPosition( lParentGX );\n\n\tconst lParentGRSM = lParentTM.clone().invert().multiply( lParentGX );\n\tconst lParentGSM = lParentGRM.clone().invert().multiply( lParentGRSM );\n\tconst lLSM = lScalingM;\n\n\tconst lGlobalRS = new Matrix4();\n\n\tif ( inheritType === 0 ) {\n\n\t\tlGlobalRS.copy( lParentGRM ).multiply( lLRM ).multiply( lParentGSM ).multiply( lLSM );\n\n\t} else if ( inheritType === 1 ) {\n\n\t\tlGlobalRS.copy( lParentGRM ).multiply( lParentGSM ).multiply( lLRM ).multiply( lLSM );\n\n\t} else {\n\n\t\tconst lParentLSM = new Matrix4().scale( new Vector3().setFromMatrixScale( lParentLX ) );\n\t\tconst lParentLSM_inv = lParentLSM.clone().invert();\n\t\tconst lParentGSM_noLocal = lParentGSM.clone().multiply( lParentLSM_inv );\n\n\t\tlGlobalRS.copy( lParentGRM ).multiply( lLRM ).multiply( lParentGSM_noLocal ).multiply( lLSM );\n\n\t}\n\n\tconst lRotationPivotM_inv = lRotationPivotM.clone().invert();\n\tconst lScalingPivotM_inv = lScalingPivotM.clone().invert();\n\t// Calculate the local transform matrix\n\tlet lTransform = lTranslationM.clone().multiply( lRotationOffsetM ).multiply( lRotationPivotM ).multiply( lPreRotationM ).multiply( lRotationM ).multiply( lPostRotationM ).multiply( lRotationPivotM_inv ).multiply( lScalingOffsetM ).multiply( lScalingPivotM ).multiply( lScalingM ).multiply( lScalingPivotM_inv );\n\n\tconst lLocalTWithAllPivotAndOffsetInfo = new Matrix4().copyPosition( lTransform );\n\n\tconst lGlobalTranslation = lParentGX.clone().multiply( lLocalTWithAllPivotAndOffsetInfo );\n\tlGlobalT.copyPosition( lGlobalTranslation );\n\n\tlTransform = lGlobalT.clone().multiply( lGlobalRS );\n\n\t// from global to local\n\tlTransform.premultiply( lParentGX.invert() );\n\n\treturn lTransform;\n\n}\n\n// Returns the three.js intrinsic Euler order corresponding to FBX extrinsic Euler order\n// ref: http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html\nfunction getEulerOrder( order ) {\n\n\torder = order || 0;\n\n\tconst enums = [\n\t\t'ZYX', // -> XYZ extrinsic\n\t\t'YZX', // -> XZY extrinsic\n\t\t'XZY', // -> YZX extrinsic\n\t\t'ZXY', // -> YXZ extrinsic\n\t\t'YXZ', // -> ZXY extrinsic\n\t\t'XYZ', // -> ZYX extrinsic\n\t\t//'SphericXYZ', // not possible to support\n\t];\n\n\tif ( order === 6 ) {\n\n\t\tconsole.warn( 'THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.' );\n\t\treturn enums[ 0 ];\n\n\t}\n\n\treturn enums[ order ];\n\n}\n\n// Parses comma separated list of numbers and returns them an array.\n// Used internally by the TextParser\nfunction parseNumberArray( value ) {\n\n\tconst array = value.split( ',' ).map( function ( val ) {\n\n\t\treturn parseFloat( val );\n\n\t} );\n\n\treturn array;\n\n}\n\nfunction convertArrayBufferToString( buffer, from, to ) {\n\n\tif ( from === undefined ) from = 0;\n\tif ( to === undefined ) to = buffer.byteLength;\n\n\treturn new TextDecoder().decode( new Uint8Array( buffer, from, to ) );\n\n}\n\nfunction append( a, b ) {\n\n\tfor ( let i = 0, j = a.length, l = b.length; i < l; i ++, j ++ ) {\n\n\t\ta[ j ] = b[ i ];\n\n\t}\n\n}\n\nfunction slice( a, b, from, to ) {\n\n\tfor ( let i = from, j = 0; i < to; i ++, j ++ ) {\n\n\t\ta[ j ] = b[ i ];\n\n\t}\n\n\treturn a;\n\n}\n\n// inject array a2 into array a1 at index\nfunction inject( a1, index, a2 ) {\n\n\treturn a1.slice( 0, index ).concat( a2 ).concat( a1.slice( index ) );\n\n}\n\nexport { FBXLoader };\n","/*!\nfflate - fast JavaScript compression/decompression\n<https://101arrowz.github.io/fflate>\nLicensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE\nversion 0.6.9\n*/\n\n// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\nvar ch2 = {};\nvar durl = function (c) { return URL.createObjectURL(new Blob([c], { type: 'text/javascript' })); };\nvar cwk = function (u) { return new Worker(u); };\ntry {\n    URL.revokeObjectURL(durl(''));\n}\ncatch (e) {\n    // We're in Deno or a very old browser\n    durl = function (c) { return 'data:application/javascript;charset=UTF-8,' + encodeURI(c); };\n    // If Deno, this is necessary; if not, this changes nothing\n    cwk = function (u) { return new Worker(u, { type: 'module' }); };\n}\nvar wk = (function (c, id, msg, transfer, cb) {\n    var w = cwk(ch2[id] || (ch2[id] = durl(c)));\n    w.onerror = function (e) { return cb(e.error, null); };\n    w.onmessage = function (e) { return cb(null, e.data); };\n    w.postMessage(msg, transfer);\n    return w;\n});\n\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;\n// fixed length extra bits\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n// fixed distance extra bits\n// see fleb note\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n// code length index map\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new u32(b[30]);\n    for (var i = 1; i < 30; ++i) {\n        for (var j = b[i]; j < b[i + 1]; ++j) {\n            r[j] = ((j - b[i]) << 5) | i;\n        }\n    }\n    return [b, r];\n};\nvar _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n    // reverse table algorithm from SO\n    var x = ((i & 0xAAAA) >>> 1) | ((i & 0x5555) << 1);\n    x = ((x & 0xCCCC) >>> 2) | ((x & 0x3333) << 2);\n    x = ((x & 0xF0F0) >>> 4) | ((x & 0x0F0F) << 4);\n    rev[i] = (((x & 0xFF00) >>> 8) | ((x & 0x00FF) << 8)) >>> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = (function (cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i)\n        ++l[cd[i] - 1];\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 0; i < mb; ++i) {\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for (i = 0; i < s; ++i) {\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = (i << 4) | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >>> rvb] = sv;\n                }\n            }\n        }\n    }\n    else {\n        co = new u16(s);\n        for (i = 0; i < s; ++i) {\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);\n            }\n        }\n    }\n    return co;\n});\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n    flt[i] = 8;\nfor (var i = 144; i < 256; ++i)\n    flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n    flt[i] = 7;\nfor (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function (a) {\n    var m = a[0];\n    for (var i = 1; i < a.length; ++i) {\n        if (a[i] > m)\n            m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function (d, p, m) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function (d, p) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\n};\n// get end of byte\nvar shft = function (p) { return ((p / 8) | 0) + (p & 7 && 1); };\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    // can't use .constructor in case user-supplied\n    var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);\n    n.set(v.subarray(s, e));\n    return n;\n};\n// expands raw DEFLATE data\nvar inflt = function (dat, buf, st) {\n    // source length\n    var sl = dat.length;\n    if (!sl || (st && !st.l && sl < 5))\n        return buf || new u8(0);\n    // have to estimate size\n    var noBuf = !buf || st;\n    // no state\n    var noSt = !st || st.i;\n    if (!st)\n        st = {};\n    // Assumes roughly 33% compression ratio average\n    if (!buf)\n        buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function (l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            st.f = final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                if (t > sl) {\n                    if (noSt)\n                        throw 'unexpected EOF';\n                    break;\n                }\n                // ensure size\n                if (noBuf)\n                    cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8;\n                continue;\n            }\n            else if (type == 1)\n                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for (var i = 0; i < hcLen; ++i) {\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for (var i = 0; i < tl;) {\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >>> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    }\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16)\n                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17)\n                            n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18)\n                            n = 11 + bits(dat, pos, 127), pos += 7;\n                        while (n--)\n                            ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            }\n            else\n                throw 'invalid block type';\n            if (pos > tbts) {\n                if (noSt)\n                    throw 'unexpected EOF';\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17;\n        if (noBuf)\n            cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for (;; lpos = pos) {\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt)\n                    throw 'unexpected EOF';\n                break;\n            }\n            if (!c)\n                throw 'invalid length/literal';\n            if (sym < 256)\n                buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            }\n            else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;\n                if (!d)\n                    throw 'invalid distance';\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt)\n                        throw 'unexpected EOF';\n                    break;\n                }\n                if (noBuf)\n                    cbuf(bt + 131072);\n                var end = bt + add;\n                for (; bt < end; bt += 4) {\n                    buf[bt] = buf[bt - dt];\n                    buf[bt + 1] = buf[bt + 1 - dt];\n                    buf[bt + 2] = buf[bt + 2 - dt];\n                    buf[bt + 3] = buf[bt + 3 - dt];\n                }\n                bt = end;\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt;\n        if (lm)\n            final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    return bt == buf.length ? buf : slc(buf, 0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n    d[o + 2] |= v >>> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function (d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for (var i = 0; i < d.length; ++i) {\n        if (d[i])\n            t.push({ s: i, f: d[i] });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s)\n        return [et, 0];\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return [v, 1];\n    }\n    t.sort(function (a, b) { return a.f - b.f; });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({ s: -1, f: 25001 });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while (i1 != s - 1) {\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };\n    }\n    var maxSym = t2[0].s;\n    for (var i = 1; i < s; ++i) {\n        if (t2[i].s > maxSym)\n            maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });\n        for (; i < s; ++i) {\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << (mbt - tr[i2_1]));\n                tr[i2_1] = mb;\n            }\n            else\n                break;\n        }\n        dt >>>= lft;\n        while (dt > 0) {\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb)\n                dt -= 1 << (mb - tr[i2_2]++ - 1);\n            else\n                ++i;\n        }\n        for (; i >= 0 && dt; --i) {\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return [new u8(tr), mbt];\n};\n// get the max length and assign length codes\nvar ln = function (n, l, d) {\n    return n.s == -1\n        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n        : (l[n.s] = d);\n};\n// length codes generation\nvar lc = function (c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while (s && !c[--s])\n        ;\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function (v) { cl[cli++] = v; };\n    for (var i = 1; i <= s; ++i) {\n        if (c[i] == cln && i != s)\n            ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for (; cls > 138; cls -= 138)\n                    w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n                    cls = 0;\n                }\n            }\n            else if (cls > 3) {\n                w(cln), --cls;\n                for (; cls > 6; cls -= 6)\n                    w(8304);\n                if (cls > 2)\n                    w(((cls - 3) << 5) | 8208), cls = 0;\n            }\n            while (cls--)\n                w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return [cl.subarray(0, cli), s];\n};\n// calculate the length of output from tree, code lengths\nvar clen = function (cf, cl) {\n    var l = 0;\n    for (var i = 0; i < cl.length; ++i)\n        l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function (out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >>> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for (var i = 0; i < s; ++i)\n        out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1];\n    var _b = hTree(df, 15), ddt = _b[0], mdb = _b[1];\n    var _c = lc(dlt), lclt = _c[0], nlc = _c[1];\n    var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];\n    var lcfreq = new u16(19);\n    for (var i = 0; i < lclt.length; ++i)\n        lcfreq[lclt[i] & 31]++;\n    for (var i = 0; i < lcdt.length; ++i)\n        lcfreq[lcdt[i] & 31]++;\n    var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];\n    var nlcc = 19;\n    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\n        ;\n    var flen = (bl + 5) << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);\n    if (flen <= ftlen && flen <= dtlen)\n        return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for (var i = 0; i < nlcc; ++i)\n            wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [lclt, lcdt];\n        for (var it = 0; it < 2; ++it) {\n            var clct = lcts[it];\n            for (var i = 0; i < clct.length; ++i) {\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15)\n                    wbits(out, p, (clct[i] >>> 5) & 127), p += clct[i] >>> 12;\n            }\n        }\n    }\n    else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for (var i = 0; i < li; ++i) {\n        if (syms[i] > 255) {\n            var len = (syms[i] >>> 18) & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7)\n                wbits(out, p, (syms[i] >>> 23) & 31), p += fleb[len];\n            var dst = syms[i] & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3)\n                wbits16(out, p, (syms[i] >>> 5) & 8191), p += fdeb[dst];\n        }\n        else {\n            wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function (dat, lvl, plvl, pre, post, lst) {\n    var s = dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var pos = 0;\n    if (!lvl || s < 8) {\n        for (var i = 0; i <= s; i += 65535) {\n            // end\n            var e = i + 65535;\n            if (e < s) {\n                // write full block\n                pos = wfblk(w, pos, dat.subarray(i, e));\n            }\n            else {\n                // write final block\n                w[i] = lst;\n                pos = wfblk(w, pos, dat.subarray(i, s));\n            }\n        }\n    }\n    else {\n        var opt = deo[lvl - 1];\n        var n = opt >>> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = new u16(32768), head = new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new u32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index  l/lind  waitdx  bitpos\n        var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;\n        for (; i < s; ++i) {\n            // hash value\n            // deopt when i > s - 3 - at end, deopt acceptable\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && rem > 423) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for (var j = 0; j < 286; ++j)\n                        lf[j] = 0;\n                    for (var j = 0; j < 30; ++j)\n                        df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = (imod - pimod) & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while (dif <= maxd && --ch_1 && imod != pimod) {\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)\n                                ;\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn)\n                                    break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for (var j = 0; j < mmd; ++j) {\n                                    var ti = (i - dif + j + 32768) & 32767;\n                                    var pti = prev[ti];\n                                    var cd = (ti - pti + 32768) & 32767;\n                                    if (cd > md)\n                                        md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += (imod - pimod + 32768) & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one Uint32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                }\n                else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        // this is the easiest way to avoid needing to maintain state\n        if (!lst && pos & 7)\n            pos = wfblk(w, pos + 1, et);\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ (function () {\n    var t = new u32(256);\n    for (var i = 0; i < 256; ++i) {\n        var c = i, k = 9;\n        while (--k)\n            c = ((c & 1) && 0xEDB88320) ^ (c >>> 1);\n        t[i] = c;\n    }\n    return t;\n})();\n// CRC32\nvar crc = function () {\n    var c = -1;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var cr = c;\n            for (var i = 0; i < d.length; ++i)\n                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n            c = cr;\n        },\n        d: function () { return ~c; }\n    };\n};\n// Alder32\nvar adler = function () {\n    var a = 1, b = 0;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length;\n            for (var i = 0; i != l;) {\n                var e = Math.min(i + 2655, l);\n                for (; i < e; ++i)\n                    m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function () {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | (a >>> 8) << 16 | (b & 255) << 8 | (b >>> 8);\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function (dat, opt, pre, post, st) {\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : (12 + opt.mem), pre, post, !st);\n};\n// Walmart object spread\nvar mrg = function (a, b) {\n    var o = {};\n    for (var k in a)\n        o[k] = a[k];\n    for (var k in b)\n        o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function (fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/ /g, '').split(',');\n    for (var i = 0; i < dt.length; ++i) {\n        var v = dt[i], k = ks[i];\n        if (typeof v == 'function') {\n            fnStr += ';' + k + '=';\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf('[native code]') != -1) {\n                    var spInd = st_1.indexOf(' ', 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));\n                }\n                else {\n                    fnStr += st_1;\n                    for (var t in v.prototype)\n                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\n                }\n            }\n            else\n                fnStr += st_1;\n        }\n        else\n            td[k] = v;\n    }\n    return [fnStr, td];\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function (v) {\n    var tl = [];\n    for (var k in v) {\n        if (v[k] instanceof u8 || v[k] instanceof u16 || v[k] instanceof u32)\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function (fns, init, id, cb) {\n    var _a;\n    if (!ch[id]) {\n        var fnStr = '', td_1 = {}, m = fns.length - 1;\n        for (var i = 0; i < m; ++i)\n            _a = wcln(fns[i], fnStr, td_1), fnStr = _a[0], td_1 = _a[1];\n        ch[id] = wcln(fns[m], fnStr, td_1);\n    }\n    var td = mrg({}, ch[id][1]);\n    return wk(ch[id][0] + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function () { return [u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, hMap, max, bits, bits16, shft, slc, inflt, inflateSync, pbf, gu8]; };\nvar bDflt = function () { return [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };\n// gzip extra\nvar gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };\n// gunzip extra\nvar guze = function () { return [gzs, gzl]; };\n// zlib extra\nvar zle = function () { return [zlh, wbytes, adler]; };\n// unzlib extra\nvar zule = function () { return [zlv]; };\n// post buf\nvar pbf = function (msg) { return postMessage(msg, [msg.buffer]); };\n// get u8\nvar gu8 = function (o) { return o && o.size && new u8(o.size); };\n// async helper\nvar cbify = function (dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function (err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n    return function () { w.terminate(); };\n};\n// auto stream\nvar astrm = function (strm) {\n    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };\n    return function (ev) { return strm.push(ev.data[0], ev.data[1]); };\n};\n// async stream attach\nvar astrmify = function (fns, strm, opts, init, id) {\n    var t;\n    var w = wrkr(fns, init, id, function (err, dat) {\n        if (err)\n            w.terminate(), strm.ondata.call(strm, err);\n        else {\n            if (dat[1])\n                w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.push = function (d, f) {\n        if (t)\n            throw 'stream finished';\n        if (!strm.ondata)\n            throw 'no stream handler';\n        w.postMessage([d, t = f], [d.buffer]);\n    };\n    strm.terminate = function () { w.terminate(); };\n};\n// read 2 bytes\nvar b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };\n// read 4 bytes\nvar b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };\nvar b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };\n// write bytes\nvar wbytes = function (d, b, v) {\n    for (; v; ++b)\n        d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function (c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0)\n        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for (var i = 0; i <= fn.length; ++i)\n            c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function (d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n        throw 'invalid gzip data';\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n        st += d[10] | (d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n        ;\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function (d) {\n    var l = d.length;\n    return ((d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16) | (d[l - 1] << 24)) >>> 0;\n};\n// gzip header length\nvar gzhl = function (o) { return 10 + ((o.filename && (o.filename.length + 1)) || 0); };\n// zlib header\nvar zlh = function (c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = (fl << 6) | (fl ? (32 - 2 * fl) : 1);\n};\n// zlib valid\nvar zlv = function (d) {\n    if ((d[0] & 15) != 8 || (d[0] >>> 4) > 7 || ((d[0] << 8 | d[1]) % 31))\n        throw 'invalid zlib data';\n    if (d[1] & 32)\n        throw 'invalid zlib data: preset dictionaries not supported';\n};\nfunction AsyncCmpStrm(opts, cb) {\n    if (!cb && typeof opts == 'function')\n        cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n// zlib footer: -4 to -0 is Adler32\n/**\n * Streaming DEFLATE compression\n */\nvar Deflate = /*#__PURE__*/ (function () {\n    function Deflate(opts, cb) {\n        if (!cb && typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n    }\n    Deflate.prototype.p = function (c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, !f), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Deflate.prototype.push = function (chunk, final) {\n        if (this.d)\n            throw 'stream finished';\n        if (!this.ondata)\n            throw 'no stream handler';\n        this.d = final;\n        this.p(chunk, final || false);\n    };\n    return Deflate;\n}());\nexport { Deflate };\n/**\n * Asynchronous streaming DEFLATE compression\n */\nvar AsyncDeflate = /*#__PURE__*/ (function () {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function () { return [astrm, Deflate]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6);\n    }\n    return AsyncDeflate;\n}());\nexport { AsyncDeflate };\nexport function deflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nexport function deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */\nvar Inflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an inflation stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Inflate(cb) {\n        this.s = {};\n        this.p = new u8(0);\n        this.ondata = cb;\n    }\n    Inflate.prototype.e = function (c) {\n        if (this.d)\n            throw 'stream finished';\n        if (!this.ondata)\n            throw 'no stream handler';\n        var l = this.p.length;\n        var n = new u8(l + c.length);\n        n.set(this.p), n.set(c, l), this.p = n;\n    };\n    Inflate.prototype.c = function (final) {\n        this.d = this.s.i = final || false;\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.o, this.s);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */\n    Inflate.prototype.push = function (chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}());\nexport { Inflate };\n/**\n * Asynchronous streaming DEFLATE decompression\n */\nvar AsyncInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous inflation stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncInflate(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            function () { return [astrm, Inflate]; }\n        ], this, 0, function () {\n            var strm = new Inflate();\n            onmessage = astrm(strm);\n        }, 7);\n    }\n    return AsyncInflate;\n}());\nexport { AsyncInflate };\nexport function inflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt\n    ], function (ev) { return pbf(inflateSync(ev.data[0], gu8(ev.data[1]))); }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function inflateSync(data, out) {\n    return inflt(data, out);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */\nvar Gzip = /*#__PURE__*/ (function () {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gzip.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function (c, f) {\n        this.c.p(c);\n        this.l += c.length;\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);\n        if (this.v)\n            gzh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    return Gzip;\n}());\nexport { Gzip };\n/**\n * Asynchronous streaming GZIP compression\n */\nvar AsyncGzip = /*#__PURE__*/ (function () {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function () { return [astrm, Deflate, Gzip]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8);\n    }\n    return AsyncGzip;\n}());\nexport { AsyncGzip };\nexport function gzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function () { return [gzipSync]; }\n    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */\nexport function gzipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming GZIP decompression\n */\nvar Gunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a GUNZIP stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Gunzip(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gunzip.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            var s = this.p.length > 3 ? gzs(this.p) : 4;\n            if (s >= this.p.length && !final)\n                return;\n            this.p = this.p.subarray(s), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 8)\n                throw 'invalid gzip stream';\n            this.p = this.p.subarray(0, -8);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Gunzip;\n}());\nexport { Gunzip };\n/**\n * Asynchronous streaming GZIP decompression\n */\nvar AsyncGunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous GUNZIP stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncGunzip(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            guze,\n            function () { return [astrm, Inflate, Gunzip]; }\n        ], this, 0, function () {\n            var strm = new Gunzip();\n            onmessage = astrm(strm);\n        }, 9);\n    }\n    return AsyncGunzip;\n}());\nexport { AsyncGunzip };\nexport function gunzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function () { return [gunzipSync]; }\n    ], function (ev) { return pbf(gunzipSync(ev.data[0])); }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param out Where to write the data. GZIP already encodes the output size, so providing this doesn't save memory.\n * @returns The decompressed version of the data\n */\nexport function gunzipSync(data, out) {\n    return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));\n}\n/**\n * Streaming Zlib compression\n */\nvar Zlib = /*#__PURE__*/ (function () {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Zlib.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function (c, f) {\n        this.c.p(c);\n        var raw = dopt(c, this.o, this.v && 2, f && 4, !f);\n        if (this.v)\n            zlh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    return Zlib;\n}());\nexport { Zlib };\n/**\n * Asynchronous streaming Zlib compression\n */\nvar AsyncZlib = /*#__PURE__*/ (function () {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function () { return [astrm, Deflate, Zlib]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10);\n    }\n    return AsyncZlib;\n}());\nexport { AsyncZlib };\nexport function zlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function () { return [zlibSync]; }\n    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\nexport function zlibSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */\nvar Unzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates a Zlib decompression stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Unzlib(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzlib.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 2 && !final)\n                return;\n            this.p = this.p.subarray(2), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4)\n                throw 'invalid zlib stream';\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}());\nexport { Unzlib };\n/**\n * Asynchronous streaming Zlib decompression\n */\nvar AsyncUnzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous Zlib decompression stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncUnzlib(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            zule,\n            function () { return [astrm, Inflate, Unzlib]; }\n        ], this, 0, function () {\n            var strm = new Unzlib();\n            onmessage = astrm(strm);\n        }, 11);\n    }\n    return AsyncUnzlib;\n}());\nexport { AsyncUnzlib };\nexport function unzlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function () { return [unzlibSync]; }\n    ], function (ev) { return pbf(unzlibSync(ev.data[0], gu8(ev.data[1]))); }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function unzlibSync(data, out) {\n    return inflt((zlv(data), data.subarray(2, -4)), out);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzip as compress, AsyncGzip as AsyncCompress };\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzipSync as compressSync, Gzip as Compress };\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar Decompress = /*#__PURE__*/ (function () {\n    /**\n     * Creates a decompression stream\n     * @param cb The callback to call whenever data is decompressed\n     */\n    function Decompress(cb) {\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Decompress.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no stream handler';\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            }\n            else\n                this.p = chunk;\n            if (this.p.length > 2) {\n                var _this_1 = this;\n                var cb = function () { _this_1.ondata.apply(_this_1, arguments); };\n                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\n                    ? new this.G(cb)\n                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\n                        ? new this.I(cb)\n                        : new this.Z(cb);\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        }\n        else\n            this.s.push(chunk, final);\n    };\n    return Decompress;\n}());\nexport { Decompress };\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar AsyncDecompress = /*#__PURE__*/ (function () {\n    /**\n   * Creates an asynchronous decompression stream\n   * @param cb The callback to call whenever data is decompressed\n   */\n    function AsyncDecompress(cb) {\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncDecompress.prototype.push = function (chunk, final) {\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}());\nexport { AsyncDecompress };\nexport function decompress(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzip(data, opts, cb)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflate(data, opts, cb)\n            : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function decompressSync(data, out) {\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzipSync(data, out)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflateSync(data, out)\n            : unzlibSync(data, out);\n}\n// flatten a directory structure\nvar fltn = function (d, p, t, o) {\n    for (var k in d) {\n        var val = d[k], n = p + k;\n        if (val instanceof u8)\n            t[n] = [val, o];\n        else if (Array.isArray(val))\n            t[n] = [val[0], mrg(o, val[1])];\n        else\n            fltn(val, n + '/', t, o);\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, { stream: true });\n    tds = 1;\n}\ncatch (e) { }\n// decode UTF8\nvar dutf8 = function (d) {\n    for (var r = '', i = 0;;) {\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length)\n            return [r, slc(d, i - 1)];\n        if (!eb)\n            r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,\n                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\n        }\n        else if (eb & 1)\n            r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));\n        else\n            r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */\nvar DecodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */\n    function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds)\n            this.t = new TextDecoder();\n        else\n            this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    DecodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no callback';\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, { stream: true }), final);\n            if (final) {\n                if (this.t.decode().length)\n                    throw 'invalid utf-8 data';\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p)\n            throw 'stream finished';\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), ch = _a[0], np = _a[1];\n        if (final) {\n            if (np.length)\n                throw 'invalid utf-8 data';\n            this.p = null;\n        }\n        else\n            this.p = np;\n        this.ondata(ch, final);\n    };\n    return DecodeUTF8;\n}());\nexport { DecodeUTF8 };\n/**\n * Streaming UTF-8 encoding\n */\nvar EncodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */\n    function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */\n    EncodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no callback';\n        if (this.d)\n            throw 'stream finished';\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}());\nexport { EncodeUTF8 };\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nexport function strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for (var i = 0; i < str.length; ++i)\n            ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te)\n        return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function (v) { ar[ai++] = v; };\n    for (var i = 0; i < l; ++i) {\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + ((l - i) << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1)\n            w(c);\n        else if (c < 2048)\n            w(192 | (c >> 6)), w(128 | (c & 63));\n        else if (c > 55295 && c < 57344)\n            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\n                w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n        else\n            w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\nexport function strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = '';\n        for (var i = 0; i < dat.length; i += 16384)\n            r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    }\n    else if (td)\n        return td.decode(dat);\n    else {\n        var _a = dutf8(dat), out = _a[0], ext = _a[1];\n        if (ext.length)\n            throw 'invalid utf-8 data';\n        return out;\n    }\n}\n;\n// deflate bit flag\nvar dbf = function (l) { return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0; };\n// skip local zip header\nvar slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };\n// read zip header\nvar zh = function (d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n};\n// read zip64 extra field\nvar z64e = function (d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n        ;\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\n};\n// extra field length\nvar exfl = function (ex) {\n    var le = 0;\n    if (ex) {\n        for (var k in ex) {\n            var l = ex[k].length;\n            if (l > 65535)\n                throw 'extra field too long';\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function (d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null)\n        d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = (f.flag << 1) | (c == null && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119)\n        throw 'date not in range 1980-2099';\n    wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >>> 1)), b += 4;\n    if (c != null) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for (var k in ex) {\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col)\n        d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function (o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */\nvar ZipPassThrough = /*#__PURE__*/ (function () {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */\n    function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.process = function (chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no callback - add to ZIP archive before pushing';\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final)\n            this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}());\nexport { ZipPassThrough };\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */\nvar ZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function ZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function (chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}());\nexport { ZipDeflate };\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */\nvar AsyncZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function AsyncZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function (err, dat, final) {\n            _this_1.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function (chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}());\nexport { AsyncZipDeflate };\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */\nvar Zip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */\n    function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */\n    Zip.prototype.add = function (file) {\n        var _this_1 = this;\n        if (this.d & 2)\n            throw 'stream finished';\n        var f = strToU8(file.filename), fl = f.length;\n        var com = file.comment, o = com && strToU8(com);\n        var u = fl != file.filename.length || (o && (com.length != o.length));\n        var hl = fl + exfl(file.extra) + 30;\n        if (fl > 65535)\n            throw 'filename too long';\n        var header = new u8(hl);\n        wzh(header, 0, file, f, u);\n        var chks = [header];\n        var pAll = function () {\n            for (var _i = 0, chks_1 = chks; _i < chks_1.length; _i++) {\n                var chk = chks_1[_i];\n                _this_1.ondata(null, chk, false);\n            }\n            chks = [];\n        };\n        var tr = this.d;\n        this.d = 0;\n        var ind = this.u.length;\n        var uf = mrg(file, {\n            f: f,\n            u: u,\n            o: o,\n            t: function () {\n                if (file.terminate)\n                    file.terminate();\n            },\n            r: function () {\n                pAll();\n                if (tr) {\n                    var nxt = _this_1.u[ind + 1];\n                    if (nxt)\n                        nxt.r();\n                    else\n                        _this_1.d = 1;\n                }\n                tr = 1;\n            }\n        });\n        var cl = 0;\n        file.ondata = function (err, dat, final) {\n            if (err) {\n                _this_1.ondata(err, dat, final);\n                _this_1.terminate();\n            }\n            else {\n                cl += dat.length;\n                chks.push(dat);\n                if (final) {\n                    var dd = new u8(16);\n                    wbytes(dd, 0, 0x8074B50);\n                    wbytes(dd, 4, file.crc);\n                    wbytes(dd, 8, cl);\n                    wbytes(dd, 12, file.size);\n                    chks.push(dd);\n                    uf.c = cl, uf.b = hl + cl + 16, uf.crc = file.crc, uf.size = file.size;\n                    if (tr)\n                        uf.r();\n                    tr = 1;\n                }\n                else if (tr)\n                    pAll();\n            }\n        };\n        this.u.push(uf);\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */\n    Zip.prototype.end = function () {\n        var _this_1 = this;\n        if (this.d & 2) {\n            if (this.d & 1)\n                throw 'stream finishing';\n            throw 'stream finished';\n        }\n        if (this.d)\n            this.e();\n        else\n            this.u.push({\n                r: function () {\n                    if (!(_this_1.d & 1))\n                        return;\n                    _this_1.u.splice(-1, 1);\n                    _this_1.e();\n                },\n                t: function () { }\n            });\n        this.d = 3;\n    };\n    Zip.prototype.e = function () {\n        var bt = 0, l = 0, tl = 0;\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for (var _b = 0, _c = this.u; _b < _c.length; _b++) {\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, f.c, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */\n    Zip.prototype.terminate = function () {\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}());\nexport { Zip };\nexport function zip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    var r = {};\n    fltn(data, '', r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var cbf = function () {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for (var i = 0; i < slft; ++i) {\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            }\n            catch (e) {\n                return cb(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cb(null, out);\n    };\n    if (!lft)\n        cbf();\n    var _loop_1 = function (i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            }\n            else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || (m && (com.length != ms)),\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft)\n                    cbf();\n            }\n        };\n        if (s > 65535)\n            cbl('filename too long', null);\n        if (!compression)\n            cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            }\n            catch (e) {\n                cbl(e, null);\n            }\n        }\n        else\n            term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for (var i = 0; i < slft; ++i) {\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nexport function zipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, '', r, opts);\n    var o = 0;\n    var tot = 0;\n    for (var fn in r) {\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535)\n            throw 'filename too long';\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || (m && (com.length != ms)),\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for (var i = 0; i < files.length; ++i) {\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Streaming pass-through decompression for ZIP archives\n */\nvar UnzipPassThrough = /*#__PURE__*/ (function () {\n    function UnzipPassThrough() {\n    }\n    UnzipPassThrough.prototype.push = function (data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}());\nexport { UnzipPassThrough };\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */\nvar UnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function UnzipInflate() {\n        var _this_1 = this;\n        this.i = new Inflate(function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function (data, final) {\n        try {\n            this.i.push(data, final);\n        }\n        catch (e) {\n            this.ondata(e, data, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}());\nexport { UnzipInflate };\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */\nvar AsyncUnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function AsyncUnzipInflate(_, sz) {\n        var _this_1 = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function (dat, final) {\n                _this_1.ondata(null, dat, final);\n            });\n        }\n        else {\n            this.i = new AsyncInflate(function (err, dat, final) {\n                _this_1.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function (data, final) {\n        if (this.i.terminate)\n            data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}());\nexport { AsyncUnzipInflate };\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */\nvar Unzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */\n    function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzip.prototype.push = function (chunk, final) {\n        var _this_1 = this;\n        if (!this.onfile)\n            throw 'no callback';\n        if (!this.p)\n            throw 'stream finished';\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d)\n                this.d.push(toAdd, !this.c);\n            else\n                this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length)\n                return this.push(chunk, final);\n        }\n        else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length)\n                buf = chunk;\n            else if (!chunk.length)\n                buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function () {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_2 = [];\n                        this_1.k.unshift(chks_2);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        }\n                        else if (dd)\n                            sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function () {\n                                if (!file_1.ondata)\n                                    throw 'no callback';\n                                if (!sc_1)\n                                    file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this_1.o[cmp_1];\n                                    if (!ctr)\n                                        throw 'unknown compression type ' + cmp_1;\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function (err, dat, final) { file_1.ondata(err, dat, final); };\n                                    for (var _i = 0, chks_3 = chks_2; _i < chks_3.length; _i++) {\n                                        var dat = chks_3[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this_1.k[0] == chks_2 && _this_1.c)\n                                        _this_1.d = d_1;\n                                    else\n                                        d_1.push(et, true);\n                                }\n                            },\n                            terminate: function () {\n                                if (d_1 && d_1.terminate)\n                                    d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0)\n                            file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                }\n                else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                    else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for (; i < l - 4; ++i) {\n                var state_1 = _loop_2();\n                if (state_1 === \"break\")\n                    break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add)\n                    add.push(dat, !!f);\n                else\n                    this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2)\n                return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c)\n                throw 'invalid zip file';\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */\n    Unzip.prototype.register = function (decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}());\nexport { Unzip };\n/**\n * Asynchronously decompresses a ZIP archive\n * @param data The raw compressed ZIP file\n * @param cb The callback to call with the decompressed files\n * @returns A function that can be used to immediately terminate the unzipping\n */\nexport function unzip(data, cb) {\n    if (typeof cb != 'function')\n        throw 'no callback';\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558) {\n            cb('invalid zip file', null);\n            return;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (!lft)\n        cb(null, {});\n    var c = lft;\n    var o = b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = b4(data, e - 12);\n        if (b4(data, e) != 0x6064B50) {\n            cb('invalid zip file', null);\n            return;\n        }\n        c = lft = b4(data, e + 32);\n        o = b4(data, e + 48);\n    }\n    var _loop_3 = function (i) {\n        var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            }\n            else {\n                files[fn] = d;\n                if (!--lft)\n                    cb(null, files);\n            }\n        };\n        if (!c_1)\n            cbl(null, slc(data, b, b + sc));\n        else if (c_1 == 8) {\n            var infl = data.subarray(b, b + sc);\n            if (sc < 320000) {\n                try {\n                    cbl(null, inflateSync(infl, new u8(su)));\n                }\n                catch (e) {\n                    cbl(e, null);\n                }\n            }\n            else\n                term.push(inflate(infl, { size: su }, cbl));\n        }\n        else\n            cbl('unknown compression type ' + c_1, null);\n    };\n    for (var i = 0; i < c; ++i) {\n        _loop_3(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @returns The decompressed files\n */\nexport function unzipSync(data) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558)\n            throw 'invalid zip file';\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c)\n        return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = b4(data, e - 12);\n        if (b4(data, e) != 0x6064B50)\n            throw 'invalid zip file';\n        c = b4(data, e + 32);\n        o = b4(data, e + 48);\n    }\n    for (var i = 0; i < c; ++i) {\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!c_2)\n            files[fn] = slc(data, b, b + sc);\n        else if (c_2 == 8)\n            files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));\n        else\n            throw 'unknown compression type ' + c_2;\n    }\n    return files;\n}\n","import {\n\tCurve,\n\tVector3,\n\tVector4\n} from 'three';\nimport * as NURBSUtils from '../curves/NURBSUtils.js';\n\n/**\n * NURBS curve object\n *\n * Derives from Curve, overriding getPoint and getTangent.\n *\n * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.\n *\n **/\n\nclass NURBSCurve extends Curve {\n\n\tconstructor(\n\t\tdegree,\n\t\tknots /* array of reals */,\n\t\tcontrolPoints /* array of Vector(2|3|4) */,\n\t\tstartKnot /* index in knots */,\n\t\tendKnot /* index in knots */\n\t) {\n\n\t\tsuper();\n\n\t\tthis.degree = degree;\n\t\tthis.knots = knots;\n\t\tthis.controlPoints = [];\n\t\t// Used by periodic NURBS to remove hidden spans\n\t\tthis.startKnot = startKnot || 0;\n\t\tthis.endKnot = endKnot || ( this.knots.length - 1 );\n\n\t\tfor ( let i = 0; i < controlPoints.length; ++ i ) {\n\n\t\t\t// ensure Vector4 for control points\n\t\t\tconst point = controlPoints[ i ];\n\t\t\tthis.controlPoints[ i ] = new Vector4( point.x, point.y, point.z, point.w );\n\n\t\t}\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst u = this.knots[ this.startKnot ] + t * ( this.knots[ this.endKnot ] - this.knots[ this.startKnot ] ); // linear mapping t->u\n\n\t\t// following results in (wx, wy, wz, w) homogeneous point\n\t\tconst hpoint = NURBSUtils.calcBSplinePoint( this.degree, this.knots, this.controlPoints, u );\n\n\t\tif ( hpoint.w !== 1.0 ) {\n\n\t\t\t// project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)\n\t\t\thpoint.divideScalar( hpoint.w );\n\n\t\t}\n\n\t\treturn point.set( hpoint.x, hpoint.y, hpoint.z );\n\n\t}\n\n\tgetTangent( t, optionalTarget = new Vector3() ) {\n\n\t\tconst tangent = optionalTarget;\n\n\t\tconst u = this.knots[ 0 ] + t * ( this.knots[ this.knots.length - 1 ] - this.knots[ 0 ] );\n\t\tconst ders = NURBSUtils.calcNURBSDerivatives( this.degree, this.knots, this.controlPoints, u, 1 );\n\t\ttangent.copy( ders[ 1 ] ).normalize();\n\n\t\treturn tangent;\n\n\t}\n\n}\n\nexport { NURBSCurve };\n","import {\n\tVector3,\n\tVector4\n} from 'three';\n\n/**\n * NURBS utils\n *\n * See NURBSCurve and NURBSSurface.\n **/\n\n\n/**************************************************************\n *\tNURBS Utils\n **************************************************************/\n\n/*\nFinds knot vector span.\n\np : degree\nu : parametric value\nU : knot vector\n\nreturns the span\n*/\nfunction findSpan( p, u, U ) {\n\n\tconst n = U.length - p - 1;\n\n\tif ( u >= U[ n ] ) {\n\n\t\treturn n - 1;\n\n\t}\n\n\tif ( u <= U[ p ] ) {\n\n\t\treturn p;\n\n\t}\n\n\tlet low = p;\n\tlet high = n;\n\tlet mid = Math.floor( ( low + high ) / 2 );\n\n\twhile ( u < U[ mid ] || u >= U[ mid + 1 ] ) {\n\n\t\tif ( u < U[ mid ] ) {\n\n\t\t\thigh = mid;\n\n\t\t} else {\n\n\t\t\tlow = mid;\n\n\t\t}\n\n\t\tmid = Math.floor( ( low + high ) / 2 );\n\n\t}\n\n\treturn mid;\n\n}\n\n\n/*\nCalculate basis functions. See The NURBS Book, page 70, algorithm A2.2\n\nspan : span in which u lies\nu    : parametric point\np    : degree\nU    : knot vector\n\nreturns array[p+1] with basis functions values.\n*/\nfunction calcBasisFunctions( span, u, p, U ) {\n\n\tconst N = [];\n\tconst left = [];\n\tconst right = [];\n\tN[ 0 ] = 1.0;\n\n\tfor ( let j = 1; j <= p; ++ j ) {\n\n\t\tleft[ j ] = u - U[ span + 1 - j ];\n\t\tright[ j ] = U[ span + j ] - u;\n\n\t\tlet saved = 0.0;\n\n\t\tfor ( let r = 0; r < j; ++ r ) {\n\n\t\t\tconst rv = right[ r + 1 ];\n\t\t\tconst lv = left[ j - r ];\n\t\t\tconst temp = N[ r ] / ( rv + lv );\n\t\t\tN[ r ] = saved + rv * temp;\n\t\t\tsaved = lv * temp;\n\n\t\t}\n\n\t\tN[ j ] = saved;\n\n\t}\n\n\treturn N;\n\n}\n\n\n/*\nCalculate B-Spline curve points. See The NURBS Book, page 82, algorithm A3.1.\n\np : degree of B-Spline\nU : knot vector\nP : control points (x, y, z, w)\nu : parametric point\n\nreturns point for given u\n*/\nfunction calcBSplinePoint( p, U, P, u ) {\n\n\tconst span = findSpan( p, u, U );\n\tconst N = calcBasisFunctions( span, u, p, U );\n\tconst C = new Vector4( 0, 0, 0, 0 );\n\n\tfor ( let j = 0; j <= p; ++ j ) {\n\n\t\tconst point = P[ span - p + j ];\n\t\tconst Nj = N[ j ];\n\t\tconst wNj = point.w * Nj;\n\t\tC.x += point.x * wNj;\n\t\tC.y += point.y * wNj;\n\t\tC.z += point.z * wNj;\n\t\tC.w += point.w * Nj;\n\n\t}\n\n\treturn C;\n\n}\n\n\n/*\nCalculate basis functions derivatives. See The NURBS Book, page 72, algorithm A2.3.\n\nspan : span in which u lies\nu    : parametric point\np    : degree\nn    : number of derivatives to calculate\nU    : knot vector\n\nreturns array[n+1][p+1] with basis functions derivatives\n*/\nfunction calcBasisFunctionDerivatives( span, u, p, n, U ) {\n\n\tconst zeroArr = [];\n\tfor ( let i = 0; i <= p; ++ i )\n\t\tzeroArr[ i ] = 0.0;\n\n\tconst ders = [];\n\n\tfor ( let i = 0; i <= n; ++ i )\n\t\tders[ i ] = zeroArr.slice( 0 );\n\n\tconst ndu = [];\n\n\tfor ( let i = 0; i <= p; ++ i )\n\t\tndu[ i ] = zeroArr.slice( 0 );\n\n\tndu[ 0 ][ 0 ] = 1.0;\n\n\tconst left = zeroArr.slice( 0 );\n\tconst right = zeroArr.slice( 0 );\n\n\tfor ( let j = 1; j <= p; ++ j ) {\n\n\t\tleft[ j ] = u - U[ span + 1 - j ];\n\t\tright[ j ] = U[ span + j ] - u;\n\n\t\tlet saved = 0.0;\n\n\t\tfor ( let r = 0; r < j; ++ r ) {\n\n\t\t\tconst rv = right[ r + 1 ];\n\t\t\tconst lv = left[ j - r ];\n\t\t\tndu[ j ][ r ] = rv + lv;\n\n\t\t\tconst temp = ndu[ r ][ j - 1 ] / ndu[ j ][ r ];\n\t\t\tndu[ r ][ j ] = saved + rv * temp;\n\t\t\tsaved = lv * temp;\n\n\t\t}\n\n\t\tndu[ j ][ j ] = saved;\n\n\t}\n\n\tfor ( let j = 0; j <= p; ++ j ) {\n\n\t\tders[ 0 ][ j ] = ndu[ j ][ p ];\n\n\t}\n\n\tfor ( let r = 0; r <= p; ++ r ) {\n\n\t\tlet s1 = 0;\n\t\tlet s2 = 1;\n\n\t\tconst a = [];\n\t\tfor ( let i = 0; i <= p; ++ i ) {\n\n\t\t\ta[ i ] = zeroArr.slice( 0 );\n\n\t\t}\n\n\t\ta[ 0 ][ 0 ] = 1.0;\n\n\t\tfor ( let k = 1; k <= n; ++ k ) {\n\n\t\t\tlet d = 0.0;\n\t\t\tconst rk = r - k;\n\t\t\tconst pk = p - k;\n\n\t\t\tif ( r >= k ) {\n\n\t\t\t\ta[ s2 ][ 0 ] = a[ s1 ][ 0 ] / ndu[ pk + 1 ][ rk ];\n\t\t\t\td = a[ s2 ][ 0 ] * ndu[ rk ][ pk ];\n\n\t\t\t}\n\n\t\t\tconst j1 = ( rk >= - 1 ) ? 1 : - rk;\n\t\t\tconst j2 = ( r - 1 <= pk ) ? k - 1 : p - r;\n\n\t\t\tfor ( let j = j1; j <= j2; ++ j ) {\n\n\t\t\t\ta[ s2 ][ j ] = ( a[ s1 ][ j ] - a[ s1 ][ j - 1 ] ) / ndu[ pk + 1 ][ rk + j ];\n\t\t\t\td += a[ s2 ][ j ] * ndu[ rk + j ][ pk ];\n\n\t\t\t}\n\n\t\t\tif ( r <= pk ) {\n\n\t\t\t\ta[ s2 ][ k ] = - a[ s1 ][ k - 1 ] / ndu[ pk + 1 ][ r ];\n\t\t\t\td += a[ s2 ][ k ] * ndu[ r ][ pk ];\n\n\t\t\t}\n\n\t\t\tders[ k ][ r ] = d;\n\n\t\t\tconst j = s1;\n\t\t\ts1 = s2;\n\t\t\ts2 = j;\n\n\t\t}\n\n\t}\n\n\tlet r = p;\n\n\tfor ( let k = 1; k <= n; ++ k ) {\n\n\t\tfor ( let j = 0; j <= p; ++ j ) {\n\n\t\t\tders[ k ][ j ] *= r;\n\n\t\t}\n\n\t\tr *= p - k;\n\n\t}\n\n\treturn ders;\n\n}\n\n\n/*\n\tCalculate derivatives of a B-Spline. See The NURBS Book, page 93, algorithm A3.2.\n\n\tp  : degree\n\tU  : knot vector\n\tP  : control points\n\tu  : Parametric points\n\tnd : number of derivatives\n\n\treturns array[d+1] with derivatives\n\t*/\nfunction calcBSplineDerivatives( p, U, P, u, nd ) {\n\n\tconst du = nd < p ? nd : p;\n\tconst CK = [];\n\tconst span = findSpan( p, u, U );\n\tconst nders = calcBasisFunctionDerivatives( span, u, p, du, U );\n\tconst Pw = [];\n\n\tfor ( let i = 0; i < P.length; ++ i ) {\n\n\t\tconst point = P[ i ].clone();\n\t\tconst w = point.w;\n\n\t\tpoint.x *= w;\n\t\tpoint.y *= w;\n\t\tpoint.z *= w;\n\n\t\tPw[ i ] = point;\n\n\t}\n\n\tfor ( let k = 0; k <= du; ++ k ) {\n\n\t\tconst point = Pw[ span - p ].clone().multiplyScalar( nders[ k ][ 0 ] );\n\n\t\tfor ( let j = 1; j <= p; ++ j ) {\n\n\t\t\tpoint.add( Pw[ span - p + j ].clone().multiplyScalar( nders[ k ][ j ] ) );\n\n\t\t}\n\n\t\tCK[ k ] = point;\n\n\t}\n\n\tfor ( let k = du + 1; k <= nd + 1; ++ k ) {\n\n\t\tCK[ k ] = new Vector4( 0, 0, 0 );\n\n\t}\n\n\treturn CK;\n\n}\n\n\n/*\nCalculate \"K over I\"\n\nreturns k!/(i!(k-i)!)\n*/\nfunction calcKoverI( k, i ) {\n\n\tlet nom = 1;\n\n\tfor ( let j = 2; j <= k; ++ j ) {\n\n\t\tnom *= j;\n\n\t}\n\n\tlet denom = 1;\n\n\tfor ( let j = 2; j <= i; ++ j ) {\n\n\t\tdenom *= j;\n\n\t}\n\n\tfor ( let j = 2; j <= k - i; ++ j ) {\n\n\t\tdenom *= j;\n\n\t}\n\n\treturn nom / denom;\n\n}\n\n\n/*\nCalculate derivatives (0-nd) of rational curve. See The NURBS Book, page 127, algorithm A4.2.\n\nPders : result of function calcBSplineDerivatives\n\nreturns array with derivatives for rational curve.\n*/\nfunction calcRationalCurveDerivatives( Pders ) {\n\n\tconst nd = Pders.length;\n\tconst Aders = [];\n\tconst wders = [];\n\n\tfor ( let i = 0; i < nd; ++ i ) {\n\n\t\tconst point = Pders[ i ];\n\t\tAders[ i ] = new Vector3( point.x, point.y, point.z );\n\t\twders[ i ] = point.w;\n\n\t}\n\n\tconst CK = [];\n\n\tfor ( let k = 0; k < nd; ++ k ) {\n\n\t\tconst v = Aders[ k ].clone();\n\n\t\tfor ( let i = 1; i <= k; ++ i ) {\n\n\t\t\tv.sub( CK[ k - i ].clone().multiplyScalar( calcKoverI( k, i ) * wders[ i ] ) );\n\n\t\t}\n\n\t\tCK[ k ] = v.divideScalar( wders[ 0 ] );\n\n\t}\n\n\treturn CK;\n\n}\n\n\n/*\nCalculate NURBS curve derivatives. See The NURBS Book, page 127, algorithm A4.2.\n\np  : degree\nU  : knot vector\nP  : control points in homogeneous space\nu  : parametric points\nnd : number of derivatives\n\nreturns array with derivatives.\n*/\nfunction calcNURBSDerivatives( p, U, P, u, nd ) {\n\n\tconst Pders = calcBSplineDerivatives( p, U, P, u, nd );\n\treturn calcRationalCurveDerivatives( Pders );\n\n}\n\n\n/*\nCalculate rational B-Spline surface point. See The NURBS Book, page 134, algorithm A4.3.\n\np1, p2 : degrees of B-Spline surface\nU1, U2 : knot vectors\nP      : control points (x, y, z, w)\nu, v   : parametric values\n\nreturns point for given (u, v)\n*/\nfunction calcSurfacePoint( p, q, U, V, P, u, v, target ) {\n\n\tconst uspan = findSpan( p, u, U );\n\tconst vspan = findSpan( q, v, V );\n\tconst Nu = calcBasisFunctions( uspan, u, p, U );\n\tconst Nv = calcBasisFunctions( vspan, v, q, V );\n\tconst temp = [];\n\n\tfor ( let l = 0; l <= q; ++ l ) {\n\n\t\ttemp[ l ] = new Vector4( 0, 0, 0, 0 );\n\t\tfor ( let k = 0; k <= p; ++ k ) {\n\n\t\t\tconst point = P[ uspan - p + k ][ vspan - q + l ].clone();\n\t\t\tconst w = point.w;\n\t\t\tpoint.x *= w;\n\t\t\tpoint.y *= w;\n\t\t\tpoint.z *= w;\n\t\t\ttemp[ l ].add( point.multiplyScalar( Nu[ k ] ) );\n\n\t\t}\n\n\t}\n\n\tconst Sw = new Vector4( 0, 0, 0, 0 );\n\tfor ( let l = 0; l <= q; ++ l ) {\n\n\t\tSw.add( temp[ l ].multiplyScalar( Nv[ l ] ) );\n\n\t}\n\n\tSw.divideScalar( Sw.w );\n\ttarget.set( Sw.x, Sw.y, Sw.z );\n\n}\n\n\n\nexport {\n\tfindSpan,\n\tcalcBasisFunctions,\n\tcalcBSplinePoint,\n\tcalcBasisFunctionDerivatives,\n\tcalcBSplineDerivatives,\n\tcalcKoverI,\n\tcalcRationalCurveDerivatives,\n\tcalcNURBSDerivatives,\n\tcalcSurfacePoint,\n};\n","import * as THREE from 'three';\r\nimport { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader.js';\r\n\r\nconst clock = new THREE.Clock();\r\n\r\n\r\nconst main_canvas = document.getElementById(\"second-canvas\");\r\n\r\nconst n = 1;\r\nlet cwidth = 640 / n;\r\nlet cheight = 640 / n;\r\nmain_canvas.setAttribute(\"width\", cwidth + \"px\");\r\nmain_canvas.setAttribute(\"height\", cheight + \"px\");\r\n\r\nconst scene = new THREE.Scene();\r\nconst camera = new THREE.PerspectiveCamera(75, main_canvas.clientWidth / main_canvas.clientHeight, 0.1, 1000);\r\n\r\nconst renderer = new THREE.WebGLRenderer({\r\n  antialias: true,\r\n  canvas: main_canvas\r\n  // alpha: true\r\n});\r\n\r\ncamera.position.set(0,5.5,2.5);\r\ncamera.rotateY(0.2);\r\nvar light = new THREE.DirectionalLight( 'white', 0.5 );\r\nlight.position.set( 1, 1, 1 );\r\nscene.add( light );\r\n\r\nvar ambient = new THREE.AmbientLight('white', 0.5);\r\nscene.add(ambient);\r\n\r\nscene.background = new THREE.Color(0x72809e); // dark\r\n\r\nlet mixer;\r\nlet head;\r\nconst model = new Promise((res, rej) => {\r\n  const loader = new FBXLoader();\r\n  loader.load('./assets/low_poly_man.fbx', (fbx) => {\r\n    fbx.scale.setScalar(0.01);\r\n    fbx.traverse(c => {\r\n      c.castShadow = true;\r\n    });\r\n    head = fbx.getObjectByName('mixamorigHead');\r\n    res(fbx);\r\n  });\r\n})\r\n\r\n\r\nconst animation1 = new Promise((res, rej) => {\r\n  const loader = new FBXLoader();\r\n  loader.load('./assets/Waving.fbx', (fbx) => {\r\n    res(fbx);\r\n  });\r\n})\r\nconst animation2 = new Promise((res, rej) => {\r\n  const loader = new FBXLoader();\r\n  loader.load('./assets/Arm Stretching.fbx', (fbx) => {\r\n    res(fbx);\r\n  });\r\n})\r\n\r\nconst combo = Promise.all([model, animation1, animation2]);\r\n\r\n\r\ncombo.then(object=>{\r\n  scene.add(object[0]);\r\n  mixer = new THREE.AnimationMixer( object[0] );\r\n  object[0].animations = object[1].animation;\r\n  const action1 = mixer.clipAction(object[1].animations[0]);\r\n  action1._clip.name = 'waving';\r\n  const action2 = mixer.clipAction(object[2].animations[0]);\r\n  action2._clip.name = 'armstretching';\r\n  action1.play();\r\n  // action1.loop = THREE.LoopOnce;\r\n  action2.loop = THREE.LoopOnce;\r\n  let wave_counter = 0;\r\n  mixer.addEventListener('finished', function(e) {\r\n    if(e.action._clip.name == 'waving' && wave_counter < 5){\r\n      wave_counter++;\r\n      action1.reset();\r\n      action1.play();\r\n      if (wave_counter == 4){\r\n        wave_counter = 0;\r\n        action1.stop();\r\n        action2.play();\r\n      }  \r\n    } else if(e.action._clip.name == 'armstretching'){\r\n      action2.stop();\r\n      action1.play();\r\n    }\r\n  });\r\n\r\n})\r\n\r\nconst target = new THREE.Object3D();\r\nconst mousePosition = new THREE.Vector2();\r\ntarget.position.set(0.2, 5.2, 2); // good initial target position\r\n\r\n\r\nfunction animate() {\r\n  const delta = clock.getDelta();\r\n\r\n  if (mixer) mixer.update(delta);\r\n  if (head) {\r\n    head.lookAt(target.position);\r\n  }\r\n\r\n  requestAnimationFrame(animate);\r\n  renderer.render(scene, camera);\r\n}\r\n\r\nanimate();\r\n\r\nlet mobile = false;\r\n\r\nif(window.matchMedia(\"(any-hover: none)\").matches) {\r\n  mobile = true;\r\n}\r\n\r\nlet lastKnownScrollPosition = 0;\r\nlet ticking = false;\r\n\r\nif (!mobile){\r\n\r\n  window.addEventListener('mousemove', (e) => {\r\n    mousePosition.x = 2 * ((e.clientX/window.innerWidth) * 2 - 1) ;\r\n    mousePosition.y = -2 * (e.clientY/window.innerHeight) * 2 + 7 ;\r\n    target.position.set(mousePosition.x, mousePosition.y, 2);\r\n  });\r\n}\r\n else {\r\n  document.addEventListener(\"scroll\", (event) => {\r\n    lastKnownScrollPosition = window.scrollY;\r\n  \r\n    if (!ticking) {\r\n      window.requestAnimationFrame(() => {\r\n        doSomething(lastKnownScrollPosition);\r\n        ticking = false;\r\n      });\r\n  \r\n      ticking = true;\r\n    }\r\n  });\r\n }\r\n\r\n\r\nfunction doSomething(scrollPos) {\r\n  // Do something with the scroll position\r\n  target.position.set(0.2,\r\n     5.2 * (1 - (scrollPos/1000)),\r\n     2);\r\n}\r\n"],"names":["$3d6a91fea9ae46ce$var$mixer","$3d6a91fea9ae46ce$var$head","$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$04ef886a022e9ae8$var$fbxTree","$04ef886a022e9ae8$var$connections","$04ef886a022e9ae8$var$sceneGraph","$04ef886a022e9ae8$export$60c52e42bb04b96","$ilwiq","$79Zxq","$cLt9Z","Loader","constructor","manager","load","url","onLoad","onProgress","onError","scope","path","LoaderUtils","extractUrlBase","loader","FileLoader","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","buffer","parse","console","error","itemError","FBXBuffer","$04ef886a022e9ae8$var$isFbxFormatBinary","CORRECT","byteLength","length","$04ef886a022e9ae8$var$convertArrayBufferToString","$04ef886a022e9ae8$var$BinaryParser","FBXText","$04ef886a022e9ae8$var$isFbxFormatASCII","text","cursor","i","num","read","offset","result","slice","$04ef886a022e9ae8$var$getFbxVersion","$04ef886a022e9ae8$var$TextParser","$04ef886a022e9ae8$var$FBXTreeParser","TextureLoader","resourcePath","setCrossOrigin","crossOrigin","textureLoader","parseConnections","images","parseImages","textures","parseTextures","materials","parseMaterials","deformers","parseDeformers","geometryMap","$04ef886a022e9ae8$var$GeometryParser","parseScene","connectionMap","Map","rawConnections","Connections","connections","forEach","rawConnection","fromID","toID","relationship","has","parents","children","push","ID","blobs","Objects","videoNodes","Video","nodeID","videoNode","parseInt","RelativeFilename","Filename","arrayBufferContent","Content","ArrayBuffer","base64Content","image","parseImage","filename","undefined","split","pop","type","content","fileName","extension","lastIndexOf","toLowerCase","getHandler","warn","array","Uint8Array","window","URL","createObjectURL","Blob","textureMap","textureNodes","Texture","texture","parseTexture","textureNode","loadTexture","name","attrName","wrapModeU","WrapModeU","wrapModeV","WrapModeV","valueU","value","valueV","wrapS","RepeatWrapping","ClampToEdgeWrapping","wrapT","values","Scaling","repeat","x","y","Translation","currentPath","indexOf","FileName","materialMap","materialNodes","Material","material","parseMaterial","materialNode","ShadingModel","parameters","parseParameters","MeshPhongMaterial","MeshLambertMaterial","setValues","BumpFactor","bumpScale","Diffuse","color","Color","fromArray","convertSRGBToLinear","DiffuseColor","DisplacementFactor","displacementScale","Emissive","emissive","EmissiveColor","EmissiveFactor","emissiveIntensity","parseFloat","Opacity","opacity","transparent","ReflectionFactor","reflectivity","Shininess","shininess","Specular","specular","SpecularColor","child","bumpMap","getTexture","aoMap","map","encoding","sRGBEncoding","displacementMap","emissiveMap","normalMap","envMap","mapping","EquirectangularReflectionMapping","specularMap","alphaMap","LayeredTexture","skeletons","morphTargets","DeformerNodes","Deformer","deformerNode","relationships","attrType","skeleton","parseSkeleton","geometryID","morphTarget","rawTargets","parseMorphTargets","deformerNodes","rawBones","boneNode","rawBone","indices","weights","transformLink","Matrix4","TransformLink","a","Indexes","Weights","bones","rawMorphTargets","morphTargetNode","rawMorphTarget","initialWeight","DeformPercent","fullWeights","FullWeights","geoID","filter","Group","modelMap","parseModels","modelNodes","Model","model","modelNode","setLookAtProperties","parentConnections","connection","parent","add","bindSkeleton","createAmbientLight","traverse","node","userData","transformData","parentMatrix","matrix","parentMatrixWorld","matrixWorld","transform","$04ef886a022e9ae8$var$generateTransform","applyMatrix4","updateWorldMatrix","animations","$04ef886a022e9ae8$var$AnimationParser","isGroup","buildSkeleton","createCamera","createLight","createMesh","createCurve","Bone","PropertyBinding","sanitizeNodeName","getTransformData","bone","subBone","copy","cameraAttribute","attr","NodeAttribute","Object3D","CameraProjectionType","nearClippingPlane","NearPlane","farClippingPlane","FarPlane","width","innerWidth","height","innerHeight","AspectWidth","AspectHeight","aspect","fov","FieldOfView","focalLength","FocalLength","PerspectiveCamera","setFocalLength","OrthographicCamera","lightAttribute","LightType","intensity","Intensity","CastLightOnObject","distance","FarAttenuationEnd","EnableFarAttenuation","PointLight","DirectionalLight","angle","Math","PI","InnerAngle","MathUtils","degToRad","penumbra","OuterAngle","max","SpotLight","CastShadows","castShadow","geometry","attributes","vertexColors","FBX_Deformer","SkinnedMesh","normalizeSkinWeights","Mesh","reduce","geo","LineBasicMaterial","linewidth","Line","inheritType","InheritType","eulerOrder","$04ef886a022e9ae8$var$getEulerOrder","RotationOrder","translation","Lcl_Translation","preRotation","PreRotation","rotation","Lcl_Rotation","postRotation","PostRotation","scale","Lcl_Scaling","scalingOffset","ScalingOffset","scalingPivot","ScalingPivot","rotationOffset","RotationOffset","rotationPivot","RotationPivot","lookAtTarget","pos","target","position","lookAt","Vector3","bindMatrices","parsePoseNodes","geoRelationships","geoConnParent","bind","Skeleton","BindPoseNode","Pose","NbPoseNodes","poseNodes","PoseNode","Array","isArray","poseNode","Node","Matrix","GlobalSettings","ambientColor","AmbientColor","r","g","b","AmbientLight","negativeMaterialIndices","geoNodes","Geometry","parseGeometry","geoNode","parseMeshGeometry","parseNurbsGeometry","GeometricTranslation","GeometricRotation","GeometricScaling","genGeometry","preTransform","BufferGeometry","geoInfo","parseGeoNode","buffers","genBuffers","positionAttribute","Float32BufferAttribute","vertex","setAttribute","colors","Uint16BufferAttribute","weightsIndices","vertexWeights","normal","normalMatrix","Matrix3","getNormalMatrix","normalAttribute","applyNormalMatrix","uvs","uvBuffer","toString","mappingType","prevMaterialIndex","materialIndex","startIndex","currentIndex","addGroup","groups","lastGroup","lastIndex","start","count","addMorphTargets","vertexPositions","Vertices","vertexIndices","PolygonVertexIndex","LayerElementColor","parseVertexColors","LayerElementMaterial","parseMaterialIndices","LayerElementNormal","parseNormals","LayerElementUV","uv","UV","parseUVs","weightTable","index","j","weight","polygonIndex","faceLength","displayedWeightsWarning","facePositionIndexes","faceNormals","faceColors","faceUVs","faceWeights","faceWeightIndices","vertexIndex","polygonVertexIndex","endOfFace","weightIndices","data","$04ef886a022e9ae8$var$getData","wt","wIndex","Weight","weightIndex","currentWeight","comparedWeight","comparedWeightIndex","comparedWeightArray","tmp","genFace","parentGeo","parentGeoNode","morphTargetsRelative","morphAttributes","rawTarget","morphGeoNode","genMorphGeometry","morphPositionsSparse","morphPositions","Float32Array","morphIndex","morphBuffers","NormalNode","MappingInformationType","referenceType","ReferenceInformationType","Normals","indexBuffer","NormalIndex","NormalsIndex","dataSize","UVNode","UVIndex","ColorNode","Colors","ColorIndex","c","toArray","MaterialNode","materialIndexBuffer","Materials","materialIndices","startKnot","endKnot","order","Order","isNaN","degree","knots","KnotVector","controlPoints","pointsValues","Points","l","Vector4","Form","points","curve","NURBSCurve","getPoints","setFromPoints","animationClips","rawClips","parseClips","key","rawClip","clip","addClip","AnimationCurve","curveNodesMap","parseAnimationCurveNodes","parseAnimationCurves","layersMap","parseAnimationLayers","parseAnimStacks","rawCurveNodes","AnimationCurveNode","rawCurveNode","match","curveNode","curves","rawCurves","animationCurve","times","KeyTime","$04ef886a022e9ae8$var$convertFBXTimeToSeconds","KeyValueFloat","animationCurveID","animationCurveRelationship","rawLayers","AnimationLayer","layerCurveNodes","z","modelID","rawModel","modelName","initialPosition","initialRotation","initialScale","morph","deformerID","morpherID","morphName","rawStacks","AnimationStack","layer","tracks","rawTracks","concat","generateTracks","AnimationClip","Quaternion","decompose","Euler","setFromQuaternion","T","keys","positionTrack","generateVectorTrack","R","rotationTrack","generateRotationTrack","S","scaleTrack","morphTrack","generateMorphTrack","initialValue","getTimesForAllAxes","getKeyframeTrackValues","VectorKeyframeTrack","interpolateRotations","setFromEuler","invert","quaternion","euler","quaternionValues","premultiply","multiply","QuaternionKeyframeTrack","val","morphNum","getObjectByName","morphTargetDictionary","NumberKeyframeTrack","sort","targetIndex","lastValue","currentValue","xIndex","yIndex","zIndex","time","xValue","prevValue","yValue","zValue","valuesSpan","absoluteSpan","abs","numSubIntervals","step","nextValue","initialTime","interval","timeSpan","nextTime","interpolatedTimes","interpolatedValues","$04ef886a022e9ae8$var$inject","getPrevNode","nodeStack","currentIndent","getCurrentNode","getCurrentProp","currentProp","pushStack","popStack","setCurrentProp","currentPropName","allNodes","$04ef886a022e9ae8$var$FBXTree","line","matchComment","matchEmpty","matchBeginning","matchProperty","matchEnd","parseNodeBegin","parseNodeProperty","parseNodePropertyContinued","property","nodeName","trim","replace","nodeAttrs","attrs","parseNodeAttr","currentNode","contentLine","propName","propValue","parentName","parseNodeSpecialProperty","connProps","from","to","rest","elem","$04ef886a022e9ae8$var$append","$04ef886a022e9ae8$var$parseNumberArray","props","prop","innerPropName","innerPropType1","innerPropType2","innerPropFlag","innerPropValue","reader","$04ef886a022e9ae8$var$BinaryReader","skip","version","getUint32","endOfContent","parseNode","size","getOffset","endOffset","getUint64","numProperties","nameLen","getUint8","getString","propertyList","parseProperty","singleProperty","subNode","parseSubNode","getBoolean","getFloat64","getFloat32","getInt32","getInt64","getArrayBuffer","getInt16","arrayLength","compressedLength","getBooleanArray","getFloat64Array","getFloat32Array","getInt32Array","getInt64Array","reader2","unzlibSync","littleEndian","dv","DataView","_textDecoder","TextDecoder","low","high","nullByte","decode","$04ef886a022e9ae8$var$dataArray","infoObject","$04ef886a022e9ae8$var$slice","$04ef886a022e9ae8$var$tempEuler","$04ef886a022e9ae8$var$tempVec","lTranslationM","lPreRotationM","lRotationM","lPostRotationM","lScalingM","lScalingPivotM","lScalingOffsetM","lRotationOffsetM","lRotationPivotM","lParentGX","lParentLX","lGlobalT","setPosition","DEFAULT_ORDER","makeRotationFromEuler","lLRM","clone","lParentGRM","extractRotation","lParentTM","copyPosition","lParentGRSM","lParentGSM","lGlobalRS","lParentLSM_inv","lParentLSM","setFromMatrixScale","lParentGSM_noLocal","lRotationPivotM_inv","lScalingPivotM_inv","lTransform","lLocalTWithAllPivotAndOffsetInfo","lGlobalTranslation","enums","a1","a2","$53691bda533d12d0$export$9ec8134f0f1b9fc6","$53691bda533d12d0$var$ch2","$53691bda533d12d0$var$durl","$53691bda533d12d0$var$cwk","u","Worker","revokeObjectURL","encodeURI","$53691bda533d12d0$var$wk","msg","transfer","cb","w","onerror","onmessage","postMessage","$53691bda533d12d0$var$u8","$53691bda533d12d0$var$u16","Uint16Array","$53691bda533d12d0$var$u32","Uint32Array","$53691bda533d12d0$var$fleb","$53691bda533d12d0$var$fdeb","$53691bda533d12d0$var$clim","$53691bda533d12d0$var$freb","eb","$53691bda533d12d0$var$_a","$53691bda533d12d0$var$fl","$53691bda533d12d0$var$revfl","$53691bda533d12d0$var$_b","$53691bda533d12d0$var$fd","$53691bda533d12d0$var$revfd","$53691bda533d12d0$var$rev","$53691bda533d12d0$var$i","$53691bda533d12d0$var$x","$53691bda533d12d0$var$hMap","cd","mb","co","le","rvb","sv","r_1","m","$53691bda533d12d0$var$flt","$53691bda533d12d0$var$fdt","$53691bda533d12d0$var$flm","$53691bda533d12d0$var$flrm","$53691bda533d12d0$var$fdm","$53691bda533d12d0$var$fdrm","$53691bda533d12d0$var$max","$53691bda533d12d0$var$bits","d","p","o","$53691bda533d12d0$var$bits16","$53691bda533d12d0$var$shft","$53691bda533d12d0$var$slc","subarray","$53691bda533d12d0$var$inflt","dat","buf","st","sl","noBuf","noSt","cbuf","bl","nbuf","final","f","bt","lm","dm","lbt","dbt","tbts","hLit","hcLen","tl","ldt","clt","clb","clbmsk","clm","lt","dt","t","lms","dms","lpos","sym","dsym","end","$53691bda533d12d0$var$wbits","$53691bda533d12d0$var$wbits16","$53691bda533d12d0$var$hTree","t2","$53691bda533d12d0$var$et","i0","i1","i2","maxSym","tr","mbt","$53691bda533d12d0$var$ln","lft","cst","i2_1","i2_2","i2_3","$53691bda533d12d0$var$lc","cl","cli","cln","cls","$53691bda533d12d0$var$clen","cf","$53691bda533d12d0$var$wfblk","out","$53691bda533d12d0$var$wblk","syms","lf","df","li","bs","ll","dl","_a","dlt","mlb","_b","ddt","mdb","_c","lclt","nlc","_d","lcdt","ndc","lcfreq","_e","lct","mlcb","nlcc","flen","ftlen","dtlen","llm","lcts","it","clct","len","dst","$53691bda533d12d0$var$deo","$53691bda533d12d0$var$dflt","lvl","plvl","pre","post","lst","ceil","opt","msk_1","prev","head","bs1_1","bs2_1","hsh","lc_1","wi","hv","imod","pimod","rem","ch_1","dif","maxn","min","maxd","ml","nl","mmd","md","ti","pti","lin","din","$53691bda533d12d0$var$mrg","k","$53691bda533d12d0$var$wcln","fn","fnStr","td","ks","st_1","prototype","spInd","$53691bda533d12d0$var$ch","$53691bda533d12d0$var$cbfs","$53691bda533d12d0$var$zlv","$53691bda533d12d0$var$td","stream","$94b07e67f83726ad$export$12efb26d7429b049","$5joV2","Curve","point","getPoint","optionalTarget","hpoint","calcBSplinePoint","divideScalar","getTangent","ders","calcNURBSDerivatives","tangent","normalize","$3de20e7c02944e1d$export$3672a5d5ca534534","$3de20e7c02944e1d$export$692f68f163c8f6b","$3de20e7c02944e1d$export$5d44f085c0641ab4","U","mid","floor","P","span","N","$3de20e7c02944e1d$export$bbebd61f407f7f41","left","right","saved","rv","lv","temp","C","Nj","wNj","nd","$3de20e7c02944e1d$export$66805edec2c1a55d","Pders","Aders","wders","CK","sub","multiplyScalar","$3de20e7c02944e1d$export$3c88b91ac9312187","nom","denom","$3de20e7c02944e1d$export$ae5bff7435823e13","du","nders","$3de20e7c02944e1d$export$70bfab2ede47286","zeroArr","ndu","s1","s2","rk","pk","j1","j2","Pw","$qgTqt","$3d6a91fea9ae46ce$var$clock","Clock","$3d6a91fea9ae46ce$var$main_canvas","document","getElementById","$3d6a91fea9ae46ce$var$cwidth","$3d6a91fea9ae46ce$var$cheight","$3d6a91fea9ae46ce$var$scene","Scene","$3d6a91fea9ae46ce$var$camera","clientWidth","clientHeight","$3d6a91fea9ae46ce$var$renderer","WebGLRenderer","antialias","canvas","rotateY","$3d6a91fea9ae46ce$var$light","$3d6a91fea9ae46ce$var$ambient","background","$3d6a91fea9ae46ce$var$combo","Promise","all","res","rej","FBXLoader","fbx","setScalar","then","object","AnimationMixer","animation","action1","clipAction","_clip","action2","play","loop","LoopOnce","wave_counter","addEventListener","action","reset","stop","$3d6a91fea9ae46ce$var$target","$3d6a91fea9ae46ce$var$mousePosition","Vector2","$3d6a91fea9ae46ce$var$animate","delta","getDelta","update","requestAnimationFrame","render","$3d6a91fea9ae46ce$var$mobile","matchMedia","matches","$3d6a91fea9ae46ce$var$lastKnownScrollPosition","$3d6a91fea9ae46ce$var$ticking","event","scrollY","scrollPos","clientX","clientY"],"version":3,"file":"index.e6f06ddd.js.map"}